[
    {
        "instruction": [
            "Provide a Fortran function code named sum_string that calculates the sum of the ASCII values of characters in a given string. The function takes an input argument str of type character with unspecified length. The function returns an output argument sig of type integer. \n\nTo generate the sum, the function first converts the string into a character array named tmp using the forall statement. Then, it uses the sum function and the ichar function to compute the ASCII values of each character and sum them up. Finally, the function assigns the resulting sum to the output argument sig.\n\nWrite a Fortran function named sum_string that takes a string as input and returns the sum of the ASCII values of its characters. The input argument is a character string with unspecified length, and the output argument is an integer representing the sum.",
            "Provide a Fortran function named sum_string that calculates the sum of the ASCII values of all the characters in a given string. The function takes one input argument of type character array with variable length and has one output argument of type integer. The name of the function is sum_string.",
            "Write a Fortran function named sum_string that calculates the sum of the ASCII values of the characters in a given string. The function takes a single input argument of type character, which represents the string to be processed. The function returns an output of type integer, which represents the sum of the ASCII values.\n\nTo use the function, provide the string as the input argument when calling the function. The function will then iterate over each character in the string, convert it into an integer, and calculate the sum of the ASCII values of all the characters. The result will be returned as the output of the function."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=50) :: str\n  \n  !case1\n  str = \"Hello World!\"\n  print *, sum_string(str)\n  \n  !case2\n  str = \"1234567890\"\n  print *, sum_string(str)\n  \n  !case3\n  str = \"Testing 1 2 3\"\n  print *, sum_string(str)\n  \n  !case4\n  str = \"abcdefghijklmnopqrstuvwxyz\"\n  print *, sum_string(str)\n  \n  !case5\n  str = \"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz\"\n  print *, sum_string(str)\n  \nend program main",
            "result": [
                "2301",
                "1805",
                "2164",
                "3615",
                "4650"
            ]
        },
        "code": "  elemental function sum_string(str) result(sig)\n    character(len=*), intent(in)   :: str\n    integer                        :: sig\n    character, dimension(len(str)) :: tmp\n    integer :: i\n\n    forall (i=1:len(str))\n       tmp(i) = str(i:i)\n    end forall\n    sig = sum(ichar(tmp))\n  end function sum_string\n"
    },
    {
        "instruction": [
            "Create a Fortran function named \"distance\" that calculates the distance between two points in a Cartesian coordinate system. The function takes four input parameters of type real: \"ax\" and \"ay\" representing the coordinates of point A, and \"bx\" and \"by\" representing the coordinates of point B. The function returns a single output parameter, also of type real, representing the calculated distance.",
            "Write a Fortran function called \"distance\" that calculates the Euclidean distance between two points in a two-dimensional space. The function takes four input arguments of type real, representing the x and y coordinates of the two points. The function returns a single value of type real, representing the distance between the two points.",
            "Please create a Fortran function named \"distance\" that calculates the Euclidean distance between two points in a 2-dimensional space. The function should have four input parameters, which are the x and y coordinates of the first point (ax, ay) and the second point (bx, by). The function should return a single output value of type real, representing the calculated distance."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real :: ax, ay, bx, by\n\n  ! case 1\n  ax = 0.0\n  ay = 0.0\n  bx = 3.0\n  by = 4.0\n  print *, distance(ax, ay, bx, by)\n\n  ! case 2\n  ax = -2.3\n  ay = 5.7\n  bx = 1.2\n  by = -6.9\n  print *, distance(ax, ay, bx, by)\n\n  ! case 3\n  ax = -10.0\n  ay = 10.0\n  bx = 10.0\n  by = -10.0\n  print *, distance(ax, ay, bx, by)\n\n  ! case 4\n  ax = 0.0\n  ay = 0.0\n  bx = 0.0\n  by = 0.0\n  print *, distance(ax, ay, bx, by)\n\n  ! case 5\n  ax = 1.234\n  ay = -5.678\n  bx = -9.876\n  by = 3.210\n  print *, distance(ax, ay, bx, by)\nend program main",
            "result": [
                "5.00000000",
                "13.0770798",
                "28.2842712",
                "0.00000000",
                "14.2277431"
            ]
        },
        "code": "function distance(ax, ay, bx, by)\n    implicit none\n    real :: ax\n    real :: ay\n    real :: bx\n    real :: by\n    real :: distance\n    distance = ((bx - ax) ** 2 + (by - ay) ** 2) ** 0.5\n    return\nend function\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named unique that returns a new array containing only the unique values from the input array. The number of input arguments is 1 and the data type is an integer array. The number of output arguments is 1 and the data type is also an integer array.",
            "Please provide a Fortran function called \"unique\" that takes in an integer array as input. The function's purpose is to return an array that contains only the unique values from the input array. The function should have one input parameter of type integer array and one output parameter of type integer array.",
            "Give me a Fortran function code named unique that returns the unique values from an input vector.The number of input arguments is 1 and the test_data type is [integer array].The number of output arguments is 1 and the test_data type is [integer array]."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer, allocatable :: vec(:), vec_unique(:)\n  \n  !case1\n  allocate(vec(5))\n  vec = [1, 2, 3, 4, 5]\n  vec_unique = unique(vec)\n  print *, vec_unique\n  deallocate(vec, vec_unique)\n\n  !case2\n  allocate(vec(10))\n  vec = [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\n  vec_unique = unique(vec)\n  print *, vec_unique\n  deallocate(vec, vec_unique)\n\n  !case3\n  allocate(vec(6))\n  vec = [1, 1, 2, 3, 3, 4]\n  vec_unique = unique(vec)\n  print *, vec_unique\n  deallocate(vec, vec_unique)\n\n  !case4\n  allocate(vec(8))\n  vec = [5, 5, 5, 5, 5, 5, 5, 5]\n  vec_unique = unique(vec)\n  print *, vec_unique\n  deallocate(vec, vec_unique)\n\n  !case5\n  allocate(vec(7))\n  vec = [2, 1, 3, 2, 1, 3, 2]\n  vec_unique = unique(vec)\n  print *, vec_unique\n  deallocate(vec, vec_unique)\nend program main",
            "result": [
                "1           2           3           4           5",
                "1           2           3           4           5",
                "1           2           3           4",
                "5",
                "2           1           3"
            ]
        },
        "code": "function unique(vec) result(vec_unique)\n! return only the unique values from vec.\n\nimplicit none\n\ninteger,dimension(:),intent(in) :: vec\ninteger,dimension(:),allocatable :: vec_unique\n\ninteger :: i,num\nlogical,dimension(size(vec)) :: mask\n\nmask = .false.\n\ndo i=1,size(vec)\n\n    !count the number of occurrences of this element:\n    num = count( vec(i)==vec )\n\n    if (num==1) then\n        !there is only one, flag it:\n        mask(i) = .true.\n    else\n        !flag this value only if it hasn't already been flagged:\n        if (.not. any(vec(i)==vec .and. mask) ) mask(i) = .true.\n    end if\n\nend do\n\n!return only flagged elements:\nallocate( vec_unique(count(mask)) )\nvec_unique = pack( vec, mask )\n\n!if you also need it sorted, then do so.\n! for example, with slatec routine:\n!call isort (vec_unique, [0], size(vec_unique), 1)\n\nend function unique\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named than that replaces special characters '<' and '>' with '<lt>' and '<gt>' respectively in a given input string. The function takes a single input argument of type character and returns the modified string as output. The number of input arguments is 1 and the data type is character(len=*). The number of output arguments is 1 and the data type is character(len=:),allocatable.",
            "Provide a Fortran function code called \"than\" that takes a string as input and replaces any occurrence of '<' with '<lt>' and '>' with '<gt>'. The input parameter is a character string and the output parameter is also a character string. The function should return the modified string.",
            "Give me a Fortran function code named than that takes a character string as input and returns a modified character string. The number of input arguments is 1 and the data type is [character(len=*)]. The number of output arguments is 1 and the data type is [character(len=:),allocatable]. The function replaces the characters '<' with '<lt>' and '>' with '<gt>' in the input string."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=:), allocatable :: in_str, out_str\n  \n  !case1\n  in_str = 'This is a test string.'\n  out_str = than(in_str)\n  print *, out_str\n  \n  !case2\n  in_str = '<<<>>>'\n  out_str = than(in_str)\n  print *, out_str\n  \n  !case3\n  in_str = 'Fortran is > C'\n  out_str = than(in_str)\n  print *, out_str\n  \n  !case4\n  in_str = 'No special characters'\n  out_str = than(in_str)\n  print *, out_str\n  \n  !case5\n  in_str = 'Testing < and > characters'\n  out_str = than(in_str)\n  print *, out_str\nend program main",
            "result": [
                "This is a test string.",
                "<lt><lt><lt><gt><gt><gt>",
                "Fortran is <gt> C",
                "No special characters",
                "Testing <lt> and <gt> characters"
            ]
        },
        "code": "function than(in) result(out)\ncharacter(len=*),intent(in)  :: in\ncharacter(len=:),allocatable :: out\ninteger                      :: i\n   out=''\n   do i=1,len_trim(in)\n      select case(in(i:i))\n      case('<')\n         out=out//'<lt>'\n      case('>')\n         out=out//'<gt>'\n      case default\n         out=out//in(i:i)\n      endselect\n   enddo\nend function than\n"
    },
    {
        "instruction": [
            "Create a Fortran function named \"f\" that takes an integer input argument and returns a real output value. The function assigns a specific real value based on the value of the input argument. If the input argument is less than -1, the function assigns -1.0 to the output. If the input argument is equal to 0, the function assigns 0.0 to the output. If the input argument is greater than 0, the function assigns 1.0 to the output. The function should be used to map integer values to corresponding real values.",
            "Give me a Fortran function code named f to determine the value of a real number based on the given integer input.The number of input arguments is 1 and the test_data type is [integer].The number of output arguments is 1 and the test_data type is [real].",
            "Provide a Fortran function named \"f\" that takes an integer input parameter \"n\". The function is intended to return a real number as its output. \n\nThe function is designed to assign a specific real value based on the value of the input parameter \"n\". If \"n\" is less than -1, the function should return -1.0. If \"n\" is equal to 0, the function should return 0.0. And if \"n\" is greater than or equal to 1, the function should return 1.0.\n\nPlease ensure that the input parameter \"n\" is declared as an integer with the \"intent(in)\" attribute, and the output of the function is declared as a real variable."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n\n  \n  !case1\n  n = -5\n  print *, f(n)\n  \n  !case2\n  n = 0\n  print *, f(n)\n  \n  !case3\n  n = 3\n  print *, f(n)\n  \n  !case4\n  n = -10\n  print *, f(n)\n  \n  !case5\n  n = 100\n  print *, f(n)\n  \nend program main",
            "result": [
                "-1.00000000",
                "0.00000000",
                "1.00000000",
                "-1.00000000",
                "1.00000000"
            ]
        },
        "code": "function f(n)\n  integer, intent(in) :: n\n  real                :: f\n\n  select case (n)\n    case (:-1); f = -1.0\n    case (0);   f =  0.0\n    case (1:);  f =  1.0\n  end select\nend function\n"
    },
    {
        "instruction": [
            "Create a Fortran function called factorial that calculates the factorial of a given positive integer. The function takes one input argument of type integer and returns one output argument of type integer. The function utilizes recursion to compute the factorial value.",
            "I have a Fortran function code named factorial that calculates the factorial of a given integer. The function takes one input parameter of type integer and returns one output parameter of type integer. \n\nTo use this function, call it with the desired integer value as the input argument. The function will then recursively compute the factorial of the input value and return the result as the output. \n\nPlease note that the function has some additional features, such as saving previously computed factorials to improve performance. Make sure to adhere to the required input range of non-negative integers up to 12.",
            "Create a Fortran function named \"factorial\" that calculates the factorial of an input integer. The function takes one input argument of type integer and returns one output argument of type integer. The function uses recursion to compute the factorial. The output argument is saved and reused for previously computed factorials to improve performance. The function also includes error handling for negative input values and values greater than 12."
        ],
        "test_case": {
            "unit_test": "\nprogram main\n  use test_function\n  implicit none\n  integer :: i\n  integer :: fac\n  \n  !case1\n  i = 0\n  print *, factorial(i)\n  \n  !case2\n  i = 1\n  print *, factorial(i)\n  \n  !case3\n  i = 5\n  print *, factorial(i)\n  \n  !case4\n  i = 10\n  print *, factorial(i)\n  \n  !case5\n  i = 12\n  print *, factorial(i)\n  \nend program main\n    ",
            "result": [
                "1",
                "1",
                "120",
                "3628800",
                "479001600"
            ]
        },
        "code": "  recursive function factorial(i) result(fac)\n    implicit none\n    integer::fac\n    integer,intent(in)::i\n    integer::init=0,j\n    logical,dimension(12)::lfacsave\n    integer,dimension(12)::facsave\n    save facsave,init,lfacsave\n    if(init.eq.0)then\n       lfacsave(1:12)=.false.\n       init=1\n    endif\n    if(i.lt.0)then\n       write(*,*)\"error: i<0 in factorial with i=\",i\n       stop\n    endif\n    if(i.gt.12)then\n       write(*,*)\"error: i > 12, please take long type (kind=lint) integer\"\n       stop\n    endif\n    if(i.eq.0)then\n       fac=1\n    else\n       if(lfacsave(i))then\n          fac=facsave(i)\n       else\n          fac=i*factorial(i-1)\n          facsave(i)=fac\n          lfacsave(i)=.true.\n       endif\n    endif\n  end function factorial\n"
    },
    {
        "instruction": [
            "Create a Fortran function called number_coefs_for_rank that calculates the number of coefficients for a given rank. The function takes an integer input argument called rank and returns an integer output argument called res. The function calculates the number of coefficients using a loop and a mathematical formula. If the rank is less than 0, the function sets the result to 0. The function then iterates over the range from 0 to the rank and calculates the number of coefficients based on the given formula. Finally, the function returns the result.",
            "Provide a Fortran function named \"number_coefs_for_rank\" that calculates the number of coefficients for a given rank. The function takes one input argument of type integer named \"rank\". It returns one output argument of type integer named \"res\". \nTo calculate the number of coefficients, the function iterates over the range from 0 to the value of \"rank\" and performs a series of calculations using the formula ((3+i)*(2+i)*(1+i))/6, where \"i\" is the current iteration value. \nEnsure that \"res\" is initialized as 0 before the loop. If the value of \"rank\" is less than 0, set \"res\" to 0. Finally, return the value of \"res\".",
            "Write a Fortran function code named number_coefs_for_rank that calculates the number of coefficients for a given rank. The function takes one input parameter of type integer, representing the rank. The function returns an integer as the result. \n\nTo summarize the function, it calculates the number of coefficients based on the given rank. If the rank is less than 0, the result is set to 0. Otherwise, the function iterates from 0 to the given rank and computes the sum of ((3+i)*(2+i)*(1+i))/6 for each iteration. The final result is the total sum of the coefficients."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: rank, res\n  \n  !case1\n  rank = 0\n  res = number_coefs_for_rank(rank)\n  print *, res\n  \n  !case2\n  rank = 3\n  res = number_coefs_for_rank(rank)\n  print *, res\n  \n  !case3\n  rank = 5\n  res = number_coefs_for_rank(rank)\n  print *, res\n  \n  !case4\n  rank = -1\n  res = number_coefs_for_rank(rank)\n  print *, res\n  \n  !case5\n  rank = 10\n  res = number_coefs_for_rank(rank)\n  print *, res\n  \nend program main",
            "result": [
                "1",
                "35",
                "126",
                "0",
                "1001"
            ]
        },
        "code": "  function number_coefs_for_rank(rank) result(res)\n    implicit none\n    integer,intent(in)::rank\n    integer::res,i\n    if(rank.lt.0)res=0\n    res=0\n    do i=0,rank\n       res=res+((3+i)*(2+i)*(1+i))/6\n    enddo\n    return\n  end function number_coefs_for_rank\n"
    },
    {
        "instruction": [
            "Write a Fortran function named primality_tester that checks whether a given integer is prime or not. The function takes an integer input parameter named n and returns a logical output parameter named prime. The function follows a series of conditions to determine the primality of the number. The function is equipped with logical and arithmetic operations to validate the conditions. Implement the function using an imperative approach.",
            "Write a Fortran function code named primality_tester to determine if a given integer is prime or not. The function takes one input argument of type integer and returns one output argument of type logical. The input argument is passed by value using the intent(in) keyword. \n\nTo use the function, call it with the integer you want to test as the input argument. The function will return a logical value indicating whether the input integer is prime or not. The output argument will be assigned the value .true. if the input integer is prime and .false. otherwise.\n\nThe function uses a series of checks to determine if the input integer is prime. If the input integer is less than or equal to 1, the function immediately returns .false. as prime numbers must be greater than 1. If the input integer is 2 or 3, the function returns .true. as they are prime numbers. If the input integer is divisible by 2 or 3, the function returns .false. as it is not prime.\n\nThe function then checks if the input integer is divisible by any odd number greater than 3 up to the square root of the input integer. If any of these checks result in the input integer being divisible, the function returns .false. as it is not prime. If none of the checks find a divisor, the function returns .true. as the input integer is prime.\n\nTo use the function, declare a variable of type logical to store the result and assign it the value returned by the function.",
            "Write a Fortran function named primality_tester that checks whether a given integer is prime or not. The function takes in one input parameter of type integer, named \"n\". The function returns a logical value, named \"prime\", indicating whether \"n\" is a prime number or not. \n\nTo determine if a number is prime, the function follows the below logic:\n- If \"n\" is less than or equal to 1, the function sets \"prime\" to false and returns.\n- If \"n\" is either 2 or 3, the function sets \"prime\" to true and returns.\n- If \"n\" is divisible by 2 or 3, the function sets \"prime\" to false and returns.\n- The function starts checking divisibility from 5 in steps of 6 up to the square root of \"n\".\n- If \"n\" is divisible by any number in the range of multiple of 6 plus or minus 1, the function sets \"prime\" to false and returns.\n- If no factors are found, the function sets \"prime\" to true.\n\nUse this information to write the Fortran function primality_tester."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n\n  \n  !case1\n  n = 2\n  print *, primality_tester(n)\n\n  !case2\n  n = 17\n  print *, primality_tester(n)\n\n  !case3\n  n = 20\n  print *, primality_tester(n)\n\n  !case4\n  n = 97\n  print *, primality_tester(n)\n\n  !case5\n  n = 1000\n  print *, primality_tester(n)\nend program main",
            "result": [
                "T",
                "T",
                "F",
                "T",
                "F"
            ]
        },
        "code": "  function primality_tester(n) result(prime)\n    integer, intent(in) :: n\n    logical :: prime\n\n    integer :: i\n\n    if (n <= 1) then\n      prime = .false.\n      return\n    else if (n <= 3) then\n      prime = .true.\n      return\n    else if (mod(n, 2) == 0 .or. mod(n, 3) == 0) then\n      prime = .false.\n      return\n    end if\n\n    i = 5\n    do while (i * i <= n)\n      if (mod(n, i) == 0 .or. mod(n, i + 2) == 0) then\n        prime = .false.\n        return\n      end if\n      i = i + 6\n    end do\n\n    prime = .true.\n  end function\n"
    },
    {
        "instruction": [
            "Create a Fortran function called mirror_about_plane that takes in a vector and a plane number as input parameters and returns a mirrored version of the vector about the specified plane. The input vector is a 3-dimensional real array, and the plane number is an integer. The output is a 3-dimensional real array representing the mirrored vector.",
            "Write a Fortran function named mirror_about_plane that takes in a 3-dimensional vector and a plane number as input parameters and returns a mirrored version of the vector about the given plane. The plane number represents the component index that is normal to the plane (e.g. 1 for the yz plane). The function should have 2 input parameters of type real, one input parameter of type integer, and 1 output parameter of type real.",
            "Write a Fortran function named mirror_about_plane that takes in a 3-dimensional vector and an integer representing a plane number as input. The function computes a new vector by mirroring the given vector about the specified plane. The function returns the mirrored vector as output.\n\nTo use this function, pass a 3-dimensional vector and an integer representing the desired plane to mirror the vector about. The function will compute the mirrored vector and return it as the result. The input vector is of type real and the plane number is of type integer. The output mirrored vector is also of type real and has a dimension of 3.\n\nMake sure to specify the correct number and type of input and output parameters when using this function."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real, dimension(3) :: vec, mirrored_vec\n  integer :: plane\n  \n  !case1\n  vec = [1.0, 2.0, 3.0]\n  plane = 1\n  mirrored_vec = mirror_about_plane(vec, plane)\n  print *, mirrored_vec\n\n  !case2\n  vec = [0.5, -2.0, 1.5]\n  plane = 3\n  mirrored_vec = mirror_about_plane(vec, plane)\n  print *, mirrored_vec\n\n  !case3\n  vec = [-1.0, 0.0, 0.0]\n  plane = 2\n  mirrored_vec = mirror_about_plane(vec, plane)\n  print *, mirrored_vec\n\n  !case4\n  vec = [2.0, -3.0, 4.0]\n  plane = 2\n  mirrored_vec = mirror_about_plane(vec, plane)\n  print *, mirrored_vec\n\n  !case5\n  vec = [0.0, 0.0, 0.0]\n  plane = 2\n  mirrored_vec = mirror_about_plane(vec, plane)\n  print *, mirrored_vec\nend program main",
            "result": [
                "-1.00000000       2.00000000       3.00000000",
                "0.500000000      -2.00000000      -1.50000000",
                "-1.00000000      -0.00000000       0.00000000",
                "2.00000000       3.00000000       4.00000000",
                "0.00000000      -0.00000000       0.00000000"
            ]
        },
        "code": "    function mirror_about_plane(vec, plane) result(mirrored_vec)\n        ! returns a version of the given vector mirrored about the given plane\n        ! the plane number is the component index which is normal to the plane (i.e. 1: yz plane, etc.)\n\n        implicit none\n\n        real,dimension(3),intent(in) :: vec\n        integer,intent(in) :: plane\n        real,dimension(3) :: mirrored_vec\n\n        mirrored_vec = vec\n        mirrored_vec(plane) = -vec(plane)\n        \n    end function mirror_about_plane\n"
    },
    {
        "instruction": [
            "Provide a Fortran function named smt_get that takes an array of characters as input. The number of input arguments is 1 and the test_data type is [character, dimension(:)]. The function returns a single character as output. The number of output arguments is 1 and the test_data type is [character]. \n\nIn the function, the input array elements are assigned to the output character one by one using a loop. The output character is then returned as the result of the function.",
            "Please create a Fortran function named \"smt_get\" that takes an input argument \"array\" of type character array. The function should return a character string \"smt_get\" which is obtained by concatenating the individual characters of the input array. The number of input arguments is 1 and the data type is [character, dimension(:)]. The number of output arguments is 1 and the data type is [character].",
            "Give me a Fortran function code named smt_get to retrieve characters from an input array and store them in a new character array. The code takes one input argument, an array of characters, and returns one output argument, a character array. The input argument is of type character and has a flexible dimension. The output argument is also of type character and has the same size as the input argument. Use a do loop to iterate over each element of the input array, assigning the corresponding character to the output array. Return the output array as the result of the function."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character, allocatable :: array(:)\n  \n  !case1\n  allocate(array(3))\n  array = ['A', 'B', 'C']\n  print *, smt_get(array)\n  deallocate(array)\n\n  !case2\n  allocate(array(4))\n  array = ['F', 'O', 'R', 'T']\n  print *, smt_get(array)\n  deallocate(array)\n\n  !case3\n  allocate(array(6))\n  array = ['H', 'E', 'L', 'L', 'O', '!']\n  print *, smt_get(array)\n  deallocate(array)\n\n  !case4\n  allocate(array(2))\n  array = ['1', '2']\n  print *, smt_get(array)\n  deallocate(array)\n\n  !case5\n  allocate(array(5))\n  array = ['T', 'E', 'S', 'T', 'S']\n  print *, smt_get(array)\n  deallocate(array)\nend program main",
            "result": [
                "ABC",
                "FORT",
                "HELLO!",
                "12",
                "TESTS"
            ]
        },
        "code": "     function smt_get( array )\n\n!  dummy arguments\n\n     character, dimension( : ) :: array\n     character( size( array ) ) :: smt_get\n\n!  local variables\n\n     integer :: i\n\n     do i = 1, size( array )\n        smt_get( i : i ) = array( i )\n     end do\n\n     return\n\n\n     end function smt_get\n"
    },
    {
        "instruction": [
            "Please provide a Fortran function named compute_pi that calculates an approximation of pi using the Monte Carlo method. The function takes one input argument, segments, which is an integer specifying the number of segments to divide a unit circle into. The function returns a real number as the approximate value of pi.\n\nTo calculate the approximation, the function iteratively computes a polygon's edge length squared and the number of polygon sides. It starts with an initial value of 2.0 for the squared edge length and 2 for the number of sides. It then performs a loop that updates the squared edge length and doubles the number of sides for the specified number of segments. \n\nWithin each iteration, the squared edge length is updated using the formula -sqrt(1 - polygon_edge_length_squared / 4) * 2 + 2. After the loop, the function calculates the approximate value of pi by multiplying the square root of the final squared edge length by the number of sides.\n\nPlease note that the function uses the Fortran-specific real*8 data type for increased precision.",
            "Create a Fortran function named compute_pi that calculates the value of pi using the Monte Carlo method. The function takes in an integer argument named \"segments\" to specify the number of segments to use in the calculation. The function returns a double precision (real*8) value representing the computed value of pi.",
            "Create a Fortran function named compute_pi to approximate the value of pi using the Monte Carlo method. The function takes an integer input parameter named segments to determine the number of iterations for the approximation. The output of the function is a double precision floating-point number. Inside the function, a loop is used to iteratively update the value of the polygon's edge length and the number of sides based on the segments parameter. The final approximation of pi is calculated using the updated values."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: segments\n  \n  !case1\n  segments=1\n  print *, compute_pi(segments)\n\n  !case2\n  segments=5\n  print *, compute_pi(segments)\n\n  !case3\n  segments=10\n  print *, compute_pi(segments)\n\n  !case4\n  segments=100\n  print *, compute_pi(segments)\n\n  !case5\n  segments=1000\n  print *, compute_pi(segments)\nend program main",
            "result": [
                "3.0614674589207178",
                "3.1412772509327569",
                "3.1415923456110768",
                "0.0000000000000000",
                "0.0000000000000000"
            ]
        },
        "code": "function compute_pi(segments)\n  implicit none\n\n  integer, intent(in) :: segments\n  real*8 :: compute_pi\n\n  real*8 :: polygon_edge_length_squared\n  integer :: polygon_sides\n  integer :: i\n\n  polygon_edge_length_squared = 2.0\n  polygon_sides = 2\n  do i = 1, segments\n    polygon_edge_length_squared = -sqrt(1 - polygon_edge_length_squared / 4) * 2 + 2\n    polygon_sides = polygon_sides * 2\n  end do\n  compute_pi = sqrt(polygon_edge_length_squared) * polygon_sides\n  return\nend function\n"
    },
    {
        "instruction": [
            "Create a Fortran function named fl5_qe1 that calculates the value of a mathematical expression. The function takes a double precision input argument named x. The function returns a double precision output value named y. The function computes y by raising x to the power of 3 and adding the exponential function of -x. Use the \"return\" keyword to return the computed value of y.",
            "Write a Fortran function code named fl5_qe1 to calculate the value of y using the input parameter x. The input argument x is a double precision number, and the output argument y is also a double precision number. The function computes y by raising x to the power of 3 and adding the exponential of -x. The function does not take any other parameters and does not return any additional values.",
            "Create a Fortran function named fl5_qe1 that calculates the value of y based on the given input argument x. The input argument x is a double precision floating-point number, and the output argument y is also a double precision floating-point number. The function calculates y by taking the cube of x and adding the exponential function of -x."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  double precision :: x, y\n\n  !case1\n  x = 0.0\n  y = fl5_qe1(x)\n  print *, y\n\n  !case2\n  x = 1.5\n  y = fl5_qe1(x)\n  print *, y\n\n  !case3\n  x = -2.0\n  y = fl5_qe1(x)\n  print *, y\n\n  !case4\n  x = 10.0\n  y = fl5_qe1(x)\n  print *, y\n\n  !case5\n  x = -5.0\n  y = fl5_qe1(x)\n  print *, y\nend program main",
            "result": [
                "1.0000000000000000",
                "3.5981301601484299",
                "-0.61094390106934959",
                "1000.0000453999297",
                "23.413159102576600"
            ]
        },
        "code": "    function fl5_qe1(x) result (y)\r\n        implicit none\r\n        double precision :: x, y\r\n        y = x ** 3 + dexp(-x)\r\n        return\r\n    end function\r\n"
    },
    {
        "instruction": [
            "Write a Fortran function code named dfl5_qe1 that takes a double precision floating-point number as input and returns another double precision floating-point number as output. The function calculates the value of y based on the input x using the formula: y = 3 * x^2 - exp(-x).",
            "Create a Fortran function named dfl5_qe1 that takes a double precision input argument x and returns a double precision output value y. The function calculates y as the result of the expression 3 * x ** 2 - dexp(-x).",
            "Please write a Fortran function named dfl5_qe1 that calculates the value of a mathematical expression. The input parameter is a double precision number, and the output parameter is also a double precision number. The function computes the value of 3 times the square of the input number minus the exponential function of negative the input number."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  double precision :: x, y\n\n  !case1\n  x = 2.0\n  y = dfl5_qe1(x)\n  print *, y\n\n  !case2\n  x = 0.5\n  y = dfl5_qe1(x)\n  print *, y\n\n  !case3\n  x = -1.0\n  y = dfl5_qe1(x)\n  print *, y\n\n  !case4\n  x = 10.0\n  y = dfl5_qe1(x)\n  print *, y\n\n  !case5\n  x = -5.0\n  y = dfl5_qe1(x)\n  print *, y\nend program main",
            "result": [
                "11.864664716763388",
                "0.14346934028736658",
                "0.28171817154095491",
                "299.99995460007023",
                "-73.413159102576600"
            ]
        },
        "code": "    function dfl5_qe1(x) result (y)\r\n        implicit none\r\n        double precision :: x, y\r\n        y = 3 * x ** 2 - dexp(-x)\r\n        return\r\n    end function\r\n"
    },
    {
        "instruction": [
            "Write a Fortran function code named fl5_qe2 that calculates the value of y using a given input value x. The input parameter x is of type double precision and there is one output parameter y, also of type double precision. The function calculates the value of y by raising x to the power of 1/3 and adding the natural logarithm of x.",
            "Write a Fortran function named fl5_qe2 that calculates the value of 'y' based on the input value 'x'. The input parameter 'x' is a double precision number, and the output parameter 'y' is also a double precision number. Inside the function, 'y' is computed as the cube root of 'x' raised to the power of 1/3, plus the natural logarithm of 'x'.",
            "Create a Fortran function named fl5_qe2 that takes a single input argument of type double precision and returns a single output argument of type double precision. The function calculates the value of y using the input argument x. The value of y is obtained by raising x to the power of 1/3 and adding the natural logarithm of x."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  double precision :: x, y\n\n  !case1\n  x = 1.0d0\n  y = fl5_qe2(x)\n  print *, y\n\n  !case2\n  x = 2.0d0\n  y = fl5_qe2(x)\n  print *, y\n\n  !case3\n  x = 3.0d0\n  y = fl5_qe2(x)\n  print *, y\n\n  !case4\n  x = 4.0d0\n  y = fl5_qe2(x)\n  print *, y\n\n  !case5\n  x = 5.0d0\n  y = fl5_qe2(x)\n  print *, y\nend program main",
            "result": [
                "1.0000000000000000",
                "1.9530682304548184",
                "2.5408618589755179",
                "2.9736954130880902",
                "3.3194138591107971"
            ]
        },
        "code": "    function fl5_qe2(x) result (y)\r\n        implicit none\r\n        double precision :: x, y\r\n        y = x ** (1.0d0/3.0d0) + dlog(x)\r\n        return\r\n    end function\r\n"
    },
    {
        "instruction": [
            "Provide a Fortran function named fl5_qe3 that calculates the value of y based on the input value of x. The input parameter is a double precision floating-point number, while the output parameter is also a double precision floating-point number. The function uses the Fortran keyword \"function\" and the \"result\" keyword to declare and define the function. The function calculates y based on the formula 1 - exp(-(x^2) / 25).",
            "Provide a Fortran function code named fl5_qe3 that calculates the value of a mathematical function. The function takes in a single input argument of type double precision and returns a single output argument of type double precision. The function computes the value of the function 1 - exp(-(x^2)/25), where x is the input argument.",
            "Provide a Fortran function code named fl5_qe3 that calculates the value of a mathematical equation. The function takes a single input argument of type double precision. The output result is also of type double precision. The equation being evaluated is 1 - exp(-(x**2)/25), where \"x\" is the input argument."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  double precision :: x, y\n  \n  !case1\n  x = 0.0\n  y = fl5_qe3(x)\n  print *, y\n\n  !case2\n  x = -10.0\n  y = fl5_qe3(x)\n  print *, y\n\n  !case3\n  x = 5.0\n  y = fl5_qe3(x)\n  print *, y\n\n  !case4\n  x = -3.2\n  y = fl5_qe3(x)\n  print *, y\n\n  !case5\n  x = 2.5\n  y = fl5_qe3(x)\n  print *, y\nend program main",
            "result": [
                "0.0000000000000000",
                "0.98168436111126578",
                "0.63212055882855767",
                "0.33608424476896692",
                "0.22119921692859512"
            ]
        },
        "code": "    function fl5_qe3(x) result (y)\r\n        implicit none\r\n        double precision :: x, y\r\n        y = 1 - dexp(-(x ** 2) / 25)\r\n        return\r\n    end function\r\n"
    },
    {
        "instruction": [
            "Provide a Fortran function named dfl5_qe3 that calculates a value based on a given input. The function takes in one double precision argument named x. The output is also of double precision and is named y. Inside the function, the value of y is computed using a mathematical formula. The formula involves multiplying 2 with x and dividing it by the product of 25 and the exponential function of x squared divided by 25. The calculated value of y is then returned as the result of the function.",
            "Develop a Fortran function named \"dfl5_qe3\" that calculates a value based on a given input. This function takes a single input parameter of type \"double precision\" and returns a single output parameter of type \"double precision\". The purpose of this function is to compute the value of y according to the formula (2 * x) / (25 * exp((x ** 2) / 25)). Ensure that the function is defined with the \"implicit none\" statement to enforce explicit variable declarations.",
            "Write a Fortran function named dfl5_qe3 that calculates a value based on the input argument. The input argument is of type double precision. The output value is also of type double precision. The function takes the input argument, performs a calculation using it, and stores the result in the output variable. The calculation involves multiplying the input argument by 2, dividing it by 25, and raising it to the power of e raised to the power of the square of the input argument divided by 25. The result is stored in the output variable, which is then returned by the function."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  double precision :: x, y\n  \n  !case1\n  x = 0.0\n  y = dfl5_qe3(x)\n  print *, y\n  \n  !case2\n  x = 2.5\n  y = dfl5_qe3(x)\n  print *, y\n  \n  !case3\n  x = -3.0\n  y = dfl5_qe3(x)\n  print *, y\n  \n  !case4\n  x = 1.234\n  y = dfl5_qe3(x)\n  print *, y\n  \n  !case5\n  x = 10.0\n  y = dfl5_qe3(x)\n  print *, y\nend program main",
            "result": [
                "0.0000000000000000",
                "0.15576015661428097",
                "-0.16744231825704747",
                "9.2886405197054767E-002",
                "1.4652511110987344E-002"
            ]
        },
        "code": "    function dfl5_qe3(x) result (y)\r\n        implicit none\r\n        double precision :: x, y\r\n        y = (2 * x) / (25 * dexp((x ** 2) / 25))\r\n        return\r\n    end function\r\n"
    },
    {
        "instruction": [
            "Write a Fortran function named \"ring\" that takes two integer arguments: \"start\" and \"k\". \n\nThe function calculates and returns the sum of a sequence of numbers within a ring pattern. The sequence starts from \"start\" and iterates in a clockwise direction towards smaller numbers. In each iteration, the function checks if the current position is a multiple of (k-1). If it is, the value at that position is added to the running total. \n\nThe function returns the final sum as an integer value.",
            "Give me a Fortran function code named ring to calculate the sum of elements in a ring pattern. The function takes two input arguments, start and k, both of which are integers. The function returns an integer value. The start argument specifies the starting value of the ring pattern, while the k argument represents the number of elements in each side of the ring. The function iterates over the elements of the ring pattern and accumulates the sum of the elements. The final sum is returned as the output of the function.",
            "Write a Fortran function named \"ring\" that calculates the sum of a specific range of numbers based on the input parameters. The function takes two integer input arguments named \"start\" and \"k\". It also returns an integer output argument named \"ring\". \n\nTo understand the function's purpose, the code iterates over a range of numbers in a specific pattern and adds certain numbers to the \"ring\" variable. The specific pattern and range of numbers are determined by the input arguments \"start\" and \"k\". \n\nTo implement this, the function initializes variables \"i\" and \"j\" as integers. It then sets \"j\" and \"ring\" to zero. The function enters a loop that iterates from \"start+k+k+(k-2)+(k-2)-1\" to \"start\", decreasing by one in each iteration. Within the loop, it checks if the remainder of \"j\" divided by \"k-1\" is zero. If it is, it adds the current value of \"i\" to the \"ring\" variable. \"j\" is incremented by one in each iteration.\n\nTo use this function, provide the input arguments \"start\" and \"k\" as integers. The function will calculate the sum and return it as the integer output argument \"ring\"."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: start, k\n\n  !case1\n  start = 1\n  k = 2\n  print *, ring(start, k)\n\n  !case2\n  start = 3\n  k = 4\n  print *, ring(start, k)\n\n  !case3\n  start = 5\n  k = 3\n  print *, ring(start, k)\n\n  !case4\n  start = 10\n  k = 5\n  print *, ring(start, k)\n\n  !case5\n  start = 2\n  k = 1\n  print *, ring(start, k)\n  \nend program main",
            "result": [
                "10",
                "38",
                "36",
                "76",
                "0"
            ]
        },
        "code": "  pure function ring(start,k)\n    implicit none\n    integer, intent(in) :: start,k\n    integer             :: i,j\n    integer             :: ring\n\n    j=0\n    ring=0\n    do i=start+k+k+(k-2)+(k-2)-1,start,-1\n       if (mod(j,k-1) == 0) then\n          ring=ring+i\n       end if\n       j=j+1\n    end do\n  end function ring\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named djscaled that calculates the scaled value of an input parameter. The number of input arguments is 1 and the data type is real*8. The number of output arguments is 1 and the data type is real*8. The function first checks if the input parameter is within the range of 0 to 1. If it is not, an error message is printed and the program stops. If the input parameter is within the range, the function computes a scaled value based on a mathematical formula and returns it as the output.",
            "Give me a Fortran function code named djscaled that computes the scaled value of a given input xval. The input parameter is a real*8 number xval. The output parameter is also a real*8 number djscaled. The function checks if the xval is within the range [0,1] and raises an error if it is not. It then calculates the pixval as the product of pi and xval and computes the djscaled as 0.75 * pi * sin(pixval)**3.",
            "Provide a Fortran function code named djscaled to calculate the scaled value of a given input parameter xval. The input parameter xval is a real*8 type. The function returns a real*8 value.\n\nThe function checks if the input parameter xval is within the range of 0 to 1. If xval is outside this range, an error message is printed and the program stops.\n\nThe function then calculates the value of pixval, which is the product of pi and xval.\n\nFinally, the function computes the value of djscaled using the formula 0.75 * pi * sin(pixval)**3 and returns the result."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real*8 :: xval\n\n  !case1\n  xval = 0.5\n  print *, djscaled(xval)\n\n  !case2\n  xval = 0.2\n  print *, djscaled(xval)\n\n  !case3\n  xval = 0.8\n  print *, djscaled(xval)\n\n  !case4\n  xval = 0.9\n  print *, djscaled(xval)\n\n  !case5\n  xval = 0.1\n  print *, djscaled(xval)\n\nend program main",
            "result": [
                "2.3561944901923448",
                "0.47848376725995168",
                "0.47848367476939796",
                "6.9527806570197873E-002",
                "6.9527761492182275E-002"
            ]
        },
        "code": "function djscaled(xval)\n  implicit none\n  real*8 :: djscaled,xval,pixval\n  real*8, parameter :: pi = 3.14159265358979323844d0 !!temp\n\n  if (xval.lt.0d0.or.xval.gt.1d0) then\n     print *, \"scalederr f\",xval; stop\n  endif\n  pixval=pi*xval\n  djscaled = 0.75d0 * pi * sin(pixval)**3 \n\nend function djscaled\n"
    },
    {
        "instruction": [
            "Create a Fortran function named gcd to compute the greatest common divisor (GCD) of two integers. The function takes two input parameters, both of integer type, and returns one output parameter of integer type. The input parameters are named \"i\" and \"j\", and the output parameter is named \"res\". The function uses a recursive approach to calculate the GCD. To call the function, provide two integer values as input arguments and store the returned GCD in a variable.",
            "Write a Fortran function named gcd that calculates the greatest common divisor of two integers. The function takes two input arguments of type integer and returns one output argument of type integer. The names of the input arguments are \"i\" and \"j\", and the name of the output argument is \"res\". The function uses recursion to find the greatest common divisor. The final result is stored in the variable \"res\".",
            "Provide a Fortran function named gcd that calculates the greatest common divisor (GCD) of two integers. The function takes two input parameters of type integer and returns one output parameter of type integer. The input parameters are declared with the intent (in) attribute. The function uses recursion to calculate the GCD. If the second input parameter is equal to zero, the function assigns the value of the first input parameter to the result. Otherwise, it calls itself with the second input parameter as the first argument and the modulus of the first and second input parameters as the second argument. The calculated GCD is stored in the result variable."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: i, j\n\n  !case1\n  i = 10\n  j = 5\n  print *, gcd(i, j)\n\n  !case2\n  i = 21\n  j = 7\n  print *, gcd(i, j)\n\n  !case3\n  i = 36\n  j = 48\n  print *, gcd(i, j)\n\n  !case4\n  i = 100\n  j = 75\n  print *, gcd(i, j)\n\n  !case5\n  i = 1024\n  j = 512\n  print *, gcd(i, j)\n\nend program main",
            "result": [
                "5",
                "7",
                "12",
                "25",
                "512"
            ]
        },
        "code": "  recursive function gcd (i, j) result (res)\n    integer, intent (in) :: i\n    integer, intent (in) :: j\n    integer :: res\n    if (j == 0) then\n      res = i\n    else\n      res = gcd (j, modulo (i, j))\n    end if\n  end function gcd\n"
    },
    {
        "instruction": [
            "Provide a Fortran function named tridiag_solve that solves a tridiagonal linear system of equations. The function takes in five input parameters: l (a real number), d (a real number), r (a real number), b (an array of real numbers), and n (an integer). The function returns an array of real numbers.\n\nTo use the function, provide the tridiagonal matrix coefficients l, d, and r, as well as the right-hand side vector b, and the size of the system n. The function will compute the solution to the linear system and store it in the array tridiag_solve.\n\nThe function uses a forward substitution method to compute intermediate values, and then backward substitution to compute the final solution. The solution is computed starting from the last element of the system, and then working backwards.\n\nEnsure that the input arrays have dimensions compatible with the size of the linear system.",
            "Write a Fortran function called tridiag_solve that solves a tridiagonal linear system of equations. The function takes in five input parameters: l, d, r, b, and n. These parameters represent the lower diagonal element, diagonal element, upper diagonal element, right-hand side vector, and the size of the system respectively. The output of the function is an array of real numbers containing the solution to the system of equations.\n\nTo use the tridiag_solve function, you need to provide the values for the input parameters l, d, r, b, and n. The lower diagonal element is represented by l, the diagonal element by d, and the upper diagonal element by r. The right-hand side vector is denoted by b and the size of the system is given by n.\n\nThe tridiag_solve function first computes some intermediate arrays bhat and rhat. Then, it iteratively solves the system of equations by starting from the last element and working backwards. The final solution is stored in the tridiag_solve array.\n\nTo use this function, call it using the appropriate arguments and store the result in an array of real numbers.",
            "Write a Fortran function named tridiag_solve to solve a tridiagonal system of equations. The function takes in five input parameters: an integer n, indicating the size of the system, and four real arrays l, d, r, and b, representing the lower, main, upper diagonal elements, and the right-hand side of the system, respectively. The function returns a real array tridiag_solve, which contains the solution to the system.\n\nInside the function, intermediate arrays bhat and rhat are declared to store temporary values. The function uses a loop to compute the values of bhat and rhat based on the input parameters. Then, another loop is used to compute the solution by starting from the last element and moving backwards.\n\nTo use the function, call it with the appropriate input arrays and store the returned solution in a variable of the same type and size as the input arrays."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n\n  real :: l, d, r\n  real, allocatable :: b(:)\n  \n  !case1\n  n = 3\n  l = 1.0\n  d = 2.0\n  r = 1.0\n  allocate(b(n))\n  b = [1.0, 2.0, 3.0]\n  print *, tridiag_solve(l, d, r, b, n)\n  deallocate(b)\n  \n  !case2\n  n = 4\n  l = 2.0\n  d = 3.0\n  r = 1.0\n  allocate(b(n))\n  b = [4.0, 5.0, 6.0, 7.0]\n  print *, tridiag_solve(l, d, r, b, n)\n  deallocate(b)\n  \n  !case3\n  n = 5\n  l = 3.0\n  d = 4.0\n  r = 2.0\n  allocate(b(n))\n  b = [1.0, 2.0, 3.0, 4.0, 5.0]\n  print *, tridiag_solve(l, d, r, b, n)\n  deallocate(b)\n  \n  !case4\n  n = 3\n  l = 2.0\n  d = 3.0\n  r = 1.0\n  allocate(b(n))\n  b = [0.0, 0.0, 0.0]\n  print *, tridiag_solve(l, d, r, b, n)\n  deallocate(b)\n  \n  !case5\n  n = 4\n  l = 1.0\n  d = 2.0\n  r = 1.0\n  allocate(b(n))\n  b = [2.0, 4.0, 6.0, 8.0]\n  print *, tridiag_solve(l, d, r, b, n)\n  deallocate(b)\n  \nend program main",
            "result": [
                "0.500000060      -1.19209290E-07   1.50000012",
                "1.16129041      0.516129017       1.12903225       1.58064520",
                "-0.149999797      0.799999595     -0.374999464       1.04999948      0.462500185",
                "0.00000000       0.00000000       0.00000000",
                "0.00000000       2.00000000       0.00000000       4.00000000"
            ]
        },
        "code": "function tridiag_solve(l, d, r, b, n)\n    implicit none\n    integer, intent(in) :: n\n    ! input array\n    real,  dimension(n), intent(in) :: b\n    real, intent(in) :: l, d, r\n    ! return value will be stored in this array\n    real, dimension(n) :: tridiag_solve\n\n    real,  dimension(n) :: bhat, rhat\n    integer :: i\n\n    rhat(1) = r / d\n    bhat(1) = b(1) / d\n    do i=2,n\n        rhat(i) = r / (d - l * rhat(i - 1))\n        bhat(i) = (b(i) - l * bhat(i-1)) / (d - l * rhat(i-1))\n    enddo\n\n    ! compute the solution, starting from n, then n-1, n-2, ...\n    tridiag_solve(n) = bhat(n)\n    do i=1,n-1\n        tridiag_solve(n - i) = bhat(n - i) - rhat(n - i) * tridiag_solve(n - i + 1)\n    end do\n\nend function\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named is_opening to determine if a given character token is an opening bracket or parenthesis. The function takes a single input parameter of type character (len=1) and returns a logical value. The function checks if the token is equal to \"(\" or \"[\" or \"{\" or \"<\" and returns true if it is, otherwise it returns false.",
            "Provide a Fortran function code named is_opening to check if a given character token is an opening bracket. The function takes in a single character token as input and returns a logical value indicating whether the token is an opening bracket. The input parameter is of type character with a length of 1, and the output parameter is of type logical.\n\nTo create the function, use the \"pure\" keyword to indicate that the function does not have any side effects and only depends on its input parameters. Initialize the logical value \"is_opening\" to false. Then, check if the token is equal to any of the opening bracket characters \"(\",\"[\",\"{\", or \"<\". If the token matches any of these characters, set \"is_opening\" to true. Finally, return the value of \"is_opening\".",
            "Provide a Fortran function named \"is_opening\" that checks whether a given character token is an opening bracket. The function takes a single input argument of type character with a length of 1. The output argument is of type logical and indicates whether the token is an opening bracket."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=1) :: token\n  \n  !case1\n  token = \"(\"\n  print *, is_opening(token)\n\n  !case2\n  token = \"[\"\n  print *, is_opening(token)\n\n  !case3\n  token = \"{\"\n  print *, is_opening(token)\n\n  !case4\n  token = \"<\"\n  print *, is_opening(token)\n\n  !case5\n  token = \")\"\n  print *, is_opening(token)\nend program main",
            "result": [
                "T",
                "T",
                "T",
                "T",
                "F"
            ]
        },
        "code": "  pure function is_opening( token )\n    implicit none\n\n    character (len=1), intent (in) :: token\n    logical :: is_opening\n\n    is_opening = .false.\n\n    if (token == \"(\" .or. token == \"[\" .or. token == \"{\" .or. token == \"<\") then\n      is_opening = .true.\n    endif\n  end function is_opening\n"
    },
    {
        "instruction": [
            "Provide a Fortran function named get_costs_for_illegal that calculates the costs associated with different closing tokens. The function takes one input parameter, a character named closingtoken. The function then returns an integer value representing the costs for the given closing token. The possible values for the closingtoken are \")\" for parentheses, \"]\" for square brackets, \"}\" for curly brackets, and \">\" for angle brackets. \n\nTo use the function, pass the desired closingtoken as an argument and store the returned costs in an integer variable.",
            "Please create a Fortran function named get_costs_for_illegal that takes a single character input argument named closingtoken. This function will return an integer value.\n\nThe function is designed to determine the cost associated with a specific closing token. It uses a select case construct to compare the value of the closingtoken argument with various closing token characters. If a match is found, the function assigns a specific integer value to the get_costs_for_illegal variable based on the matched closing token.\n\nThe function has 1 input parameter of type character and 1 output parameter of type integer.",
            "Give me a Fortran function code named get_costs_for_illegal to determine the costs associated with different closing tokens. The function takes one input argument of type character, representing the closing token. The output of the function is an integer, indicating the costs associated with the input closing token.\n\nTo use the function, provide the closing token as an argument when calling the function. The function will then determine the costs based on the provided closing token. The function uses a select case construct to check the value of the closing token and assign the corresponding costs. The function returns the determined costs as an integer value.\n\nMake sure to declare the function as pure and specify the intent of the input argument as \"in\"."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character :: closingtoken\n\n  !case1\n  closingtoken = \")\"\n  print *, get_costs_for_illegal(closingtoken)\n\n  !case2\n  closingtoken = \"]\"\n  print *, get_costs_for_illegal(closingtoken)\n\n  !case3\n  closingtoken = \"}\"\n  print *, get_costs_for_illegal(closingtoken)\n\n  !case4\n  closingtoken = \">\"\n  print *, get_costs_for_illegal(closingtoken)\n\n  !case5\n  closingtoken = \"(\"\n  print *, get_costs_for_illegal(closingtoken)\nend program main",
            "result": [
                "3",
                "57",
                "1197",
                "25137",
                "32765"
            ]
        },
        "code": "  pure function get_costs_for_illegal(closingtoken)\n    implicit none\n\n    character, intent(in) :: closingtoken\n    integer :: get_costs_for_illegal\n\n    select case (closingtoken)\n      case(\")\")\n        get_costs_for_illegal = 3\n      case (\"]\")\n        get_costs_for_illegal = 57\n      case (\"}\")\n        get_costs_for_illegal = 1197\n      case (\">\")\n        get_costs_for_illegal = 25137\n    end select\n  end function get_costs_for_illegal\n"
    },
    {
        "instruction": [
            "Provide a Fortran function named \"get_expected_closing_char_from\" that returns the expected closing character for a given opening character. The function takes one input argument of type \"character\" representing the opening character. The function returns a single output value of type \"character\" representing the expected closing character. The function uses a \"select case\" statement to determine the expected closing character based on the input opening character.",
            "Create a Fortran function named get_expected_closing_char_from that determines the expected closing character given an opening character. The function takes one input argument, openingtoken, of type character. It returns one output argument of type character, which represents the expected closing character. Implement a select case statement to handle different opening characters such as \"(\" with corresponding closing character \")\", \"[\" with \"]\", \"{\" with \"}\", and \"<\" with \">\".",
            "Provide a Fortran function named get_expected_closing_char_from that determines the expected closing character based on the given opening character. The function takes one input argument of type character, representing the opening character. The output is also of type character, representing the expected closing character. \n\nTo use the function, pass an opening character to it, and it will return the corresponding closing character. The function supports four opening characters: \"(\", \"[\", \"{\", and \"<\". \n\nWrite a code that includes this function, ensuring that it is a pure function by adding the \"pure\" keyword before the \"function\" keyword."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character :: openingtoken\n  character :: closingtoken\n  \n  !case1\n  openingtoken = \"(\"\n  closingtoken = get_expected_closing_char_from(openingtoken)\n  print *, closingtoken\n\n  !case2\n  openingtoken = \"[\"\n  closingtoken = get_expected_closing_char_from(openingtoken)\n  print *, closingtoken\n\n  !case3\n  openingtoken = \"{\"\n  closingtoken = get_expected_closing_char_from(openingtoken)\n  print *, closingtoken\n\n  !case4\n  openingtoken = \"<\"\n  closingtoken = get_expected_closing_char_from(openingtoken)\n  print *, closingtoken\n\n  !case5\n  openingtoken = \"A\"\n  closingtoken = get_expected_closing_char_from(openingtoken)\n  print *, closingtoken\nend program main",
            "result": [
                ")",
                "]",
                "}",
                ">",
                "\u0000"
            ]
        },
        "code": "  pure function get_expected_closing_char_from(openingtoken) \n    implicit none\n\n    character, intent(in) :: openingtoken\n    character :: get_expected_closing_char_from\n\n    select case (openingtoken)\n      case(\"(\")\n        get_expected_closing_char_from = \")\"\n      case (\"[\")\n        get_expected_closing_char_from = \"]\"\n      case (\"{\")\n        get_expected_closing_char_from = \"}\"\n      case (\"<\")\n        get_expected_closing_char_from = \">\"\n    end select\n  end function get_expected_closing_char_from\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named norm2_c to calculate the Euclidean norm of a complex array. The number of input arguments is 1 and the data type is a complex array. The number of output arguments is 1 and the data type is a real number.",
            "Please provide a Fortran function named norm2_c that calculates the Euclidean norm of a complex array. The function takes an array of complex numbers as input, with the number of elements not specified. The input parameter is of type complex(8) and has the intent(in) attribute. The function returns a real(8) value, which is the calculated norm.",
            "Provide a Fortran function named norm2_c that calculates the Euclidean norm of a complex array. The function takes an input argument val, which is an array of complex numbers. The number of input arguments is 1 and the data type is complex(8), with the intent set as in. The function returns a single output value, norm2_c, which is a real(8) number representing the Euclidean norm of the complex array. The output value is calculated by finding the norm of the real and imaginary parts of the input array separately, and then computing the square root of the sum of their squares."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  complex(8), allocatable :: val(:)\n  \n  !case1\n  allocate(val(2))\n  val = [(1.0, 1.0), (2.0, -2.0)]\n  print *, norm2_c(val)\n  deallocate(val)\n\n  !case2\n  allocate(val(4))\n  val = [(0.0, 0.0), (0.0, 0.0), (0.0, 0.0), (0.0, 0.0)]\n  print *, norm2_c(val)\n  deallocate(val)\n\n  !case3\n  allocate(val(3))\n  val = [(2.0, 0.0), (0.0, 1.0), (-1.0, -1.0)]\n  print *, norm2_c(val)\n  deallocate(val)\n\n  !case4\n  allocate(val(5))\n  val = [(3.333, 2.222), (-4.444, 0.0), (1.111, -3.333), (0.0, 0.0), (5.555, 4.444)]\n  print *, norm2_c(val)\n  deallocate(val)\n\n  !case5\n  allocate(val(2))\n  val = [(1.5, -2.5), (-3.5, 4.5)]\n  print *, norm2_c(val)\n  deallocate(val)\nend program main",
            "result": [
                "3.1622776601683795",
                "0.0000000000000000",
                "2.6457513110645907",
                "9.9370857182918417",
                "6.4031242374328494"
            ]
        },
        "code": "function norm2_c(val)\n  character(len=*),parameter :: this_sub_name = 'norm2'\n\n  complex(8),dimension(:),intent(in) :: val\n\n  real(8) :: norm_real\n  real(8) :: norm_complex\n\n  real(8) :: norm2_c\n\n  norm_real = norm2(real(val))\n  norm_complex = norm2(aimag(val))\n\n  norm2_c = (norm_real**2 + norm_complex**2)**(0.5)\nend function norm2_c\n"
    },
    {
        "instruction": [
            "Write a Fortran function code named atan2_cc that calculates the complex arc tangent (atan2) of two complex numbers. The function accepts two complex numbers as input arguments, val1 and val2, both of type complex(8). The function returns a complex number, atan2_cc, also of type complex(8), which represents the atan2 value of val1 and val2.",
            "Provide a Fortran function code named atan2_cc that computes the complex arctangent of two complex numbers. The function takes two complex numbers as input arguments of type complex(8), and returns a complex number as the output argument of type complex(8). The function uses the atan2 function to calculate the phase angle and the complex division formula to calculate the magnitude. The function is implemented using the if-else construct to handle special cases when the real parts of the input arguments are zero.",
            "Provide a Fortran function code named atan2_cc that calculates the complex arctangent of two complex numbers. The function has two input parameters, both of type complex(8), and one output parameter of type complex(8). The name of the function is atan2_cc."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  complex(8) :: val1, val2, result\n  \n  !case1\n  val1 = (3.0, 4.0)\n  val2 = (1.0, 1.0)\n  result = atan2_cc(val1, val2)\n  print *, result\n  \n  !case2\n  val1 = (2.0, -5.0)\n  val2 = (-3.0, 2.0)\n  result = atan2_cc(val1, val2)\n  print *, result\n  \n  !case3\n  val1 = (0.0, 0.0)\n  val2 = (1.0, 2.0)\n  result = atan2_cc(val1, val2)\n  print *, result\n  \n  !case4\n  val1 = (-2.0, 3.0)\n  val2 = (0.0, 1.0)\n  result = atan2_cc(val1, val2)\n  print *, result\n  \n  !case5\n  val1 = (1.0, -1.0)\n  val2 = (-1.0, -1.0)\n  result = atan2_cc(val1, val2)\n  print *, result\nend program main",
            "result": [
                "(  1.2490457723982544     , 0.10000000000000001     )",
                "(  2.5535900500422257     , 0.84615384615384615     )",
                "(  0.0000000000000000     ,  0.0000000000000000     )",
                "( -1.5707963267948966     , 0.50000000000000000     )",
                "(  2.3561944901923448     ,  1.0000000000000000     )"
            ]
        },
        "code": "function atan2_cc(val1,val2)\n  character(len=*),parameter :: this_sub_name = 'atan2_cc'\n\n  complex(8),intent(in) :: val1\n  complex(8),intent(in) :: val2\n\n  complex(8) :: atan2_cc\n\n  real(8) :: r1\n  real(8) :: c1\n  real(8) :: r2\n  real(8) :: c2\n\n  r1 = real(val1)\n  c1 = aimag(val1)\n  r2 = real(val2)\n  c2 = aimag(val2)\n\n  if ((r1 .ne. 0) .or. (r2 .ne. 0)) then\n    atan2_cc = cmplx(atan2(r1,r2),(r2*c1-r1*c2)/(r1**2+r2**2),8)\n  else\n    atan2_cc = cmplx(atan2(r1,r2),0.0,8)\n  endif\nend function atan2_cc\n"
    },
    {
        "instruction": [
            "Write a Fortran function named abs_c that calculates the absolute value of a complex number. The function takes one input argument of type complex(8), which is a complex number. The function returns one output argument of the same type, which is the absolute value of the input complex number.",
            "Create a Fortran function named abs_c that calculates the absolute value of a complex number. The function takes one input parameter, a complex number of type complex(8), and returns the absolute value as a complex number of the same type.",
            "Create a Fortran function named abs_c that calculates the absolute value of a complex number. The function accepts one input argument of type complex(8) and returns one output argument of the same type. The function should be named abs_c. If the real part of the input number is negative, the function should return the complex conjugate of the input number."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  complex(8) :: val, result\n\n  !case1: val with positive real and imaginary part\n  val = cmplx(3.0, 4.0, 8)\n  result = abs_c(val)\n  print *, result\n\n  !case2: val with negative real and positive imaginary part\n  val = cmplx(-2.0, 5.0, 8)\n  result = abs_c(val)\n  print *, result\n\n  !case3: val with negative real and imaginary part\n  val = cmplx(-1.5, -2.5, 8)\n  result = abs_c(val)\n  print *, result\n\n  !case4: val with positive real and negative imaginary part\n  val = cmplx(4.0, -3.0, 8)\n  result = abs_c(val)\n  print *, result\n\n  !case5: val with zero real and imaginary part\n  val = cmplx(0.0, 0.0, 8)\n  result = abs_c(val)\n  print *, result\n\nend program main",
            "result": [
                "(  3.0000000000000000     ,  4.0000000000000000     )",
                "(  2.0000000000000000     , -5.0000000000000000     )",
                "(  1.5000000000000000     ,  2.5000000000000000     )",
                "(  4.0000000000000000     , -3.0000000000000000     )",
                "(  0.0000000000000000     ,  0.0000000000000000     )"
            ]
        },
        "code": "function abs_c(val)\n  character(len=*),parameter :: this_sub_name = 'abs_c'\n\n  complex(8),intent(in) :: val\n\n  complex(8) :: abs_c\n\n  if (real(val) .lt. 0) then\n    abs_c = cmplx(-real(val),-aimag(val),8)\n  else\n    abs_c = val\n  endif\n\nend function abs_c\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named dot_product_c to compute the dot product of two complex arrays. The number of input arguments is 2 and the test_data type is [complex(8), complex(8)]. The number of output arguments is 1 and the test_data type is [complex(8)].",
            "Provide a Fortran function code named dot_product_c that calculates the dot product of two complex arrays. The function takes two complex arrays, val1 and val2, as input parameters. The number of input arguments is 2 and the data type of the input arrays is complex(8). The function returns a complex(8) value as the dot product. The number of output arguments is 1 and the data type of the output value is complex(8). The function performs element-wise multiplication of the corresponding elements in val1 and val2 and then accumulates the results to compute the dot product. The dot product is initialized to zero and then updated in a loop.",
            "Provide a Fortran function code named dot_product_c that calculates the dot product of two complex arrays. The function takes in two complex arrays of 8-byte precision as input parameters. The number of input arguments is 2 and the data type of each input argument is complex(8),dimension(:),intent(in). The function returns a complex number of 8-byte precision as the output. The number of output arguments is 1 and the data type is complex(8). The function iterates over the elements of the arrays and computes the dot product by multiplying corresponding elements of the arrays and summing them up."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n_elem\n  complex(8), allocatable :: val1(:), val2(:)\n  \n  !case1\n  n_elem = 3\n  allocate(val1(n_elem), val2(n_elem))\n  val1 = [(1.0, 2.0), (2.0, 3.0), (3.0, 4.0)]\n  val2 = [(2.0, 1.0), (3.0, 2.0), (4.0, 3.0)]\n  print *, dot_product_c(val1, val2)\n  deallocate(val1, val2)\n\n  !case2\n  n_elem = 4\n  allocate(val1(n_elem), val2(n_elem))\n  val1 = [(1.0, 1.0), (2.0, 2.0), (3.0, 3.0), (4.0, 4.0)]\n  val2 = [(2.0, 1.0), (3.0, 2.0), (4.0, 3.0), (5.0, 4.0)]\n  print *, dot_product_c(val1, val2)\n  deallocate(val1, val2)\n\n  !case3\n  n_elem = 5\n  allocate(val1(n_elem), val2(n_elem))\n  val1 = [(1.0, 2.0), (2.0, 3.0), (3.0, 4.0), (4.0, 5.0), (5.0, 6.0)]\n  val2 = [(2.0, 1.0), (3.0, 2.0), (4.0, 3.0), (5.0, 4.0), (6.0, 5.0)]\n  print *, dot_product_c(val1, val2)\n  deallocate(val1, val2)\n\n  !case4\n  n_elem = 2\n  allocate(val1(n_elem), val2(n_elem))\n  val1 = [(1.0, 1.0), (2.0, 2.0)]\n  val2 = [(2.0, 1.0), (3.0, 2.0)]\n  print *, dot_product_c(val1, val2)\n  deallocate(val1, val2)\n\n  !case5\n  n_elem = 3\n  allocate(val1(n_elem), val2(n_elem))\n  val1 = [(1.0, 1.0), (2.0, 2.0), (3.0, 3.0)]\n  val2 = [(2.0, 1.0), (3.0, 2.0), (4.0, 3.0)]\n  print *, dot_product_c(val1, val2)\n  deallocate(val1, val2)\nend program main",
            "result": [
                "(  0.0000000000000000     ,  43.000000000000000     )",
                "(  10.000000000000000     ,  70.000000000000000     )",
                "(  0.0000000000000000     ,  145.00000000000000     )",
                "(  3.0000000000000000     ,  13.000000000000000     )",
                "(  6.0000000000000000     ,  34.000000000000000     )"
            ]
        },
        "code": "function dot_product_c(val1,val2)\n  character(len=*),parameter :: this_sub_name = 'dot_product_c'\n\n  complex(8),dimension(:),intent(in) :: val1\n  complex(8),dimension(:),intent(in) :: val2\n\n  complex(8) :: dot_product_c\n\n  integer :: n_elem_1\n  integer :: n_elem_2\n  integer :: ielem\n\n  n_elem_1 = size(val1)\n  n_elem_2 = size(val2)\n\n  dot_product_c = 0\n\n  do ielem = 1,n_elem_1\n    dot_product_c = dot_product_c + val1(ielem)*val2(ielem)\n  enddo\nend function dot_product_c\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named multiply_two_numbers that calculates the product of two floating-point numbers. The function takes two input arguments, both of type real, and returns a single output argument, also of type real. The input arguments are passed by value and are labeled as intent(in). The output argument is labeled as result(c). To compute the product, multiply the values of the input arguments and assign the result to the output argument. Use the return statement to return the computed value.",
            "Provide a Fortran function code named multiply_two_numbers that multiplies two floating-point numbers. The function takes two input arguments of type real and returns a single output argument of type real. The function uses the intent(in) keyword to indicate that the input arguments are read-only. The computed result is stored in the output variable named c.",
            "Provide a Fortran function named multiply_two_numbers that takes two real numbers as input arguments and returns their product. The function should have two input parameters of type real, specified with the intent(in) attribute, and one output parameter of type real. The function should compute the product of the two input numbers and assign the result to the output parameter. The function should then return without any specific value using the return statement."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real :: a, b, c\n  \n  !case1\n  a = 2.5\n  b = 3.0\n  c = multiply_two_numbers(a, b)\n  print *, c\n  \n  !case2\n  a = -4.7\n  b = 0.5\n  c = multiply_two_numbers(a, b)\n  print *, c\n  \n  !case3\n  a = 0.0\n  b = 100.0\n  c = multiply_two_numbers(a, b)\n  print *, c\n  \n  !case4\n  a = 1.2345\n  b = 6.7890\n  c = multiply_two_numbers(a, b)\n  print *, c\n  \n  !case5\n  a = -10.0\n  b = -2.5\n  c = multiply_two_numbers(a, b)\n  print *, c\n  \nend program main",
            "result": [
                "7.50000000",
                "-2.34999990",
                "0.00000000",
                "8.38102055",
                "25.0000000"
            ]
        },
        "code": "  function multiply_two_numbers(a, b) result(c)\n    real, intent(in) :: a, b\n    real :: c\n    c = a * b\n    return\n  end function multiply_two_numbers\n"
    },
    {
        "instruction": [
            "Write a Fortran function called filesep_swap that swaps forward slashes ('/') with backslashes ('\\') in a given string path. The function takes a single input argument of type character and returns a modified string with the swapped characters. The number of input arguments is 1 and the test_data type is [character]. The number of output arguments is 1 and the test_data type is [character].",
            "Give me a Fortran function code named filesep_swap to swap forward slashes '/' to backslashes '\\' in a given character string. The function takes one input argument of type character and returns one output argument of the same type. Use the following instructions to understand the code correctly and briefly summarize its function.\n\nIn the function filesep_swap, a character string 'path' is provided as input. The code aims to swap all occurrences of forward slashes '/' with backslashes '\\' in the given string. The function uses a loop to iterate through the string and replaces each '/' with the ASCII representation of the backslash character. The function then returns the modified string as the output result.\n\nTo use this function, you need to provide a character string 'path' as input, and the function will return the modified string with swapped file separators.",
            "Provide a Fortran function code named filesep_swap that swaps the forward slash ('/') with the backslash ('\\') for Windows systems in a given input path. The function has one input parameter, 'path', which is a character string representing the file path. The function returns a modified character string, 'swapped', with the forward slashes replaced by backslashes."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=100) :: path\n\n  !case1\n  path = \"C:/Program Files/Fortran\"\n  print *, filesep_swap(path)\n\n  !case2\n  path = \"D:\\Data\\Documents\"\n  print *, filesep_swap(path)\n\n  !case3\n  path = \"/home/user/documents\"\n  print *, filesep_swap(path)\n\n  !case4\n  path = \"C:\\Windows\\System32\"\n  print *, filesep_swap(path)\n\n  !case5\n  path = \"/path/with/no/slashes\"\n  print *, filesep_swap(path)\nend program main",
            "result": [
                "C:\\Program Files\\Fortran",
                "D:\\Data\\Documents",
                "\\home\\user\\documents",
                "C:\\Windows\\System32",
                "\\path\\with\\no\\slashes"
            ]
        },
        "code": "function filesep_swap(path) result(swapped)\n!! swaps '/' to '\\' for windows systems\n\ncharacter(*), intent(in) :: path\ncharacter(len(path)) :: swapped\ninteger :: i\n\nswapped = path\ndo\n  i = index(swapped, '/')\n  if (i == 0) exit\n  swapped(i:i) = char(92)\nend do\n\nend function filesep_swap\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named dist that calculates the cartesian distance between two points in 3-dimensional space. The function takes two input arguments, a and b, both of type real and dimension 3, representing the coordinates of the two points. The function returns a single output argument, c, of type real, which represents the computed distance between the points.",
            "Write a Fortran function named dist that calculates the Cartesian distance between two points in three-dimensional space. The function takes two arrays of real numbers, each representing the coordinates of a point, as input. The number of input arguments is 2 and the type of each argument is [real, real, real]. The function returns a single real number as the output.",
            "Provide a Fortran function named \"dist\" that calculates the Cartesian distance between two points in three-dimensional space. The function takes two input arguments, both of type real and with a dimension of 3, representing the coordinates of the two points. The function returns a single output argument of type real, representing the calculated distance."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real, dimension(3) :: a, b\n\n  !case1\n  a = [0.0, 0.0, 0.0]\n  b = [1.0, 1.0, 1.0]\n  print *, dist(a, b)\n\n  !case2\n  a = [-2.0, 3.0, 1.5]\n  b = [4.0, -1.0, 0.0]\n  print *, dist(a, b)\n\n  !case3\n  a = [10.0, 0.0, 0.0]\n  b = [0.0, 10.0, 0.0]\n  print *, dist(a, b)\n\n  !case4\n  a = [0.0, 0.0, 0.0]\n  b = [0.0, 0.0, 0.0]\n  print *, dist(a, b)\n\n  !case5\n  a = [1.0, 2.0, 3.0]\n  b = [4.0, 5.0, 6.0]\n  print *, dist(a, b)\nend program main",
            "result": [
                "1.73205078",
                "7.36545992",
                "14.1421356",
                "0.00000000",
                "5.19615221"
            ]
        },
        "code": "function dist(a, b) result(c)\r\n  ! calculates the cartesian distance between 2 points\r\n\r\n    implicit none\r\n\r\n    real,dimension(3),intent(in) :: a, b\r\n    real :: c\r\n\r\n    c = sqrt(sum((a-b)**2))\r\n\r\nend function dist\r\n"
    },
    {
        "instruction": [
            "Please write a Fortran function named \"inner\" that calculates the 3D Euclidean inner product. The function takes two input arguments, both of type real and dimension 3, and returns a single output argument of type real.",
            "Please create a Fortran function named inner that calculates the 3D Euclidean inner product of two vectors. The function takes two input parameters, both of type real and with a dimension of 3. The output parameter is a single real number.",
            "Write a Fortran function named inner that calculates the 3D Euclidean inner product of two given vectors. The function takes two input arguments of type real array with a dimension of 3. The function returns a single output value of type real."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real :: a(3), b(3), c\n  \n  !case1\n  a = [1.0, 2.0, 3.0]\n  b = [4.0, 5.0, 6.0]\n  c = inner(a,b)\n  print *, c\n\n  !case2\n  a = [0.0, -1.0, 2.0]\n  b = [3.0, 0.0, -4.0]\n  c = inner(a,b)\n  print *, c\n\n  !case3\n  a = [2.5, -1.5, 3.8]\n  b = [0.5, 1.2, -0.9]\n  c = inner(a,b)\n  print *, c\n\n  !case4\n  a = [0.0, 0.0, 0.0]\n  b = [1.0, 2.0, 3.0]\n  c = inner(a,b)\n  print *, c\n\n  !case5\n  a = [-1.5, 2.7, -3.1]\n  b = [0.0, 0.0, 0.0]\n  c = inner(a,b)\n  print *, c\nend program main",
            "result": [
                "32.0000000",
                "-8.00000000",
                "-3.96999979",
                "0.00000000",
                "0.00000000"
            ]
        },
        "code": "function inner(a, b) result(c)\r\n  ! calculates the 3d euclidean inner product\r\n\r\n  implicit none\r\n  real, dimension(3) :: a, b\r\n  real :: c\r\n\r\n  c = a(1)*b(1)+a(2)*b(2)+a(3)*b(3)\r\n\r\nend function inner\r\n"
    },
    {
        "instruction": [
            "Write a Fortran function code named inner2 that calculates the 2D Euclidean inner product of two arrays. The function takes in two arrays of real numbers, each with a dimension of 2, as input arguments. The function returns a single real number as the output.",
            "Write a Fortran function code named inner2 that calculates the 2D Euclidean inner product of two vectors. The function takes two input arguments of type real and dimension 2, representing the two vectors. The function returns a single output argument of type real, which is the result of the inner product calculation.",
            "Write a Fortran function named inner2 that calculates the 2D Euclidean inner product of two arrays. The function takes two input arguments of type real and dimension(2), and returns one output argument of type real. The input arrays are named \"a\" and \"b\", and the output variable is named \"c\"."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real, dimension(2) :: a, b\n  \n  !case1\n  a = [1.0, 2.0]\n  b = [3.0, 4.0]\n  print *, inner2(a, b)\n  \n  !case2\n  a = [0.0, 0.0]\n  b = [1.0, -1.0]\n  print *, inner2(a, b)\n  \n  !case3\n  a = [2.5, -3.7]\n  b = [-1.2, 4.6]\n  print *, inner2(a, b)\n  \n  !case4\n  a = [10.0, 0.0]\n  b = [0.0, 5.0]\n  print *, inner2(a, b)\n  \n  !case5\n  a = [0.1, 0.2]\n  b = [0.3, 0.4]\n  print *, inner2(a, b)\nend program main",
            "result": [
                "11.0000000",
                "0.00000000",
                "-20.0200005",
                "0.00000000",
                "0.110000007"
            ]
        },
        "code": "function inner2(a, b) result(c)\r\n  ! calculates the 2d euclidean inner product\r\n\r\n  implicit none\r\n  real, dimension(2) :: a, b\r\n  real :: c\r\n\r\n  c = a(1)*b(1)+a(2)*b(2)\r\n\r\nend function inner2\r\n"
    },
    {
        "instruction": [
            "Write a Fortran function named \"outer\" that computes the outer product of two vectors. The function takes two input arguments, both of type real and dimension 3. The output is a 3x3 matrix of real numbers. \n\nIn the function, initialize the output matrix to zero. Then, iterate over the indices of the first vector and assign the product of each element in the first vector and the entire second vector to the corresponding row of the output matrix. \n\nRemember to include the necessary \"implicit none\" statement and declare the variables and arrays with appropriate types and dimensions.",
            "Provide a Fortran function named outer that calculates the outer product of two vectors. The function takes two input arguments, both of type real and dimension 3, representing the two vectors. The function returns an output argument of type real and dimension 3x3, representing the resulting outer product matrix. The function should be implemented using a do loop to iterate over the vector elements and compute the outer product.",
            "Write a Fortran function named \"outer\" to calculate the outer product of two vectors. The function takes two input arguments of type real and dimension 3, representing the vectors \"a\" and \"b\". The function returns a 2-dimensional array of type real and dimension 3x3, representing the outer product matrix \"c\". \n\nInside the function, initialize the matrix \"c\" to all zeros. Use a loop to iterate over each element of the vectors \"a\" and \"b\". Multiply each element of \"a\" with all elements of \"b\" and assign the result to the corresponding element of \"c\". \n\nBy the end of the function, the matrix \"c\" will contain the outer product of \"a\" and \"b\"."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real, dimension(3) :: a, b\n  real, dimension(3,3) :: c\n  \n  !case1\n  a = [1.0, 2.0, 3.0]\n  b = [4.0, 5.0, 6.0]\n  c = outer(a, b)\n  print *, c\n\n  !case2\n  a = [0.5, 1.5, 2.5]\n  b = [2.0, 4.0, 6.0]\n  c = outer(a, b)\n  print *, c\n  \n  !case3\n  a = [10.0, 20.0, 30.0]\n  b = [0.1, 0.2, 0.3]\n  c = outer(a, b)\n  print *, c\n  \n  !case4\n  a = [1.0, -2.0, 3.0]\n  b = [-4.0, 5.0, -6.0]\n  c = outer(a, b)\n  print *, c\n  \n  !case5\n  a = [2.5, 1.5, 0.5]\n  b = [0.2, 0.4, 0.6]\n  c = outer(a, b)\n  print *, c\n  \nend program main",
            "result": [
                "4.00000000       8.00000000       12.0000000       5.00000000       10.0000000       15.0000000       6.00000000       12.0000000       18.0000000",
                "1.00000000       3.00000000       5.00000000       2.00000000       6.00000000       10.0000000       3.00000000       9.00000000       15.0000000",
                "1.00000000       2.00000000       3.00000000       2.00000000       4.00000000       6.00000000       3.00000000       6.00000000       9.00000000",
                "-4.00000000       8.00000000      -12.0000000       5.00000000      -10.0000000       15.0000000      -6.00000000       12.0000000      -18.0000000",
                "0.500000000      0.300000012      0.100000001       1.00000000      0.600000024      0.200000003       1.50000000      0.900000036      0.300000012"
            ]
        },
        "code": "function outer(a, b) result(c)\r\n  ! calculates the outer product of two vectors\r\n\r\n  implicit none\r\n\r\n  real,dimension(3) :: a, b\r\n  real,dimension(3,3) :: c\r\n\r\n  integer :: i\r\n\r\n  c = 0.\r\n\r\n  do i=1,3\r\n    c(i,:) = a(i)*b(:)\r\n  end do\r\n\r\nend function\r\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named det3 to calculate the determinant of a 3x3 matrix. The function takes a 3x3 matrix as input, specified by the parameter \"a\" of type real and dimension(3,3). The function returns the determinant, specified by the output parameter \"c\" of type real.",
            "Write a Fortran function named det3 to calculate the determinant of a 3x3 matrix. The function takes a single input parameter, a 3x3 matrix of real numbers. The output of the function is a single real number representing the determinant.",
            "Write a Fortran function code named det3 that calculates the determinant of a 3x3 matrix. The function takes a single input parameter, a 3x3 real matrix, and returns a single output parameter, a real value representing the determinant."
        ],
        "test_case": {
            "unit_test": "program main\r\n  use test_function\r\n  implicit none\r\n  real, dimension(3,3) :: a\r\n\r\n  !case1\r\n  a = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0], [3,3])\r\n  print *, det3(a)\r\n\r\n  !case2\r\n  a = reshape([2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0], [3,3])\r\n  print *, det3(a)\r\n\r\n  !case3\r\n  a = reshape([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0], [3,3])\r\n  print *, det3(a)\r\n\r\n  !case4\r\n  a = reshape([1.0, 2.0, 3.0, 0.0, 1.0, 4.0, 5.0, 6.0, 0.0], [3,3])\r\n  print *, det3(a)\r\n\r\n  !case5\r\n  a = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0], [3,3])\r\n  print *, det3(a)\r\n  \r\nend program main",
            "result": [
                "0.00000000",
                "0.00000000",
                "1.00000000",
                "1.00000000",
                "0.00000000"
            ]
        },
        "code": "function det3(a) result(c)\r\n  ! calculates the determinant of a 3x3 matrix\r\n\r\n  implicit none\r\n\r\n  real,dimension(3,3) :: a\r\n  real :: c\r\n\r\n  c = a(1,1)*(a(2,2)*a(3,3)-a(2,3)*a(3,2))\r\n  c = c - a(1,2)*(a(2,1)*a(3,3)-a(2,3)*a(3,1))\r\n  c = c + a(1,3)*(a(2,1)*a(3,2)-a(3,1)*a(2,2))\r\n\r\nend function det3\r\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named dot to calculate the dot product of two 3-dimensional vectors. The function takes two input arguments of type real, each being an array of size 3. The function returns a single output argument of type real. The dot product is computed by multiplying corresponding elements of the two input vectors and summing them up. The result is stored in the output argument named dot.",
            "Create a Fortran function named dot that calculates the dot product of two 3-dimensional vectors. The function takes two input arguments, v1 and v2, which are arrays of real numbers. The function returns a single output argument, dot, which is a real number.",
            "Please provide a Fortran function named dot that calculates the dot product of two 3-dimensional arrays of real numbers. The function takes two input arguments, both of type real and dimension 3. The function returns a single output argument of type real."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real (kind=8), dimension(3) :: v1, v2\n  \n  !case1\n  v1 = [1.0, 2.0, 3.0]\n  v2 = [4.0, 5.0, 6.0]\n  print *, dot(v1, v2)\n\n  !case2\n  v1 = [0.0, 0.0, 0.0]\n  v2 = [1.0, 2.0, 3.0]\n  print *, dot(v1, v2)\n\n  !case3\n  v1 = [-1.5, 2.3, -0.8]\n  v2 = [0.5, -1.2, 0.3]\n  print *, dot(v1, v2)\n\n  !case4\n  v1 = [10.0, 20.0, 30.0]\n  v2 = [1.0, 1.0, 1.0]\n  print *, dot(v1, v2)\n\n  !case5\n  v1 = [0.0, 1.0, 0.0]\n  v2 = [0.0, 0.0, 1.0]\n  print *, dot(v1, v2)\nend program main\n    ",
            "result": [
                "32.000000000000000",
                "0.0000000000000000",
                "-3.7500000655651071",
                "60.000000000000000",
                "0.0000000000000000"
            ]
        },
        "code": "    function dot(v1, v2)\n      real (kind=8), intent(in), dimension(3) :: v1, v2\n      integer(kind=4) :: i, length\n      real (kind=8) :: cp, dot\n    \t\n      length = size(v1)\n      cp = 0.0;\n    \t\n      do i=1,length\n        cp = cp + v1(i)*v2(i)\n      enddo\n    \t\n      dot = cp\n      return\n    end function dot\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named declination to calculate the solar declination angle based on the given day of the year. The function takes two input arguments: daynum (integer) and degtorad (real). It returns the declination angle as an output argument (real).",
            "Write a Fortran function named declination that calculates the solar declination angle based on the given day of the year. The function takes two input arguments: daynum (integer) and degtorad (real). It returns the declination angle (real) as the output.",
            "Provide a Fortran function named \"declination\" to calculate the solar declination angle based on the day of the year. The function takes two input parameters: \"daynum\" of type integer and \"degtorad\" of type real. The function returns a single output parameter \"declination\" of type real."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: daynum\n  real :: degtorad\n\n  !case1\n  daynum = 100\n  degtorad = 0.0174533\n  print *, declination(daynum, degtorad)\n\n  !case2\n  daynum = 200\n  degtorad = 0.0174533\n  print *, declination(daynum, degtorad)\n\n  !case3\n  daynum = 300\n  degtorad = 0.0174533\n  print *, declination(daynum, degtorad)\n\n  !case4\n  daynum = 365\n  degtorad = 0.0174533\n  print *, declination(daynum, degtorad)\n\n  !case5\n  daynum = 183\n  degtorad = 0.0174533\n  print *, declination(daynum, degtorad)\nend program main",
            "result": [
                "7.43813896",
                "20.8711395",
                "-13.7018194",
                "-23.1034050",
                "23.0679798"
            ]
        },
        "code": "function declination(daynum, degtorad)\nimplicit none\n!*--declination9\n!include 'p1unconv.inc'\n!\n!*** start of declarations rewritten by spag\n!\n! dummy arguments\n!\ninteger :: daynum\nreal :: declination, degtorad\n\n\n!\n! local variables\n!\nreal :: b\n!\n!*** end of declarations rewritten by spag\n!\n \n!     + + + purpose + + +\n\n!     the sun based on the day of the year\n \n!     + + + keywords + + +\n!     solar declination\n \n!     + + + argument declarations + + +\n \n!     + + + argument definitions + + +\n!     daynum   - day of year\n \n!     + + + local variables + + +\n \n!     + + + local definitions + + +\n!     b      - sub calculation (time of year, radians)\n \n!     + + + common blocks + + +\n \n!     + + + end specifications + + +\n \n!     calculate declination angle (dec)\nb = (360.0/365.0)*(daynum-81.25)*degtorad          !h-55\ndeclination = 23.45*sin(b)                         !h-58\n \nend function declination\n"
    },
    {
        "instruction": [
            "Write a Fortran function named rerf that calculates the relative error function for a given input value. The function takes one input argument of type real and returns one output argument of type real. The function uses a series of calculations and conditional statements to determine the appropriate calculation based on the input value. It then computes and returns the relative error function value.",
            "Provide a Fortran function named \"rerf\" that calculates the value of the relative error function for a given input argument. The function takes a single input parameter of type real and returns a value of type real. The input parameter represents the value at which the relative error function is to be evaluated. \n\nThe function uses a series of mathematical calculations involving constants and intermediate variables to compute the value of the relative error function. The code includes local variables and constants for these calculations. \n\nTo compute the relative error function, the code first performs some preprocessing steps such as taking the absolute value of the input argument and calculating the square root and logarithm of the input argument. \n\nBased on the value of the input argument, the code then applies different formulas to compute the value of the relative error function. If the input argument is less than or equal to 0.966105, the base formula is used to calculate the value of the relative error function. If the input argument is greater than 0.999311, a different formula involving additional terms is used. For input arguments between these two values, another formula with additional terms is used. \n\nFinally, the code multiplies the computed value of the relative error function by the original input argument to obtain the final result. \n\nThe generated Fortran function \"rerf\" takes one input argument of type real and returns a value of type real.",
            "Provide a Fortran function code named rerf to calculate the value of the Riemann Zeta function. The function takes a single input argument of type real and returns a value of type real. The name of the function is \"rerf\"."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real :: y\n\n  !case1\n  y = 1.0\n  print *, rerf(y)\n\n  !case2\n  y = -2.5\n  print *, rerf(y)\n\n  !case3\n  y = 0.5\n  print *, rerf(y)\n\n  !case4\n  y = 10.0\n  print *, rerf(y)\n\n  !case5\n  y = -0.75\n  print *, rerf(y)\n  \nend program main",
            "result": [
                "3.00520825",
                "273941.844",
                "0.476938367",
                "-12116105.0",
                "-0.813419759"
            ]
        },
        "code": "function rerf(y)\n!\nimplicit none\n!\n\n!\nreal :: y\nreal :: rerf\n!\n! local variables\n!\nreal :: a,a1,a2,alogy,b,b1,b2,base,c,c1,c2,d,d1,e,er1,er2,f,g,h,i,j,sqy,y2,y3,  &\n      & y4,y5,z\nreal :: alog\n!\n!**********************************************************************\n!     + + +  purpose + + +\n\n\n!     written by l. hagen and coded by i. elmanyawi\n \n!     + + +  argument declarations + + +\n \n!     + + + local variables + + +\n!     + + + end specifications + + +\n!\na = 0.000009477\nb = -2.76913995\nc = 0.88589485\nd = 2.30199509\ne = -2.44996884\nf = -0.14332263\ng = 2.246990417\nh = -0.54046067\ni = -0.68292239\nj = 0.15092933\nz = y\ny = abs(y)\n!\na1 = 2857.5463\nb1 = -0.00016423\nc1 = -5717.0696\nd1 = -2857.5783\na2 = 69161.649\nb2 = -277330.28\nc2 = 208168.95\n!\nsqy = sqrt(y)\nalogy = alog(y)\ny2 = y*y\ny3 = y2*y\ny4 = y3*y\ny5 = y4*y\n!\nbase = (a+c*y+e*y2+g*y3+i*y4)/(1.000000+b*y+d*y2+f*y3+h*y4+j*y5)\n!\nif (y.le.0.966105) then\n  rerf = base\nelse if (y.gt.0.999311) then\n!\n  er2 = a2 + b2*y*sqy + c2*y2\n  rerf = base - er2\nelse\n!\n  er1 = a1 + b1/alogy + c1*alogy/y + d1/y2\n  rerf = base - er1\nend if\nrerf = rerf*z/y\nend function rerf\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named \"predicate\" that checks if a given integer is a perfect square. The function takes one input argument, an integer, and returns a logical value indicating whether the number is a perfect square or not.",
            "Write a Fortran function named \"predicate\" that checks whether a given integer is a perfect square. The function takes an integer as input and returns a logical value indicating whether the number is a perfect square. The input argument is of type integer and is declared with the \"intent(in)\" attribute. The output value is of type logical and is returned by the function.",
            "Provide a Fortran function named \"predicate\" that checks whether a given integer is a perfect square. The function takes one input argument of type integer and returns a logical value indicating whether the input is a perfect square."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n\n  \n  !case1\n  n = 7\n  print *, predicate(n)\n  \n  !case2\n  n = 16\n  print *, predicate(n)\n  \n  !case3\n  n = 23\n  print *, predicate(n)\n  \n  !case4\n  n = 144\n  print *, predicate(n)\n  \n  !case5\n  n = 97\n  print *, predicate(n)\n  \nend program main",
            "result": [
                "T",
                "F",
                "T",
                "F",
                "T"
            ]
        },
        "code": "  pure function predicate(n)\n    implicit none\n    integer, intent(in) :: n\n    logical             :: predicate\n\n    predicate=mod(sqrt(dble(n)),1.0)/=0.0\n\n  end function predicate\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named quote that takes a string as input and optionally takes a quote character as input. The function returns the input string enclosed in quotes. The number of input arguments is 1 and the data type is character(len=*). The number of optional input arguments is 1 and the data type is character(len=*). The number of output arguments is 1 and the data type is character(len=:), allocatable.",
            "Give me a Fortran function code named quote to add quotation marks around a given string. The function takes one mandatory input argument of type character and one optional input argument of type character. The output is a character string. To use the optional input argument, specify it as the second argument when calling the function.",
            "Write a Fortran function named quote that takes a string as input and optionally a quote character, and returns the string surrounded by the specified quote character. The number of input arguments is 1 or 2, with the first argument being a character string and the second argument, if present, being a character string as well. The number of output arguments is 1, which is also a character string."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=100) :: s, q\n  character(len=:), allocatable :: r\n\n  !case1\n  s = 'Hello World!'\n  print *, quote(s)\n  \n  !case2\n  s = 'Fortran is fun!'\n  q = \"'\"\n  print *, quote(s, q)\n  \n  !case3\n  s = 'Testing 123'\n  q = ''\n  print *, quote(s, q)\n  \n  !case4\n  s = ''\n  q = '\"'\n  print *, quote(s, q)\n  \n  !case5\n  s = 'Testing special characters: &, <, >'\n  q = \"'\"\n  print *, quote(s, q)\n  \nend program main",
            "result": [
                "\"Hello World!                                                                                        \"",
                "'                                                                                                   Fortran is fun!                                                                                     '",
                "Testing 123",
                "\"                                                                                                                                                                                                       \"",
                "'                                                                                                   Testing special characters: &, <, >                                                                 '"
            ]
        },
        "code": "        function quote(s, q) result (r)\n            character(len=*), intent(in) :: s\n            character(len=*), optional, intent(in) :: q\n            character(len=:), allocatable :: t_q\n            character(len=:), allocatable :: r\n\n            if (.not. present(q)) then\n                t_q = '\"'\n            else\n                t_q = q\n            end if\n\n            r = t_q//s//t_q\n        end function\n"
    },
    {
        "instruction": [
            "Write a Fortran function code called \"dlog2\" that calculates the base-2 logarithm of a given double precision number. The function takes one input argument of type double precision and returns one output argument of the same type.",
            "Create a Fortran function named dlog2 that calculates the logarithm base 2 of a given double precision input number. The function takes one input argument of type double precision and returns one output argument of type double precision. The function uses the built-in logarithm function, dlog, to compute the natural logarithm of the input number and then divides it by the natural logarithm of 2.",
            "Write a Fortran function named \"dlog2\" that computes the logarithm base 2 of a given double precision input argument. The function takes one input argument of type double precision and returns the result as a double precision value."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  double precision :: x, y\n\n  !case1\n  x = 2.0d0\n  y = dlog2(x)\n  print *, y\n\n  !case2\n  x = 10.0d0\n  y = dlog2(x)\n  print *, y\n\n  !case3\n  x = 0.5d0\n  y = dlog2(x)\n  print *, y\n\n  !case4\n  x = 100.0d0\n  y = dlog2(x)\n  print *, y\n\n  !case5\n  x = 0.2d0\n  y = dlog2(x)\n  print *, y\nend program main",
            "result": [
                "1.0000000000000000",
                "3.3219280948873626",
                "-1.0000000000000000",
                "6.6438561897747253",
                "-2.3219280948873622"
            ]
        },
        "code": "        function dlog2(x) result (y)\n            implicit none\n            double precision, intent(in) :: x\n            double precision :: y\n\n            y = dlog(x) / dlog(2.0d0)\n            return\n        end function\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named \"str\" that converts an integer to a string. The function takes in one input argument of type integer. The number of input arguments is 1 and the data type is [integer]. The function returns a string as the output. The number of output arguments is 1 and the data type is [character(len=:), allocatable].",
            "Provide a Fortran function code named \"str\" that converts an integer to a string. The function takes one input argument, an integer, and returns one output argument, a character string.",
            "Give me a Fortran function code named str to convert an integer to a string. The function takes one input argument of type integer and returns a string."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: k\n  character(len=:), allocatable :: t\n  \n  !case1\n  k = 0\n  t = str(k)\n  print *, t\n\n  !case2\n  k = -123\n  t = str(k)\n  print *, t\n\n  !case3\n  k = 987654321\n  t = str(k)\n  print *, t\n\n  !case4\n  k = 999999999\n  t = str(k)\n  print *, t\n\n  !case5\n  k = -123456789\n  t = str(k)\n  print *, t\nend program main",
            "result": [
                "0",
                "-123",
                "987654321",
                "999999999",
                "-123456789"
            ]
        },
        "code": "        function str(k) result (t)\n!       \"convert an integer to string.\"\n            integer, intent(in) :: k\n            character(len=128) :: s\n            character(len=:), allocatable :: t\n            write(s, *) k\n            t = trim(adjustl(s))\n            return\n            return\n        end function\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named get_col_totals to calculate the totals of each column in a 2-dimensional array. The function takes in three input parameters: the number of rows (r) and columns (c), and the array (arr) of real numbers. The function returns an array of real numbers containing the column totals.",
            "Create a Fortran function named get_col_totals that calculates the column totals of a 2D array. The function takes three input parameters: 'r' and 'c' of integer type to specify the dimensions of the array, and 'arr' of real type to store the values of the array. The function returns an array of real type named 'get_col_totals' containing the column totals.",
            "Please write a Fortran function named get_col_totals. This function takes in three input parameters: r and c, which are integers, and arr, which is a 2D real array of size (r, c). The purpose of this function is to calculate the column totals of the input array and return them in a 1D real array called totals. The number of columns in the input array determines the size of the totals array. The function should be declared as real and should return the calculated totals array."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: r, c\n  real, allocatable :: arr(:,:)\n  \n  !case1\n  r=3\n  c=3\n  allocate(arr(r,c))\n  arr = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0], [r, c])\n  print *, get_col_totals(r, c, arr)\n  deallocate(arr)\n\n  !case2\n  r=2\n  c=4\n  allocate(arr(r,c))\n  arr = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0], [r, c])\n  print *, get_col_totals(r, c, arr)\n  deallocate(arr)\n\n  !case3\n  r=4\n  c=2\n  allocate(arr(r,c))\n  arr = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0], [r, c])\n  print *, get_col_totals(r, c, arr)\n  deallocate(arr)\n\n  !case4\n  r=1\n  c=5\n  allocate(arr(r,c))\n  arr = reshape([1.0, 2.0, 3.0, 4.0, 5.0], [r, c])\n  print *, get_col_totals(r, c, arr)\n  deallocate(arr)\n\n  !case5\n  r=5\n  c=1\n  allocate(arr(r,c))\n  arr = reshape([1.0, 2.0, 3.0, 4.0, 5.0], [r, c])\n  print *, get_col_totals(r, c, arr)\n  deallocate(arr)\nend program main",
            "result": [
                "1.00000000       1.00000000       1.00000000",
                "1.00000000       1.00000000       1.00000000       1.00000000",
                "1.00000000       1.00000000",
                "1.00000000       1.00000000       1.00000000       1.00000000       1.00000000",
                "1.00000000"
            ]
        },
        "code": "function get_col_totals(r, c, arr)\n  integer, intent(in) :: r, c\n  real, dimension(r, c), intent(in) :: arr\n  real, dimension(c) :: totals\n  real, dimension(c) :: get_col_totals\n  totals = 1\n  get_col_totals = totals\nend function get_col_totals\n"
    },
    {
        "instruction": [
            "Write a Fortran function named qaverage that calculates the average value based on different cases. The function takes in five input parameters of different types: an integer q, and four real*8 values rhoa, rhob, mya, and myb. The function returns a real*8 value qaverage.\n\nHere are the details of the function:\n- The function uses a select case statement to handle different cases based on the value of q.\n- If q is 1, the function calculates qaverage using the formula rhoa/rhosum*mya + rhob/rhosum*myb, where rhosum is the sum of rhoa and rhob.\n- If q is -1, the function calculates qaverage using the formula 1/(rhoa/rhosum*(1/mya) + rhob/rhosum*(1/myb)).\n- If q is 0, the function calculates qaverage using the formula (mya**(rhoa) + myb**(rhob))**(1/rhosum), where rhosum is the sum of rhoa and rhob.\n- For any other value of q, the function returns 0.\n\nMake sure to provide the appropriate data types and number of parameters when calling the function.",
            "Create a pure function named \"qaverage\" in Fortran to calculate the weighted average. The function takes five input parameters, including an integer \"q\", and four real numbers \"rhoa\", \"rhob\", \"mya\", and \"myb\". The function returns a real number \"qaverage\".\n\nTo compute the weighted average, the function first calculates the sum of \"rhoa\" and \"rhob\". Then, using a select case statement, the function performs different calculations based on the value of \"q\". If \"q\" is 1, the function computes the average by multiplying \"mya\" with the ratio of \"rhoa\" to the sum of \"rhoa\" and \"rhob\", and \"myb\" with the ratio of \"rhob\" to the sum of \"rhoa\" and \"rhob\". If \"q\" is -1, the function calculates the inverse of the weighted average. If \"q\" is 0, the function computes the average of \"mya\" and \"myb\" raised to the power of the corresponding \"rho\" values, which is then raised to the power of the reciprocal of the sum of \"rhoa\" and \"rhob\". For any other value of \"q\", the function returns 0.\n\nRemember to specify the input and output types in the function definition and to use the \"return\" statement to return the computed value.",
            "Create a Fortran function named \"qaverage\" that calculates the average value based on a given formula. The function takes in five input parameters: an integer q, and four real*8 numbers rhoa, rhob, mya, and myb. The function returns a real*8 value representing the average.\n\nHere's how the function works:\n- The function first calculates the sum of rhoa and rhob and stores it in rhosum.\n- Using a select case statement, the function checks the value of q.\n- If q is equal to 1, the function computes the average using the formula rhoa/rhosum * mya + rhob/rhosum * myb and stores it in qaverage.\n- If q is equal to -1, the function computes the average using the formula 1/(rhoa/rhosum * (1/mya) + rhob/rhosum * (1/myb)) and stores it in qaverage.\n- If q is equal to 0, the function computes the average using the formula (mya**(rhoa) + myb**(rhob))**(1.d0/rhosum) and stores it in qaverage.\n- If q is any other value, the function sets qaverage to 0.\n- Finally, the function returns the value of qaverage."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: q\n  real*8 :: rhoa, rhob, mya, myb\n  \n  !case1\n  q = 1\n  rhoa = 2.0\n  rhob = 3.0\n  mya = 4.0\n  myb = 5.0\n  print *, qaverage(q, rhoa, rhob, mya, myb)\n  \n  !case2\n  q = -1\n  rhoa = 1.0\n  rhob = 2.0\n  mya = 3.0\n  myb = 4.0\n  print *, qaverage(q, rhoa, rhob, mya, myb)\n  \n  !case3\n  q = 0\n  rhoa = 0.5\n  rhob = 0.5\n  mya = 1.0\n  myb = 2.0\n  print *, qaverage(q, rhoa, rhob, mya, myb)\n  \n  !case4\n  q = 2\n  rhoa = 1.0\n  rhob = 2.0\n  mya = 3.0\n  myb = 4.0\n  print *, qaverage(q, rhoa, rhob, mya, myb)\n  \n  !case5\n  q = -2\n  rhoa = 2.0\n  rhob = 1.0\n  mya = 4.0\n  myb = 3.0\n  print *, qaverage(q, rhoa, rhob, mya, myb)\nend program main",
            "result": [
                "4.5999999999999996",
                "3.5999999999999996",
                "2.4142135623730949",
                "0.0000000000000000",
                "0.0000000000000000"
            ]
        },
        "code": " pure function qaverage(q,rhoa,rhob,mya,myb)\n  \n  implicit none\n  \n  integer, intent(in) :: q \n  \n  real*8, intent(in) :: rhoa,rhob,mya,myb\n  \n  real*8 :: qaverage,rhosum\n  \n  rhosum=rhoa+rhob\n  \n  select case(q)\n  case(1)\n    qaverage=rhoa/rhosum*mya+rhob/rhosum*myb\n  case(-1)\n    qaverage=1.d0/(rhoa/rhosum*(1.d0/mya)+rhob/rhosum*(1.d0/myb))\n  case(0)\n    qaverage=(mya**(rhoa)+myb**(rhob))**(1.d0/rhosum)\n  case default\n    qaverage=0.d0\n  end select\n  \n  return\n  \n end function\n"
    },
    {
        "instruction": [
            "Write a Fortran function called qaverage0 that calculates the q-average of two numbers using a formula. The function takes four input arguments of type real*8: rhoa, rhob, mya, and myb. It returns a single output argument of type real*8, which is the q-average calculated based on the input arguments.",
            "Provide a Fortran function code named qaverage0 to calculate the average quantity for two given values. The function takes in four input parameters of type real*8: rhoa, rhob, mya, and myb. It returns a single output parameter of type real*8, representing the calculated average quantity.",
            "Create a Fortran function called qaverage0 that calculates the average of two quantities, mya and myb, using the weighted average formula. The function takes four input arguments of type real*8: rhoa, rhob, mya, and myb. The function returns a single output argument of type real*8, which represents the calculated average."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real*8 :: rhoa, rhob, mya, myb, result\n\n  !case1\n  rhoa = 1.0\n  rhob = 2.0\n  mya = 3.0\n  myb = 4.0\n  result = qaverage0(rhoa, rhob, mya, myb)\n  print *, result\n\n  !case2\n  rhoa = 0.5\n  rhob = 0.5\n  mya = 2.0\n  myb = 2.0\n  result = qaverage0(rhoa, rhob, mya, myb)\n  print *, result\n\n  !case3\n  rhoa = 2.5\n  rhob = 1.5\n  mya = 5.0\n  myb = 3.0\n  result = qaverage0(rhoa, rhob, mya, myb)\n  print *, result\n\n  !case4\n  rhoa = 0.0\n  rhob = 2.0\n  mya = 0.0\n  myb = 4.0\n  result = qaverage0(rhoa, rhob, mya, myb)\n  print *, result\n\n  !case5\n  rhoa = 1.8\n  rhob = 1.8\n  mya = 2.5\n  myb = 2.5\n  result = qaverage0(rhoa, rhob, mya, myb)\n  print *, result\nend program main",
            "result": [
                "2.6684016487219449",
                "2.8284271247461903",
                "2.7958024767787135",
                "4.1231056256176606",
                "1.9168558287392337"
            ]
        },
        "code": " pure function qaverage0(rhoa,rhob,mya,myb)\n  \n  implicit none\n  \n  real*8, intent(in) :: rhoa,rhob,mya,myb\n  \n  real*8 :: qaverage0,rhosum\n  \n  rhosum=rhoa+rhob\n  \n  qaverage0=(mya**(rhoa)+myb**(rhob))**(1.d0/rhosum)\n  \n  return\n  \n end function\n"
    },
    {
        "instruction": [
            "Write a Fortran function named remove_spaces that takes a string as input and removes all the whitespace characters from it. The number of input argument is 1 and the data type is character(len=*). The number of output argument is 1 and the data type is character(len=:), allocatable. The function utilizes features of Fortran, such as intent(in), character data type, and the allocate statement. Follow the provided code to implement the function.",
            "Please provide a Fortran function code named remove_spaces that removes whitespace from a given string. The function takes one input argument of type character(len=*), which represents the input string. The function returns one output argument of type character(len=:), which represents the string without spaces.",
            "Write a Fortran function named remove_spaces that takes a string as input and returns the string without any spaces. The function uses the \"pure\" attribute, ensuring that it only depends on its input arguments and has no side effects. The input parameter is a character string. The output parameter is also a character string."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=:), allocatable :: str, res\n  \n  !case1\n  str = '  remove_spaces  '\n  res = remove_spaces(str)\n  print *, res\n  \n  !case2\n  str = 'This is a test'\n  res = remove_spaces(str)\n  print *, res\n\n  !case3\n  str = ' Remove   Multiple   Spaces   '\n  res = remove_spaces(str)\n  print *, res\n\n  !case4\n  str = '   12345   '\n  res = remove_spaces(str)\n  print *, res\n\n  !case5\n  str = '  SpaceBefore   AndAfterSpace   '\n  res = remove_spaces(str)\n  print *, res\n\nend program main",
            "result": [
                "remove_spaces",
                "Thisisatest",
                "RemoveMultipleSpaces",
                "12345",
                "SpaceBeforeAndAfterSpace"
            ]
        },
        "code": "    pure function remove_spaces(str) result(res)\n        !! remove whitespace in the given string.\n\n        character(len=*), intent(in) :: str\n            !! the string.\n        character(len=:), allocatable :: res\n            !! the string without spaces.\n\n        character(len=len_trim(str)) :: tmp\n        integer :: i, j, c\n\n        tmp = adjustl(str)\n\n        j = 0\n\n        do i = 1, len_trim(tmp)\n            c = iachar(tmp(i:i))\n            if ((c == int(z'20')) .or. (c >= int(z'09') .and. c <= int(z'0d'))) then\n                cycle\n            end if\n            j = j + 1\n            tmp(j:j) = tmp(i:i)\n        end do\n\n        if (j == 0) then\n            res = ''\n        else\n            res = tmp(1:j)\n        end if\n    end function remove_spaces\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named to_upper that converts a given string into uppercase. The function accepts one input argument of type character array and returns one output argument of the same type.",
            "Write a Fortran function named \"to_upper\" that takes a string as input and converts it to uppercase. The function should have one input parameter of type character(len=*), and one output parameter of the same type.",
            "Give me a Fortran function code named to_upper that converts a given string into uppercase. The function takes one input argument of type character(len=*), which is the string to be converted. It returns one output argument of type character(len=len(str)), which is the converted uppercase string. The function uses the pure keyword to indicate that it does not have any side effects. The function iterates over each character in the input string, checks if it is a lowercase letter using the ASCII code, and converts it to uppercase by subtracting 32 from the ASCII value. The converted string is then returned as the result."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=30) :: str\n  \n  !case1\n  str = \"Hello World!\"\n  print *, to_upper(str)\n  \n  !case2\n  str = \"fOrTrAn\"\n  print *, to_upper(str)\n  \n  !case3\n  str = \"12345\"\n  print *, to_upper(str)\n  \n  !case4\n  str = \"aBcDeF\"\n  print *, to_upper(str)\n  \n  !case5\n  str = \"Testing123\"\n  print *, to_upper(str)\n  \nend program main",
            "result": [
                "HELLO WORLD!",
                "FORTRAN",
                "12345",
                "ABCDEF",
                "TESTING123"
            ]
        },
        "code": "    pure function to_upper(str) result(res)\n        !! convert a string into uppercase.\n\n        character(len=*), intent(in) :: str\n            !! the string to be converted.\n        character(len=len(str)) :: res\n            !! the converted uppercase string.\n\n        integer :: i, c\n\n        res = str\n\n        do i = 1, len_trim(res)\n            c = iachar(res(i:i))\n            select case (c)\n            case (97:122)\n                res(i:i) = achar(c - 32)\n            end select\n        end do\n    end function to_upper\n"
    },
    {
        "instruction": [
            "Provide a Fortran function named \"studnt\" that calculates the upper tail area under Student's t-distribution. The function takes two input arguments, \"t\" of type real and \"doff\" of type real. The function returns a single output argument, \"fn_val\" of type real. \n\nTo use the function, ensure that the degrees of freedom, \"doff\", are greater than 4. Then, call the function with the desired value of \"t\" to compute the upper tail area. The function performs a series evaluation using various constants and formulas to obtain the result. If \"t\" is positive, the calculated upper tail area is returned as \"fn_val\". Otherwise, one minus the calculated upper tail area is returned as \"fn_val\".",
            "Provide a Fortran function code named studnt to calculate the upper tail area under Student's t-distribution. The function requires two input parameters: t (real) and doff (real). The function returns a single output parameter fn_val (real). The function implements the algorithm AS 27 from Applied Statistics, Volume 19, No. 1. \n\nTo use the function, call it with the values of t and doff as input arguments. The function will compute the upper tail area under Student's t-distribution and return the result in the output parameter fn_val.",
            "Provide a Fortran function code named studnt to calculate the upper tail area under Student's t-distribution. The function takes two input arguments of type real, namely t and doff. The function returns a single output of type real, named fn_val. The code uses a series evaluation algorithm to compute the upper tail area. Check that the degrees of freedom (doff) are greater than 4, and then calculate the series using the provided coefficients. If the input t is positive, return the calculated value (x), otherwise return 1 minus x."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real :: t, doff\n\n  !case1\n  t = 1.96\n  doff = 10.0\n  print *, studnt(t, doff)\n  \n  !case2\n  t = -2.57\n  doff = 20.0\n  print *, studnt(t, doff)\n  \n  !case3\n  t = 0.75\n  doff = 30.0\n  print *, studnt(t, doff)\n  \n  !case4\n  t = -1.34\n  doff = 40.0\n  print *, studnt(t, doff)\n  \n  !case5\n  t = 2.0\n  doff = 50.0\n  print *, studnt(t, doff)\n  \nend program main",
            "result": [
                "3.92135233E-02",
                "0.990863681",
                "0.229548439",
                "0.906095862",
                "2.54739877E-02"
            ]
        },
        "code": "function studnt (t, doff) result(fn_val)\r\n\r\n! n.b. argument ifault has been removed.\r\n \r\n! code converted using to_f90 by alan miller\r\n! date: 2002-01-02  time: 21:19:45\r\n\r\n!     algorithm as 27  appl. statist. vol.19, no.1\r\n\r\n!     calculate the upper tail area under student's t-distribution\r\n\r\n!     translated from algol by alan miller\r\n\r\nimplicit none\r\nreal, intent(in)      :: t\r\nreal, intent(in)      :: doff\r\nreal                  :: fn_val\r\n\r\n!     local variables\r\n\r\nreal     :: v, x, tt\r\nlogical  :: pos\r\nreal, parameter  :: four = 4.0, one = 1.0, zero = 0.0, half = 0.5\r\nreal, parameter  :: a1 = 0.09979441, a2 = -0.581821, a3 = 1.390993,  &\r\n                    a4 = -1.222452, a5 = 2.151185\r\nreal, parameter  :: b1 = 5.537409, b2 = 11.42343\r\nreal, parameter  :: c1 = 0.04431742, c2 = -0.2206018, c3 = -0.03317253,  &\r\n                    c4 = 5.679969, c5 = -12.96519\r\nreal, parameter  :: d1 = 5.166733, d2 = 13.49862\r\nreal, parameter  :: e1 = 0.009694901, e2 = -0.1408854, e3 = 1.88993,  &\r\n                    e4 = -12.75532, e5 = 25.77532\r\nreal, parameter  :: f1 = 4.233736, f2 = 14.3963\r\nreal, parameter  :: g1 = -9.187228e-5, g2 = 0.03789901, g3 = -1.280346,  &\r\n                    g4 = 9.249528, g5 = -19.08115\r\nreal, parameter  :: h1 = 2.777816, h2 = 16.46132\r\nreal, parameter  :: i1 = 5.79602e-4, i2 = -0.02763334, i3 = 0.4517029,  &\r\n                    i4 = -2.657697, i5 = 5.127212\r\nreal, parameter  :: j1 = 0.5657187, j2 = 21.83269\r\n\r\n!     check that number of degrees of freedom > 4.\r\n\r\nif (doff <= four) then\r\n  write(*, *) '** error in as27 - degrees of freedom <= 4  **'\r\n  return\r\nend if\r\n\r\n!     evaluate series.\r\n\r\nv = one / doff\r\npos = (t >= zero)\r\ntt = abs(t)\r\nx = half*(one +   &\r\n    tt*(((a1 + v*(a2 + v*(a3 + v*(a4 + v*a5)))) / (one - v*(b1 - v*b2))) +  &\r\n    tt*(((c1 + v*(c2 + v*(c3 + v*(c4 + v*c5)))) / (one - v*(d1 - v*d2))) +  &\r\n    tt*(((e1 + v*(e2 + v*(e3 + v*(e4 + v*e5)))) / (one - v*(f1 - v*f2))) +  &\r\n    tt*(((g1 + v*(g2 + v*(g3 + v*(g4 + v*g5)))) / (one - v*(h1 - v*h2))) +  &\r\n    tt*((i1 + v*(i2 + v*(i3 + v*(i4 + v*i5)))) / (one - v*(j1 - v*j2))) ))))) ** (-8)\r\nif (pos) then\r\n  fn_val = x\r\nelse\r\n  fn_val = one - x\r\nend if\r\n\r\nreturn\r\nend function studnt\r\n"
    },
    {
        "instruction": [
            "Write a Fortran function named \"b32\" that calculates a specific mathematical expression. The function takes a single input argument of type real(8). The output of the function is also of type real(8). \n\nThe function \"b32\" implements the equation ((-2 * xx + 2) * xx + 1) / 2. \n\nTo use the function, you need to provide a single real(8) value as input and the function will return the result of the equation as output.",
            "Provide a Fortran function named b32 that takes a real(8) input argument named xx. The function calculates and returns a real(8) value as the output. The function uses the formula ((-2.d0 * xx +2.d0) * xx +1.d0) / 2.d0 to compute the result. The function has one input parameter of type real(8) and one output parameter of type real(8).",
            "Write a Fortran function named b32 that takes in a single input argument of type real(8) and returns a value of the same type. The function computes a mathematical expression ((-2.d0 * xx + 2.d0) * xx + 1.d0) / 2.d0 to calculate the value of b32. The function has an intent(in) attribute for the input argument, and the output value is assigned to the variable b32."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real(8) :: xx\n\n  !case1\n  xx = 0.5d0\n  print *, b32(xx)\n\n  !case2\n  xx = -2.0d0\n  print *, b32(xx)\n\n  !case3\n  xx = 3.14d0\n  print *, b32(xx)\n\n  !case4\n  xx = 1.0d0\n  print *, b32(xx)\n\n  !case5\n  xx = -0.123d0\n  print *, b32(xx)\n\nend program main",
            "result": [
                "0.75000000000000000",
                "-5.5000000000000000",
                "-6.2196000000000007",
                "0.50000000000000000",
                "0.36187100000000000"
            ]
        },
        "code": "function b32(xx)\n\timplicit none\n\treal(8), intent(in) :: xx\n\treal(8) :: b32\n\t\tb32 = ((-2.d0 * xx +2.d0) * xx +1.d0) / 2.d0\n\treturn\nend function\n"
    },
    {
        "instruction": [
            "Create a Fortran function named boundary_func that calculates the value of a boundary function at a given point (x, y). The function takes two real input arguments (x and y) and returns a real output value. The function utilizes the mathematical constants and functions available in Fortran, such as pi, sin, and exp, to compute the value of the boundary function.",
            "Give me a Fortran function code named boundary_func to calculate the value of a boundary function. The boundary_func function takes in two input parameters, both of which are real numbers. The function returns a real number as the output. The boundary_func function computes the value of the function sin(pi * x) * exp(-pi * y), where pi is a predefined constant.",
            "Write a Fortran function named boundary_func that calculates the value of a mathematical function at a given point. The function takes two input arguments of type real, named x and y. The function also has one output argument of type real, named boundary_func. The function calculates the value of the function, which is the sine of pi multiplied by x, multiplied by the exponential function of negative pi multiplied by y. Make sure to include the \"implicit none\" statement to enforce explicit variable declarations."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real(kind=8) :: x, y\n\n  !case1\n  x = 0.5\n  y = 0.5\n  print *, boundary_func(x, y)\n\n  !case2\n  x = -1.0\n  y = 2.0\n  print *, boundary_func(x, y)\n\n  !case3\n  x = 1.2\n  y = -0.8\n  print *, boundary_func(x, y)\n\n  !case4\n  x = 0.0\n  y = 0.0\n  print *, boundary_func(x, y)\n\n  !case5\n  x = 0.25\n  y = 0.75\n  print *, boundary_func(x, y)\n  \nend program main",
            "result": [
                "0.20787957635076193",
                "-2.2869577639771785E-019",
                "-7.2563776027360651",
                "0.0000000000000000",
                "6.7019739708273365E-002"
            ]
        },
        "code": "function boundary_func(x,y)\n        implicit none \n        real(kind = 8) :: boundary_func, x, y, pi\n        pi = 4.d0*atan(1.d0)\n        boundary_func = sin(pi*x)*exp(-pi*y)\nend function\n"
    },
    {
        "instruction": [
            "Write a Fortran function named atan4 that calculates the arctangent of four input values. The function takes four real numbers as input arguments and returns a real number as the result. The input arguments are passed using the \"intent(in)\" attribute. The function uses the \"atan2\" function to calculate the arctangent and subtracts a fifth input value from the result. If the difference between the calculated angle and the fifth input value exceeds pi (180 degrees), it adjusts the angle by adding or subtracting 2*pi accordingly.",
            "Write a Fortran function code named \"atan4\" to compute the arctangent of a complex number in the form of a/b and subtract a given angle. The function takes four input arguments of type \"real\" - a, b, c, and d. The function returns a value of type \"real(kind=8)\". The function first computes the arctangent of a/b using the \"atan2\" function and then subtracts the angle c. If the resulting angle is greater than pi (180 degrees), it is adjusted by subtracting 2*pi. Similarly, if the resulting angle is less than -pi, it is adjusted by adding 2*pi.",
            "Please provide a Fortran function named `atan4` that calculates the arctangent of four input parameters `a`, `b`, `c`, and `d`. All four parameters are of type real and have a kind of 8 (double precision). The function returns a real value with the same kind. It is important to note that the function uses the `atan2` function to calculate the arctangent and then subtracts the value of `c` from it. Additionally, if the resulting angle exceeds 180 degrees (pi) or is less than -180 degrees, it is adjusted by adding or subtracting 2*pi."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real(kind=8) :: a, b, c, d\n  \n  !case1\n  a = 1.0d0\n  b = 1.0d0\n  c = 0.0d0\n  d = 0.0d0\n  print *, atan4(a, b, c, d)\n\n  !case2\n  a = 0.0d0\n  b = 1.0d0\n  c = 0.0d0\n  d = 0.0d0\n  print *, atan4(a, b, c, d)\n\n  !case3\n  a = 1.0d0\n  b = 0.0d0\n  c = 0.0d0\n  d = 0.0d0\n  print *, atan4(a, b, c, d)\n\n  !case4\n  a = 1.0d0\n  b = 1.0d0\n  c = 0.0d0\n  d = 1.5707963267948966d0\n  print *, atan4(a, b, c, d)\n\n  !case5\n  a = 0.0d0\n  b = 1.0d0\n  c = 3.141592653589793d0\n  d = 3.141592653589793d0\n  print *, atan4(a, b, c, d)\nend program main",
            "result": [
                "0.78539816339744828",
                "0.0000000000000000",
                "1.5707963267948966",
                "0.78539816339744828",
                "3.1415926535897931"
            ]
        },
        "code": "   function atan4(a,b,c,d)\r\n    implicit none\r\n    real(kind=8) :: atan4\r\n    real(kind=8), intent(in) :: a,b,c,d\r\n    real (kind=8),parameter :: twopi=6.283185307179586d0, &\r\n                                  pi=3.141592553589793d0\r\n      atan4 = atan2(a,b) - c\r\n      !  limit angle change to pi (180 degrees)\r\n      if( atan4-d > pi  )then\r\n        atan4 = atan4 - twopi\r\n      else if( atan4-d < -pi )then\r\n        atan4 = atan4 + twopi\r\n      end if\r\n    end function\r\n"
    },
    {
        "instruction": [
            "Provide a Fortran function named \"getcolorgradvect\" that computes a color gradient vector based on the given input values. The function takes two input parameters: an array of real numbers called \"value\" and a real number called \"valueexp\". The function also has one output parameter, an array of integers called \"res\". \n\nInside the function, the input values are exponentiated with \"valueexp\". Then, the red, green, and blue components of the color gradient vector are calculated based on the given formulas. The resulting red, green, and blue values are assigned to the corresponding arrays. Finally, the \"res\" array is calculated by combining the red, green, and blue values using the provided expressions.\n\nNote: The variables \"br\", \"ar\", \"bg\", \"ag\", \"bb\", and \"ab\" used in the expressions are assumed to be defined elsewhere in the code.",
            "Provide a Fortran function named getcolorgradvect that takes in an array of real numbers and an exponent value as input and returns an array of integers as output. The number of input arguments is 2, where the first argument is an array of real numbers and the second argument is a real number. The number of elements in the input array should match the size of the output array. The output array is an array of integers. The function computes the color gradient vector for each element of the input array by raising each element to the power of the exponent value. It then calculates the red, green, and blue values based on predetermined values and the computed values. Finally, it combines the red, green, and blue values into a single integer value and stores it in the output array.",
            "Please provide a Fortran function named getcolorgradvect that computes the color gradient vector based on given input values. The function takes two input arguments: a 1D array of real numbers called \"value\" and a single real number called \"valueexp\". The function also has one output argument, which is a 1D array of integers called \"res\". The function calculates the color values for the red, green, and blue channels using the formula (br - ar) * value + ar for red, (bg - ag) * value + ag for green, and (bb - ab) * value + ab for blue, where ar, ag, ab, br, bg, and bb are constants. The resulting color values are then combined into a single integer using the formula res = red + 256 * green + 65536 * blue."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n\n  real(8), allocatable :: value(:)\n  integer, allocatable :: red(:), green(:), blue(:), res(:)\n  real(8) :: valueexp\n\n  !case1\n  n = 5\n  valueexp = 2.0\n  allocate(value(n), red(n), green(n), blue(n), res(n))\n  value = [1.0, 2.0, 3.0, 4.0, 5.0]\n  print *, getcolorgradvect(value, valueexp)\n  deallocate(value, red, green, blue, res)\n\n  !case2\n  n = 3\n  valueexp = 0.5\n  allocate(value(n), red(n), green(n), blue(n), res(n))\n  value = [0.0, 1.0, 2.0]\n  print *, getcolorgradvect(value, valueexp)\n  deallocate(value, red, green, blue, res)\n\n  !case3\n  n = 4\n  valueexp = 1.5\n  allocate(value(n), red(n), green(n), blue(n), res(n))\n  value = [2.0, 3.0, 4.0, 5.0]\n  print *, getcolorgradvect(value, valueexp)\n  deallocate(value, red, green, blue, res)\n\n  !case4\n  n = 2\n  valueexp = 3.0\n  allocate(value(n), red(n), green(n), blue(n), res(n))\n  value = [0.0, 1.0]\n  print *, getcolorgradvect(value, valueexp)\n  deallocate(value, red, green, blue, res)\n\n  !case5\n  n = 6\n  valueexp = 2.5\n  allocate(value(n), red(n), green(n), blue(n), res(n))\n  value = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]\n  print *, getcolorgradvect(value, valueexp)\n  deallocate(value, red, green, blue, res)\nend program main",
            "result": [
                "0           0           0           0           0",
                "0           0           0",
                "0           0           0           0",
                "0           0",
                "0           0           0           0           0           0"
            ]
        },
        "code": "    function getcolorgradvect(value,valueexp) result(res)\n        \n        real(8), dimension(:) :: value\n        integer, dimension(size(value)) :: red, green, blue\n        integer, dimension(size(value)) :: res\n        real(8) :: valueexp\n        \n        value = value**valueexp\n        \n        red   = (br - ar) * value + ar      ! evaluated as -255*value + 255.\n        green = (bg - ag) * value + ag      ! evaluates as 0.\n        blue  = (bb - ab) * value + ab      ! evaluates as 255*value + 0.\n        \n        res = red + 256*green + 65536*blue\n        \n    end function getcolorgradvect\n"
    },
    {
        "instruction": [
            "Create a Fortran function named sum_8bit that calculates the sum of two 8-bit integer numbers. The function takes two input parameters of type integer(1) and returns a single output parameter of the same type. The function should be declared with the \"dllexport\" attribute and the alias \"sum_8bit\".",
            "Create a Fortran function called sum_8bit that calculates the sum of two 8-bit integers. The function takes two input arguments of type integer(1) and returns a single output argument of the same type. The name of the function is \"sum_8bit\".",
            "Provide a Fortran function named sum_8bit that calculates the sum of two 8-bit integers. The function takes two input arguments of type integer(1) and returns a single output argument of the same type. The name of the function is \"sum_8bit\". The function should be exported and its alias should also be set to \"sum_8bit\"."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer(1) :: a, b, value\n\n  !case1: testing positive numbers\n  a = 10\n  b = 20\n  value = sum_8bit(a, b)\n  print *, value\n\n  !case2: testing negative numbers\n  a = -10\n  b = -20\n  value = sum_8bit(a, b)\n  print *, value\n\n  !case3: testing zero\n  a = 0\n  b = 0\n  value = sum_8bit(a, b)\n  print *, value\n\n  !case4: testing overflow\n  a = 127\n  b = 1\n  value = sum_8bit(a, b)\n  print *, value\n\n  !case5: testing underflow\n  a = -128\n  b = -1\n  value = sum_8bit(a, b)\n  print *, value\n\nend program main",
            "result": [
                "30",
                "-30",
                "0",
                "-128",
                "127"
            ]
        },
        "code": "function sum_8bit(a, b) result(value)\n    !dec$ attributes dllexport, alias:'sum_8bit' :: sum_8bit\n    implicit none\n    integer(1) :: a, b, value\n    value = a + b\nend function sum_8bit\n"
    },
    {
        "instruction": [
            "Write a Fortran function named sum_16bit that calculates the sum of two 16-bit integers. The function takes two input arguments, both of type integer(2), and returns a single output argument of the same type. The name of the function is sum_16bit.",
            "Create a Fortran function named \"sum_16bit\" that calculates the sum of two 16-bit integers. This function takes in two input parameters of type integer(2) and returns a single output parameter of the same type. The function should be declared with the attributes \"dllexport\" and \"alias\" to make it accessible from other programs.",
            "Write a Fortran function code named sum_16bit that computes the sum of two 16-bit integers. The function takes two input parameters of type integer(2) and returns a single output parameter of the same type. The function is named \"sum_16bit\" and it should be exported with the \"dllexport\" attribute."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer(2) :: a, b, value\n  \n  !case1\n  a = 100\n  b = 200\n  print *, sum_16bit(a, b)\n  \n  !case2\n  a = -32768\n  b = 32767\n  print *, sum_16bit(a, b)\n  \n  !case3\n  a = 0\n  b = 0\n  print *, sum_16bit(a, b)\n  \n  !case4\n  a = -10000\n  b = -5000\n  print *, sum_16bit(a, b)\n  \n  !case5\n  a = 32767\n  b = -1000\n  print *, sum_16bit(a, b)\n  \nend program main\n",
            "result": [
                "300",
                "-1",
                "0",
                "-15000",
                "31767"
            ]
        },
        "code": "function sum_16bit(a, b) result(value)\n    !dec$ attributes dllexport, alias:'sum_16bit' :: sum_16bit\n    implicit none\n    integer(2) :: a, b, value\n    value = a + b\nend function sum_16bit\n"
    },
    {
        "instruction": [
            "Please provide a Fortran function code named sum_32bit that calculates the sum of two 32-bit integers. The function has 2 input parameters of type integer(4) and 1 output parameter of type integer(4).",
            "Write a Fortran function named sum_32bit that adds two 32-bit integer numbers and returns the result as a 32-bit integer value. The function takes two input arguments, both of type integer(4), and returns one output argument of type integer(4).",
            "Please create a Fortran function called sum_32bit that calculates the sum of two 32-bit integers. This function takes two input parameters of type integer(4) and returns a single output parameter of the same type. Use the imperative tone when writing the instructions."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer(4) :: a, b, result\n\n  !case1\n  a = 10\n  b = 20\n  result = sum_32bit(a, b)\n  print *, result\n\n  !case2\n  a = -5\n  b = 3\n  result = sum_32bit(a, b)\n  print *, result\n\n  !case3\n  a = 100\n  b = -50\n  result = sum_32bit(a, b)\n  print *, result\n\n  !case4\n  a = 0\n  b = 0\n  result = sum_32bit(a, b)\n  print *, result\n\n  !case5\n  a = 2147483647\n  b = 1\n  result = sum_32bit(a, b)\n  print *, result\nend program main",
            "result": [
                "30",
                "-2",
                "50",
                "0",
                "-2147483648"
            ]
        },
        "code": "function sum_32bit(a, b) result(value)\n    !dec$ attributes dllexport, alias:'sum_32bit' :: sum_32bit\n    implicit none\n    integer(4) :: a, b, value\n    value = a + b\nend function sum_32bit\n"
    },
    {
        "instruction": [
            "Write a Fortran function code named multiply_float32 that calculates the product of two single-precision floating-point numbers. The function takes two input arguments of type real(4) and returns one output argument of the same type. The name of the function is multiply_float32.",
            "Create a Fortran function named multiply_float32 that multiplies two 32-bit floating-point numbers. The input parameters are two single-precision real numbers, and the output parameter is a single-precision real number. The function calculates the product of the two input numbers and stores the result in the output parameter.",
            "Write a Fortran function code named multiply_float32, which multiplies two 32-bit floating point numbers. The function takes two input arguments of type real(4) and returns one output argument of the same type."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real(4) :: a, b, result\n  \n  !case1\n  a = 2.5\n  b = 3.0\n  result = multiply_float32(a, b)\n  print *, result\n\n  !case2\n  a = -5.2\n  b = 4.8\n  result = multiply_float32(a, b)\n  print *, result\n\n  !case3\n  a = 0.0\n  b = 10.5\n  result = multiply_float32(a, b)\n  print *, result\n\n  !case4\n  a = 1.23456\n  b = 0.98765\n  result = multiply_float32(a, b)\n  print *, result\n\n  !case5\n  a = -3.14159\n  b = -2.71828\n  result = multiply_float32(a, b)\n  print *, result\nend program main",
            "result": [
                "7.50000000",
                "-24.9600010",
                "0.00000000",
                "1.21931314",
                "8.53972149"
            ]
        },
        "code": "function multiply_float32(a, b) result(value)\n    !dec$ attributes dllexport, alias:'multiply_float32' :: multiply_float32\n    implicit none\n    real(4) :: a, b, value\n    value = a * b\nend function multiply_float32\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named multiply_float64 that multiplies two floating-point numbers. The function takes two input arguments of type real(8), representing double precision floating-point numbers, and returns a single output argument of the same type.",
            "Create a Fortran function called multiply_float64 that multiplies two floating-point numbers and returns the result. The function should have two input parameters of type real(8) that represent the numbers to be multiplied. The function should also have one output parameter of type real(8) that holds the result of the multiplication.",
            "Please create a Fortran function named multiply_float64. This function takes in two floating-point numbers as input arguments and returns the product of these numbers as an output argument. The input arguments should be of type real(8), and the output argument should also be of type real(8). The function should be declared as dllexport and alias as 'multiply_float64'."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real(8) :: a, b, result\n  \n  !case1\n  a = 3.5d0\n  b = 2.0d0\n  result = multiply_float64(a, b)\n  print *, result\n  \n  !case2\n  a = -4.2d0\n  b = 1.5d0\n  result = multiply_float64(a, b)\n  print *, result\n  \n  !case3\n  a = 0.0d0\n  b = 100.0d0\n  result = multiply_float64(a, b)\n  print *, result\n  \n  !case4\n  a = 2.5d0\n  b = -2.5d0\n  result = multiply_float64(a, b)\n  print *, result\n  \n  !case5\n  a = 1.234567890123456789d0\n  b = 9.876543210987654321d0\n  result = multiply_float64(a, b)\n  print *, result\n  \nend program main",
            "result": [
                "7.0000000000000000",
                "-6.3000000000000007",
                "0.0000000000000000",
                "-6.2500000000000000",
                "12.193263113702178"
            ]
        },
        "code": "function multiply_float64(a, b) result(value)\n    !dec$ attributes dllexport, alias:'multiply_float64' :: multiply_float64\n    implicit none\n    real(8) :: a, b, value\n    value = a * b\nend function multiply_float64\n"
    },
    {
        "instruction": [
            "Provide a Fortran function named \"is_positive\" that determines whether a given floating-point number is positive or not. The function takes one input argument of type real(8) and returns a logical value. The input argument is named \"a\" and the output value is named \"value\".",
            "Write a Fortran function named \"is_positive\" that checks whether a given floating-point number is positive or not. The function takes one input argument of type real(8) and returns a logical value.",
            "Create a Fortran function called is_positive that determines whether a given floating-point number is positive or not. The function takes one input argument of type real(8) and returns a logical value indicating if the number is positive or not. The function should be exported and have the alias name \"is_positive\"."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real(8) :: a\n  \n  !case1\n  a = 5.6d0\n  print *, is_positive(a)\n  \n  !case2\n  a = -3.2d0\n  print *, is_positive(a)\n  \n  !case3\n  a = 0.0d0\n  print *, is_positive(a)\n  \n  !case4\n  a = 10.12d0\n  print *, is_positive(a)\n  \n  !case5\n  a = -1.5d0\n  print *, is_positive(a)\nend program main",
            "result": [
                "T",
                "F",
                "F",
                "T",
                "F"
            ]
        },
        "code": "function is_positive(a) result(value)\n    !dec$ attributes dllexport, alias:'is_positive' :: is_positive\n    implicit none\n    logical :: value\n    real(8) :: a\n    value = a > 0.d0\nend function is_positive\n"
    },
    {
        "instruction": [
            "Create a Fortran function called add_or_subtract that takes in two integer parameters, \"a\" and \"b\", and a logical parameter, \"do_addition\". The function calculates the sum or difference of \"a\" and \"b\" based on the value of \"do_addition\". If \"do_addition\" is true, the function returns the sum of \"a\" and \"b\". Otherwise, it returns the difference of \"a\" and \"b\". The function should have one output parameter of type integer(4).",
            "Create a Fortran function named add_or_subtract that takes in two integer numbers and a logical variable indicating whether to perform addition or subtraction. The function returns an integer value. The input parameters are of type integer(4) and logical, while the output parameter is of type integer(4). The function computes the sum or difference of the two input numbers based on the value of the logical variable.",
            "Create a Fortran function named \"add_or_subtract\" to perform addition or subtraction based on a logical input. The function takes two integer arguments and one logical argument. The number of input arguments is 3 and the data type of the input arguments is [integer(4), integer(4), logical]. The number of output arguments is 1 and the data type of the output argument is [integer(4)]."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: a, b, value\n  logical :: do_addition\n  \n  !case1\n  a = 5\n  b = 3\n  do_addition = .true.\n  value = add_or_subtract(a, b, do_addition)\n  print *, value\n  \n  !case2\n  a = 10\n  b = 7\n  do_addition = .false.\n  value = add_or_subtract(a, b, do_addition)\n  print *, value\n  \n  !case3\n  a = -2\n  b = 8\n  do_addition = .true.\n  value = add_or_subtract(a, b, do_addition)\n  print *, value\n  \n  !case4\n  a = 0\n  b = 0\n  do_addition = .true.\n  value = add_or_subtract(a, b, do_addition)\n  print *, value\n  \n  !case5\n  a = 100\n  b = -50\n  do_addition = .false.\n  value = add_or_subtract(a, b, do_addition)\n  print *, value\n  \nend program main",
            "result": [
                "8",
                "3",
                "6",
                "0",
                "150"
            ]
        },
        "code": "function add_or_subtract(a, b, do_addition) result(value)\n    !dec$ attributes dllexport, alias:'add_or_subtract' :: add_or_subtract\n    implicit none\n    logical :: do_addition\n    integer(4) :: a, b, value\n    if (do_addition) then\n        value = a + b\n    else\n        value = a - b\n    endif\nend function add_or_subtract\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named upcase to convert all lowercase characters in a given string to uppercase characters. The number of input arguments is 1 and the data type is a character string. The number of output arguments is 1 and the data type is also a character string.",
            "Provide a Fortran function code named upcase to convert all lowercase characters in a given string to uppercase. The function takes a single input argument of type character and returns the modified string. The input argument is declared with the intent(in) attribute. The function uses the iso_c_binding module for compatibility with C. The function uses the implicit none statement to enforce explicit variable declaration. The function also declares a local variable n of type integer and a loop index variable i of type integer. The function defines two character parameters uc and lc, representing the uppercase and lowercase alphabet letters, respectively. The function initializes the output string ss with the input string s. The function then iterates over each character in the input string using a do loop. For each character, it checks if it is a lowercase letter by finding its index in the lc string. If a lowercase letter is found, the corresponding uppercase letter is retrieved from the uc string and assigned to the corresponding position in the output string ss. Finally, the modified string ss is returned as the result of the function.",
            "Give me a Fortran function code named upcase to convert all lowercase characters in a given string to uppercase. The function takes a single input argument of type character and returns a modified string as the output."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=10) :: s\n  \n  !case1\n  s = \"hello\"\n  print *, upcase(s)\n\n  !case2\n  s = \"world\"\n  print *, upcase(s)\n\n  !case3\n  s = \"Fortran\"\n  print *, upcase(s)\n\n  !case4\n  s = \"12345\"\n  print *, upcase(s)\n\n  !case5\n  s = \"AbCdEfG\"\n  print *, upcase(s)\nend program main",
            "result": [
                "hello",
                "world",
                "Fortran",
                "12345",
                "AbCdEfG"
            ]
        },
        "code": "  function upcase(s) result(ss)\n    use iso_c_binding\n    implicit none\n    character(kind=c_char,len=*), intent(in) :: s\n    character(kind=c_char,len=len(s)) :: ss\n    integer :: n, i\n    character(*), parameter :: uc = \"abcdefghijklmnopqrstuvwxyz\"\n    character(*), parameter :: lc = \"abcdefghijklmnopqrstuvwxyz\"\n    ss = s\n    do i = 1, len_trim(s)\n       n = index(lc, s(i:i))\n       if (n /= 0) ss(i:i) = uc(n:n)\n    end do\n  end function upcase\n"
    },
    {
        "instruction": [
            "Provide a Fortran function named sum_digits_squared that calculates the sum of the squares of the individual digits in a given integer number. The function takes one input argument of type integer, named \"number\". The function returns one output argument of type integer, named \"result\", which contains the computed sum.",
            "Write a Fortran function named \"sum_digits_squared\" that calculates the sum of the squares of the digits of an integer input. The function takes one input argument of type integer and returns one output argument of type integer.",
            "Write a Fortran function code named sum_digits_squared that calculates the sum of the squares of each digit in a given number. The function takes one input argument, an integer named \"number\". The function returns the sum of the squared digits as an integer named \"result\"."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: number\n\n  !case1\n  number = 1234\n  print *, sum_digits_squared(number)\n  \n  !case2\n  number = 9876\n  print *, sum_digits_squared(number)\n  \n  !case3\n  number = 0\n  print *, sum_digits_squared(number)\n  \n  !case4\n  number = -567\n  print *, sum_digits_squared(number)\n  \n  !case5\n  number = 99999999\n  print *, sum_digits_squared(number)\n  \nend program main",
            "result": [
                "30",
                "230",
                "0",
                "110",
                "648"
            ]
        },
        "code": "  function sum_digits_squared (number) result (result)\n\n    implicit none\n    integer, intent (in) :: number\n    integer :: result\n    integer :: digit\n    integer :: rest\n    integer :: work\n\n    result = 0\n    work = number\n    do\n      if (work == 0) then\n        exit\n      end if\n      rest = work / 10\n      digit = work - 10 * rest\n      result = result + digit * digit\n      work = rest\n    end do\n\n  end function sum_digits_squared\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named spring_1 that calculates the quantum potential between two atoms in a polymer system. The function takes in six arguments, including the coordinates of the atom of interest (rik), coordinates of the other atom of interest (ril), simulation box length (box), and spring potential constant (k_spring). The function returns the partial potential (partial_pot) between the two atoms. The coordinates are given as real numbers in three dimensions. The function handles periodic boundaries by applying the anint function to the coordinate differences and computes the squared distance between the atoms. The spring potential is calculated using the squared distance and the spring constant. The units used in the calculations are specified as sigma=1 for the squared distance and lj units for the spring potential.",
            "Please provide a Fortran function code named \"spring_1\" that calculates the quantum spring energy between two atoms in a polymer system. The function takes as input the coordinates of the atoms of interest (rik and ril), the simulation box length (box), and the spring potential constant (k_spring). The function returns the partial potential energy (partial_pot) in LJ units. \n\nTo calculate the potential energy, the function subtracts the coordinates of the second atom from the first atom and applies periodic boundary conditions. It then calculates the squared distance between the two atoms, taking into account the simulation box length. Finally, the function computes the spring potential using the spring constant and the squared distance.\n\nPlease note that the input coordinates must be dimensioned as real arrays of size 3. The output partial potential energy is also a real value.\n\n",
            "Please write a Fortran function named spring_1 that calculates the quantum potential for a given atom in a polymer system. The function takes in 2 input parameters of type real and dimensions (3), which are the coordinates of the atom of interest (rik) and the coordinates of another atom in the same polymer ring (ril). It also takes in 2 input parameters of type real, box (simulation box length) and k_spring (spring potential constant). The function returns a single output parameter of type real, partial_pot, which is the quantum spring energy of the atom (i,k) in rik with its neighbor (i,l) in the same polymer ring. The function assumes that the coordinates in rik have already been divided by box and the results are in LJ units where sigma = 1 and epsilon = 1. The function calculates the squared distance between rik and ril, applies periodic boundaries using the box length, and then calculates the spring potential using the spring constant and the squared distance."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real, dimension(3) :: rik, ril\n  real :: box, k_spring, partial_pot\n  \n  !case1\n  rik = [0.0, 0.0, 0.0]\n  ril = [1.0, 1.0, 1.0]\n  box = 10.0\n  k_spring = 2.0\n  partial_pot = spring_1(rik, ril, box, k_spring)\n  print *, partial_pot\n  \n  !case2\n  rik = [2.5, 3.5, 4.5]\n  ril = [1.5, 2.5, 3.5]\n  box = 5.0\n  k_spring = 1.0\n  partial_pot = spring_1(rik, ril, box, k_spring)\n  print *, partial_pot\n  \n  !case3\n  rik = [0.0, 0.0, 0.0]\n  ril = [0.0, 0.0, 0.0]\n  box = 1.0\n  k_spring = 0.5\n  partial_pot = spring_1(rik, ril, box, k_spring)\n  print *, partial_pot\n  \n  !case4\n  rik = [0.5, 0.5, 0.5]\n  ril = [0.0, 0.0, 0.0]\n  box = 2.0\n  k_spring = 2.5\n  partial_pot = spring_1(rik, ril, box, k_spring)\n  print *, partial_pot\n  \n  !case5\n  rik = [0.1, 0.2, 0.3]\n  ril = [0.4, 0.5, 0.6]\n  box = 0.5\n  k_spring = 1.5\n  partial_pot = spring_1(rik, ril, box, k_spring)\n  print *, partial_pot\n  \nend program main",
            "result": [
                "0.00000000",
                "0.00000000",
                "0.00000000",
                "3.75000000",
                "5.06250039E-02"
            ]
        },
        "code": "  function spring_1 ( rik, ril, box, k_spring ) result ( partial_pot )\n    implicit none\n    real                           :: partial_pot ! returns quantum potential for given atom\n    real, dimension(3), intent(in) :: rik         ! coordinates of atom of interest\n    real, dimension(3), intent(in) :: ril         ! coordinates of other atom of interest\n    real,               intent(in) :: box         ! simulation box length\n    real,               intent(in) :: k_spring    ! spring potential constant\n\n    ! partial_pot is the quantum spring energy of atom (i,k) in rik for polymer bead k\n    ! with its neighbour (i,l) in the same polymer ring\n    ! the coordinates in rik are not necessarily identical with those in r(:,i,k)\n    ! the partner atom index is always the same as i\n\n    ! it is assumed that r has been divided by box\n    ! results are in lj units where sigma = 1, epsilon = 1\n\n    real               :: r_ik_il_sq\n    real, dimension(3) :: r_ik_il\n\n    r_ik_il(:)  = rik(:) - ril(:)\n    r_ik_il(:)  = r_ik_il(:) - anint ( r_ik_il(:) ) ! periodic boundaries in box=1 units\n    r_ik_il_sq  = sum ( r_ik_il**2 ) *  box**2      ! squared distance in sigma=1 units\n    partial_pot = 0.5 * k_spring * r_ik_il_sq       ! spring potential\n\n  end function spring_1\n"
    },
    {
        "instruction": [
            "Create a Fortran function called compress that takes a string as input and removes all spaces and tabs from it. The function has one input parameter of type character(len=*), named str_in, and one output parameter of the same type and length, named str_out. The function iterates through each character of the input string and checks if it is a space or tab character. If it is not, the character is added to the output string. Finally, the compressed string is returned as the output of the function.",
            "Create a Fortran function named \"compress\" that takes a string as input and returns a compressed version of the string with all spaces and tabs removed. The function should have one input parameter of type character(len=*) and one output parameter of type character(len=len(str_in)).",
            "Write a Fortran function named compress that takes an input string and removes all spaces and tabs from it. The function has one input parameter of type character and one output parameter of type character. The name of the input parameter is \"str_in\" and the name of the output parameter is \"str_out\". Invoke the function by calling \"compress(str_in)\" and it will return the compressed string without spaces and tabs."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=100) :: str_in, str_out\n\n  !case1\n  str_in = \"Hello World\"\n  str_out = compress(str_in)\n  print *, str_out\n\n  !case2\n  str_in = \"   Test    String   \"\n  str_out = compress(str_in)\n  print *, str_out\n\n  !case3\n  str_in = \"1234567890\"\n  str_out = compress(str_in)\n  print *, str_out\n\n  !case4\n  str_in = \"  This  is   a    test  \"\n  str_out = compress(str_in)\n  print *, str_out\n\n  !case5\n  str_in = \"NoSpacesOrTabs\"\n  str_out = compress(str_in)\n  print *, str_out\n\nend program main",
            "result": [
                "HelloWorld",
                "TestString",
                "1234567890",
                "Thisisatest",
                "NoSpacesOrTabs"
            ]
        },
        "code": "   function compress(str_in) result(str_out)\n      ! inputs/outputs\n      character(len=*), intent(in) :: str_in  !< input string\n      character(len=len(str_in)) :: str_out   !< output string, no more spaces and tabs\n      ! local variables\n      integer, parameter :: iachar_space = 32\n      integer, parameter :: iachar_tab = 9\n      integer :: i,j,my_iachar\n      j=0; str_out=' '\n      do i=1,len(str_in)\n         my_iachar=iachar(str_in(i:i))\n         if (my_iachar.ne.iachar_space .and. my_iachar.ne.iachar_tab) then\n            j=j+1; str_out(j:j)=str_in(i:i)\n         end if\n      end do\n   end function compress\n"
    },
    {
        "instruction": [
            "Write a Fortran function named getoddpositionelements that takes an input array of integers and returns an array containing only the elements at odd positions. The function should have one input parameter of type integer array and one output parameter of type integer array. \n\nTo implement the function, declare an integer array named 'r' with a size of (size(list)+1)/2. Initialize a variable 'j' to 1. Use a do loop to iterate through the input array. Inside the loop, check if the current position is odd using the modulo operator. If it is odd, assign the corresponding element from the input array to the 'r' array at position 'j' and increment 'j' by 1. Finally, the function should return the 'r' array which contains only the elements at odd positions.",
            "Give me a Fortran function code named getoddpositionelements that returns an array containing the elements at odd positions from a given input array. The input argument is an integer array, and the output argument is also an integer array. The function takes the input array and extracts the values at positions 1, 3, 5, and so on, and stores them in the output array.",
            "Create a Fortran function named getoddpositionelements that takes an input integer array and returns a new array consisting of the elements at odd positions from the input array. The number of input arguments is 1 and the data type is an integer array. The number of output arguments is 1 and the data type is also an integer array."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer, allocatable :: list(:)\n  integer, allocatable :: r(:)\n\n  !case1\n  allocate(list(5))\n  list = [1, 2, 3, 4, 5]\n  r = getoddpositionelements(list)\n  print *, r\n  deallocate(list, r)\n\n  !case2\n  allocate(list(6))\n  list = [10, 20, 30, 40, 50, 60]\n  r = getoddpositionelements(list)\n  print *, r\n  deallocate(list, r)\n\n  !case3\n  allocate(list(7))\n  list = [100, 200, 300, 400, 500, 600, 700]\n  r = getoddpositionelements(list)\n  print *, r\n  deallocate(list, r)\n\n  !case4\n  allocate(list(3))\n  list = [0, 0, 0]\n  r = getoddpositionelements(list)\n  print *, r\n  deallocate(list, r)\n\n  !case5\n  allocate(list(8))\n  list = [5, -4, 3, -2, 1, -1, 2, -3]\n  r = getoddpositionelements(list)\n  print *, r\n  deallocate(list, r)\n\nend program main",
            "result": [
                "1           3           5",
                "10          30          50",
                "100         300         500         700",
                "0           0",
                "5           3           1           2"
            ]
        },
        "code": "        function getoddpositionelements(list) result(r)\n            integer, dimension(1:), intent(in) :: list\n            integer, dimension(1:(size(list)+1)/2) :: r\n            integer :: i\n            integer :: j\n            \n            j=1            \n            do i=1,size(list)\n                if (modulo(i, 2) == 1) then ! odd position\n                    r(j) = list(i)\n                    j = j + 1\n                end if\n            end do\n            \n        end function getoddpositionelements\n"
    },
    {
        "instruction": [
            "Write a Fortran function named \"indexof\" that returns the index of a given element in a sorted array. The function takes two input parameters: an integer element and an integer array (both passed by value). The function also returns an integer value as the output parameter.",
            "Please write a Fortran function named \"indexof\" that returns the index of a given element in a sorted array. The function should have two input parameters: an integer \"element\" and an integer array \"array\". The function should also have one output parameter, which is an integer \"indexof\". The function works by performing a binary search on the sorted array to find the index of the given element. If the element is not found in the array, the function should return -1.",
            "Please provide a Fortran function code named \"indexof\" that returns the index of an element in a sorted array. The function takes two input parameters: \"element\" of type integer and \"array\" of type integer array. The function returns an integer value representing the index of the element in the array. If the element is not found in the array or the array is not sorted, the function returns -1."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: element\n  integer, allocatable :: array(:)\n  \n  !case1\n  allocate(array(5))\n  array = [1, 2, 3, 4, 5]\n  element = 2\n  print *, indexof(element, array)\n  deallocate(array)\n\n  !case2\n  allocate(array(7))\n  array = [10, 20, 30, 40, 50, 60, 70]\n  element = 60\n  print *, indexof(element, array)\n  deallocate(array)\n\n  !case3\n  allocate(array(3))\n  array = [5, 10, 15]\n  element = 20\n  print *, indexof(element, array)\n  deallocate(array)\n\n  !case4\n  allocate(array(4))\n  array = [0, 0, 0, 0]\n  element = 0\n  print *, indexof(element, array)\n  deallocate(array)\n\n  !case5\n  allocate(array(6))\n  array = [-10, -5, 0, 5, 10, 15]\n  element = -5\n  print *, indexof(element, array)\n  deallocate(array)\nend program main\n    ",
            "result": [
                "2",
                "6",
                "-1",
                "2",
                "2"
            ]
        },
        "code": "  function indexof(element, array)\n    ! please note that array has to be sorted\n    integer :: indexof\n    integer, intent(in) :: element\n    integer, intent(in), dimension(:) :: array\n\n    integer :: left, right, middle\n    left = lbound(array, 1)\n    right = ubound(array, 1)\n    middle = (left + right) / 2\n\n    indexof = -1\n\n    if (array(left) > element .or. array(right) < element) then\n       return\n    end if\n    do while (element /= array(middle))\n       if (left > right) then\n          return\n       end if\n\n       if (element > array(middle)) then\n          left = middle + 1\n       else if (element < array(middle)) then\n          right = middle - 1\n       end if\n       middle = (left + right) / 2\n\n    end do\n\n    indexof = middle\n\n  end function indexof\n"
    },
    {
        "instruction": [
            "Create a Fortran function named \"tmpedge2localedge\" that takes an integer input argument named \"iedge\". The function returns an integer output named \"ilocaledge\". The function computes the local edge index corresponding to a given global edge index. The number of input arguments is 1 and the data type is integer. The number of output arguments is 1 and the data type is integer.",
            "Provide a Fortran function code named tmpedge2localedge that converts a given input integer edge index to its corresponding local edge index. The function takes an integer input argument named iedge. The function returns an integer output argument named ilocaledge.",
            "Write a Fortran function named tmpedge2localedge that takes an integer input argument iedge and returns an integer output result ilocaledge. The purpose of this function is to convert a temporary edge index to a local edge index by performing a mathematical operation. The input argument iedge is of type integer and is passed by value. The output result ilocaledge is also of type integer. The function takes the input argument iedge and computes the value of ilocaledge using the modulo operator and addition. The result is then returned by the function."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: iedge, ilocaledge\n  \n  !case1\n  iedge = 0\n  ilocaledge = tmpedge2localedge(iedge)\n  print *, ilocaledge\n  \n  !case2\n  iedge = 1\n  ilocaledge = tmpedge2localedge(iedge)\n  print *, ilocaledge\n  \n  !case3\n  iedge = 2\n  ilocaledge = tmpedge2localedge(iedge)\n  print *, ilocaledge\n  \n  !case4\n  iedge = 5\n  ilocaledge = tmpedge2localedge(iedge)\n  print *, ilocaledge\n  \n  !case5\n  iedge = -3\n  ilocaledge = tmpedge2localedge(iedge)\n  print *, ilocaledge\nend program main",
            "result": [
                "3",
                "1",
                "2",
                "2",
                "0"
            ]
        },
        "code": "function tmpedge2localedge(iedge) result(ilocaledge)\nimplicit none\n    integer, intent(in) :: iedge\n    integer :: ilocaledge\n\n    ilocaledge = mod(iedge+2,3)+1\n    return\nend function tmpedge2localedge\n"
    },
    {
        "instruction": [
            "Provide a Fortran function called sgn that returns the sign of a given real number. The function takes 1 input argument of type real and returns 1 output argument of type real. The function determines the sign of the input number as follows: \n- If the input number is equal to 0, the function returns 0.\n- If the input number is greater than 0, the function returns 1.\n- If the input number is less than 0, the function returns -1.",
            "Create a Fortran function named \"sgn\" that takes a single input argument of type real(4) and returns a value of type real(4). This function determines the sign of the input number. If the input number is equal to zero, the function returns 0. If the input number is greater than zero, the function returns 1. If the input number is less than zero, the function returns -1. The function has no output parameters.",
            "Provide a Fortran function named sgn that returns the sign of a given floating-point number. The input parameter is a single real number, and the output is also a single real number. The function checks if the input number is equal to zero, greater than zero, or less than zero and assigns the corresponding value (0, 1, or -1) to the output parameter accordingly."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real :: x\n  \n  !case1: x = 0\n  x = 0.0\n  print *, sgn(x)\n\n  !case2: x = 5.6\n  x = 5.6\n  print *, sgn(x)\n\n  !case3: x = -3.2\n  x = -3.2\n  print *, sgn(x)\n\n  !case4: x = 1000.0\n  x = 1000.0\n  print *, sgn(x)\n\n  !case5: x = -100.5\n  x = -100.5\n  print *, sgn(x)\nend program main\n    ",
            "result": [
                "0.00000000",
                "1.00000000",
                "-1.00000000",
                "1.00000000",
                "-1.00000000"
            ]
        },
        "code": "    function sgn(x)\n        real(4)::sgn\n        real(4)::x\n        if (x==0) sgn = 0\n        if (x>0)  sgn = 1\n        if (x<0)  sgn = -1\n    end function\n"
    },
    {
        "instruction": [
            "Write a Fortran function code called get_len that calculates the length of a string and returns the result as an integer. The function takes a single input argument of type character, which represents the string. The output of the function is a single integer. The function first calculates the length of the input string using the len() function in Fortran. Then, it initializes an integer variable k to 0 and enters a do-while loop. Inside the loop, it checks if the character at position k+1 in the string is not equal to a space. If it is not a space, it increments k by 1. If it is a space, it assigns the value of k to the output variable get_len and exits the loop. Finally, the function returns the value of get_len as the result.",
            "Give me a Fortran function code named get_len to calculate the length of a given string. The function takes in one input argument of type character with variable length. The function returns an output argument of type integer representing the length of the string.",
            "Provide a Fortran function named get_len that calculates the length of a string and returns the result as an integer. The function takes one input argument of type character(len=*), which represents the string to be evaluated. The function has one output parameter of type integer, which holds the length of the string."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=100) :: string\n  \n  !case1\n  string = \"Hello World\"\n  print *, get_len(string)\n\n  !case2\n  string = \"This is a test\"\n  print *, get_len(string)\n\n  !case3\n  string = \"   \"\n  print *, get_len(string)\n\n  !case4\n  string = \"1234567890\"\n  print *, get_len(string)\n\n  !case5\n  string = \"Fortran is awesome\"\n  print *, get_len(string)\n  \nend program main",
            "result": [
                "5",
                "4",
                "0",
                "10",
                "7"
            ]
        },
        "code": "  function get_len(string)\n    character(len=*), intent(in):: string\n    integer:: get_len\n    integer::k\n    get_len = len(string)\n    k = 0\n    do while (k<get_len)\n      if (string(k+1:k+1)/=' ') then\n        k = k+1\n      else\n        get_len = k\n      end if\n    end do\n  end function\n"
    },
    {
        "instruction": [
            "Create a Fortran function named \"zeros\" that initializes a 2-dimensional integer array with zeros. The function takes two input arguments, x and y, both of integer type. The function returns a 2-dimensional integer array called \"result\" with dimensions x and y. The purpose of the function is to set all elements of the \"result\" array to zero using nested do-loops.",
            "Create a Fortran function named \"zeros\" to generate a matrix filled with zeros. The function takes two integer inputs, x and y, representing the dimensions of the matrix. The output is a two-dimensional integer array named \"result\" with dimensions x and y. Use a nested do-loop to iterate through each element of the matrix and set its value to zero.",
            "Write a Fortran function named zeros that creates a 2-dimensional array filled with zeros. The function takes two integer arguments, x and y, to determine the size of the array. The output of the function is a 2-dimensional integer array named result. The function sets all elements of the array to zero using nested do-loops. Implement this code as a function in Fortran."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: x, y\n  integer, allocatable :: result(:,:)\n  \n  !case1\n  x = 2\n  y = 3\n  allocate(result(x, y))\n  result = zeros(x, y)\n  print *, result\n  deallocate(result)\n\n  !case2\n  x = 4\n  y = 2\n  allocate(result(x, y))\n  result = zeros(x, y)\n  print *, result\n  deallocate(result)\n\n  !case3\n  x = 3\n  y = 3\n  allocate(result(x, y))\n  result = zeros(x, y)\n  print *, result\n  deallocate(result)\n\n  !case4\n  x = 1\n  y = 5\n  allocate(result(x, y))\n  result = zeros(x, y)\n  print *, result\n  deallocate(result)\n\n  !case5\n  x = 5\n  y = 1\n  allocate(result(x, y))\n  result = zeros(x, y)\n  print *, result\n  deallocate(result)\nend program main",
            "result": [
                "0           0           0           0           0           0",
                "0           0           0           0           0           0           0           0",
                "0           0           0           0           0           0           0           0           0",
                "0           0           0           0           0",
                "0           0           0           0           0"
            ]
        },
        "code": "  function zeros(x,y) result(result)\n    integer:: x,y\n    integer, dimension(x,y) :: result\n\n    do i_x=1,x\n       do i_y=1,y\n          result(i_x, i_y) = 0\n       end do\n    end do\n  end function\n"
    },
    {
        "instruction": [
            "Write a Fortran function named \"fact\" that calculates the factorial of a given integer. The function takes one input parameter of type integer and returns one output parameter of type integer.",
            "Write a Fortran function code named fact to compute the factorial of a given number. The function takes an integer input parameter named n. The output is an integer value representing the factorial of n.",
            "Provide a Fortran function named \"fact\" to calculate the factorial of a given integer number. The function takes one input argument of type integer (n) and returns one output argument of type integer (fact). The function uses a local variable (f) to store the factorial value and a loop to iterate from 1 to n, multiplying each number to calculate the factorial."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n\n\n  !case1\n  n = 0\n  print *, fact(n)\n\n  !case2\n  n = 5\n  print *, fact(n)\n\n  !case3\n  n = 10\n  print *, fact(n)\n\n  !case4\n  n = 3\n  print *, fact(n)\n\n  !case5\n  n = 7\n  print *, fact(n)\nend program main",
            "result": [
                "1",
                "120",
                "3628800",
                "6",
                "5040"
            ]
        },
        "code": "function fact(n)    !computing factorial\r\n    implicit none\r\n    integer::f,n,i    !local variables\r\n    integer::fact   !dummy variable\r\n    f=1\r\n    do i=1,n\r\n        f=f*i\r\n    end do\r\n    fact=f\r\nend function\r\n"
    },
    {
        "instruction": [
            "Provide a Fortran function named strmerge that merges two strings by padding the first and second arguments to the same length. The function takes three input arguments: str1 and str2 are character strings, and expr is a logical value. The function returns a character string, strout.",
            "Create a Fortran elemental function named strmerge that merges two input strings, str1 and str2, based on a logical expression. The function returns a new string, strout, which is the result of padding the first and second arguments to the same length. The function takes three input parameters: str1 and str2 are character strings of any length, and expr is a logical value. The function has one output parameter, strout, which is a character string of maximum length between str1 and str2.",
            "Create a Fortran function named strmerge that takes in two character strings (str1 and str2) and a logical expression (expr). The function merges the two input strings by padding the shorter string with spaces to match the length of the longer string. The function returns the merged string as the output. The number of input arguments is 3 and their types are [character(len=*), character(len=*), logical]. The number of output argument is 1 and its type is [character(len=max(len(str1), len(str2)))]."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=10) :: str1, str2, strout\n  \n  !case1\n  str1 = \"Hello\"\n  str2 = \"World\"\n  print *, strmerge(str1, str2, .true.)\n\n  !case2\n  str1 = \"Fortran\"\n  str2 = \"Expert\"\n  print *, strmerge(str1, str2, .false.)\n\n  !case3\n  str1 = \"12345\"\n  str2 = \"ABCDE\"\n  print *, strmerge(str1, str2, .true.)\n\n  !case4\n  str1 = \"Testing\"\n  str2 = \"Function\"\n  print *, strmerge(str1, str2, .false.)\n\n  !case5\n  str1 = \"Good\"\n  str2 = \"Bad\"\n  print *, strmerge(str1, str2, .true.)\n\nend program main",
            "result": [
                "Hello",
                "Expert",
                "12345",
                "Function",
                "Good"
            ]
        },
        "code": "elemental function strmerge(str1,str2,expr) result(strout)\n!$@(#) m_strings::strmerge(3f): pads first and second arguments to merge(3f) to same length\ncharacter(len=*),intent(in)              :: str1\ncharacter(len=*),intent(in)              :: str2\nlogical,intent(in)                       :: expr\ncharacter(len=max(len(str1), len(str2))) :: strout\n   if(expr)then\n      strout=str1\n   else\n      strout=str2\n   endif\nend function strmerge\n"
    },
    {
        "instruction": [
            "Please create a Fortran function named latlon_local_min that checks if a given section of elevation data has a local minimum. The function takes an array of real numbers, orog_section, as input with a dimension of 1 to 9. The function returns a single real number, is_minimum, which indicates whether the section has a local minimum or not. \n\nTo determine if there is a local minimum, the function compares the values in the orog_section array to the value at the center position (index 5). If any value in the array is smaller than the center value, is_minimum is set to 0.0. Otherwise, is_minimum remains 1.0.",
            "Write a Fortran function called \"latlon_local_min\" that determines if a given array of 9 floating-point numbers represents a local minimum in a 3x3 grid. The function takes one input parameter named \"orog_section\" of type real*8 and dimension 1:9, representing the 3x3 grid. The function returns a single output parameter named \"is_minimum\" of type real*8, indicating whether the center value of the grid is a local minimum. The function uses a do loop to compare each element of the grid with the center value and sets \"is_minimum\" to 1.0 if all elements are greater than or equal to the center value, otherwise it sets \"is_minimum\" to 0.0.",
            "Create a Fortran function named latlon_local_min that determines whether a given section of orography data has a local minimum value. The function accepts an input parameter orog_section, which is an array of 9 real numbers. The function returns an output parameter is_minimum, which is a single real number.\n\nTo determine if the orography section has a local minimum, the function iterates over each element of the array. If the element is the central value (index 5), it skips to the next iteration. Otherwise, it compares the value of the current element with the central value. If any element is found to be smaller than the central value, the is_minimum variable is set to 0.0 to indicate that the orography section does not have a local minimum. If all elements are greater than or equal to the central value, is_minimum remains 1.0, indicating the presence of a local minimum in the orography section."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real*8, dimension(1:9) :: orog_section\n  \n  !case1\n  orog_section = [1.0, 2.0, 3.0, 4.0, 5.0, 4.0, 3.0, 2.0, 1.0]\n  print *, latlon_local_min(orog_section)\n\n  !case2\n  orog_section = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 5.0, 4.0, 3.0]\n  print *, latlon_local_min(orog_section)\n\n  !case3\n  orog_section = [5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0]\n  print *, latlon_local_min(orog_section)\n\n  !case4\n  orog_section = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 5.0, 4.0, 1.0]\n  print *, latlon_local_min(orog_section)\n\n  !case5\n  orog_section = [1.0, 2.0, 1.0, 4.0, 5.0, 4.0, 3.0, 2.0, 1.0]\n  print *, latlon_local_min(orog_section)\n\nend program main",
            "result": [
                "0.0000000000000000",
                "0.0000000000000000",
                "1.0000000000000000",
                "0.0000000000000000",
                "0.0000000000000000"
            ]
        },
        "code": "function latlon_local_min(orog_section) result(is_minimum)\n\n\nreal*8, intent(in), dimension(1:9) :: orog_section\n\n!local variables\ninteger :: i\nreal*8 :: centre_value\nreal*8 :: is_minimum\n\n    is_minimum = 1.0\n    do i = 1,9\n        if (i == 5) cycle\n        centre_value = orog_section(5)\n        if (orog_section(i) < centre_value) is_minimum = 0.0\n    end do\n\nend function latlon_local_min\n"
    },
    {
        "instruction": [
            "Write a Fortran recursive function named \"fibonacci\" that calculates the Fibonacci number for a given input integer. The function takes one input parameter of integer type denoted by \"n\". The function returns the Fibonacci number as an integer denoted by \"fnum\".",
            "Provide a Fortran recursive function named fibonacci that calculates the Fibonacci number of a given input integer. The function takes one input argument of type integer and returns one output argument of type integer. The name of the function is \"fibonacci\".",
            "Create a recursive Fortran function named \"fibonacci\" that calculates the Fibonacci number for a given input \"n\". The function takes one input argument of type integer and returns one output argument of type integer. The function recursively calculates the Fibonacci number by summing the two previous Fibonacci numbers until it reaches the desired input value."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n\n  \n  !case1\n  n = 0\n  print *, fibonacci(n)\n  \n  !case2\n  n = 1\n  print *, fibonacci(n)\n  \n  !case3\n  n = 5\n  print *, fibonacci(n)\n  \n  !case4\n  n = 10\n  print *, fibonacci(n)\n  \n  !case5\n  n = 15\n  print *, fibonacci(n)\n  \nend program main",
            "result": [
                "0",
                "1",
                "5",
                "55",
                "610"
            ]
        },
        "code": "recursive function fibonacci (n) result (fnum)\n     integer, intent(in) :: n\n     integer :: fnum\n\n    !  handle exit conditions\n    if (n<2) then\n        fnum = n\n    \n    !  handle normal conditions\n    else\n        fnum = fibonacci(n-1) + fibonacci(n-2)\n\n    endif\nend function fibonacci\n"
    },
    {
        "instruction": [
            "Write a Fortran function named fjson_convert_bool_to_value that converts a boolean variable into a JSON string representation. The function takes an input argument of type logical and returns a string. \n\nTo use the function, provide a boolean variable as the input argument. The function will check if the boolean variable is true or false, and assign the corresponding JSON string value of \"true\" or \"false\" to the val_string variable. Finally, the function trims any leading or trailing spaces from the val_string and returns the result.\n\nMake sure to allocate enough memory for the val_string and bool_string variables before calling the function.",
            "Provide a Fortran function named fjson_convert_bool_to_value that converts a logical variable into a JSON string representation. The function takes one input argument of type logical and returns one output argument of type character. \n\nTo use this function, pass a logical variable to it and it will return a JSON string representation of that variable. The JSON string will be either \"true\" if the logical variable is .true., or \"false\" if the logical variable is .false.\n\nHere is an example usage of the function:\nval_string = fjson_convert_bool_to_value(var)\n\nNote: Make sure to allocate enough space for the output character variable val_string before calling the function.",
            "Write a Fortran function called fjson_convert_bool_to_value that converts a logical variable to a JSON string representation. The function takes one input argument of type logical and returns one output argument of type character(len=:), which is an allocatable string.\n\nTo use the function, pass a logical variable as the input argument. The function will convert the logical value to a corresponding JSON string value, \"true\" if the logical variable is true or \"false\" if the logical variable is false. The resulting JSON string value will be assigned to the output argument, which should be allocated and trimmed before calling the function.\n\nTo convert a logical variable to a JSON string value, call the fjson_convert_bool_to_value function and pass the logical variable as the input argument. The resulting JSON string value will be returned and can be used accordingly."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  logical :: var\n\n  !case1\n  var = .true.\n  print *, fjson_convert_bool_to_value(var)\n\n  !case2\n  var = .false.\n  print *, fjson_convert_bool_to_value(var)\n\n  !case3\n  var = .true. .or. .false.\n  print *, fjson_convert_bool_to_value(var)\n\n  !case4\n  var = .not. .true.\n  print *, fjson_convert_bool_to_value(var)\n\n  !case5\n  var = .not. .false.\n  print *, fjson_convert_bool_to_value(var)\nend program main\n",
            "result": [
                "true",
                "false",
                "true",
                "false",
                "true"
            ]
        },
        "code": "   function fjson_convert_bool_to_value(var) result(val_string)\n\n      implicit none\n\n      !> variable to be converted\n      logical, intent(in) :: var\n\n      !> json string\n      character(len=:), allocatable :: val_string\n\n      character(len=:), allocatable :: bool_string\n\n      character(len=*), parameter :: caller = \"fjson_convert_bool_to_value\"\n\n      if (var) then\n         bool_string = \"true\"\n      else\n         bool_string = \"false\"\n      end if\n      val_string = trim(adjustl(bool_string))\n\n   end function\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named rand_uniform that generates a random number between two given values. The function takes two double precision input arguments, a and b, representing the range of the random number. The function returns a single double precision output argument, c, which is the generated random number. The random number is generated using the random_number subroutine provided by Fortran.",
            "Provide a Fortran function called rand_uniform that generates a random number within a given range. The function takes in two input arguments, both of type double precision, representing the lower and upper bounds of the range. The function returns a single output argument, also of type double precision, representing the randomly generated number.",
            "Give me a Fortran function code named rand_uniform to generate a random number within a given range. The function takes two double precision input arguments, a and b, representing the lower and upper bounds of the range respectively. The function returns a single double precision output argument, c, which represents the randomly generated number within the specified range."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  double precision :: a, b, c\n  \n  ! Case 1: Random number between 0 and 1\n  a = 0.0\n  b = 1.0\n  c = rand_uniform(a, b)\n  print *, c\n\n  ! Case 2: Random number between -5 and 5\n  a = -5.0\n  b = 5.0\n  c = rand_uniform(a, b)\n  print *, c\n\n  ! Case 3: Random number between -100 and 100\n  a = -100.0\n  b = 100.0\n  c = rand_uniform(a, b)\n  print *, c\n\n  ! Case 4: Random number between 10 and 20\n  a = 10.0\n  b = 20.0\n  c = rand_uniform(a, b)\n  print *, c\n\n  ! Case 5: Random number between -1000 and 1000\n  a = -1000.0\n  b = 1000.0\n  c = rand_uniform(a, b)\n  print *, c\n\nend program main",
            "result": [
                "0.99755959009261719",
                "0.66824707611273304",
                "93.183075099224993",
                "17.479276854714321",
                "-265.21820525048861"
            ]
        },
        "code": "      function rand_uniform(a,b) result(c)\n       double precision :: a,b,c,temp\n       call random_number(temp)\n       c= a+temp*(b-a)\n      end function\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named rand_exponential to generate random numbers from an exponential distribution with a specified mean. The function takes one input parameter of type double precision named mean. The function returns one output parameter of type double precision named c. \n\nTo use the function, ensure that the mean value is positive. If the mean is not positive, display an error message. If the mean is positive, generate a random number between 0 and 1 using the random_number subroutine. Multiply the negative logarithm of this random number with the mean to calculate the result, and assign it to the variable c.",
            "Create a Fortran function named rand_exponential that generates a random number from an exponential distribution. The input parameter, mean, is a double precision floating-point number. The function calculates the exponential random number using the formula -mean * log(temp), where temp is a random number between 0 and 1 generated by the random_number function. The output parameter, c, is also a double precision floating-point number. If the mean value is not positive, the function outputs an error message.",
            "Create a Fortran function named rand_exponential that calculates a random number from an exponential distribution with a specified mean. The function takes one input parameter, mean, which is a double precision floating-point number. The function returns one output parameter, c, also a double precision floating-point number. If the mean is less than or equal to zero, the function will display a message stating that the mean must be positive. Otherwise, the function generates a random number using the random_number subroutine and computes c as the negative mean multiplied by the natural logarithm of the random number."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  double precision :: mean, c\n  \n  !case1\n  mean = 1.0d0\n  c = rand_exponential(mean)\n  print *, c\n  \n  !case2\n  mean = 2.5d0\n  c = rand_exponential(mean)\n  print *, c\n  \n  !case3\n  mean = 0.5d0\n  c = rand_exponential(mean)\n  print *, c\n  \n  !case4\n  mean = 10.0d0\n  c = rand_exponential(mean)\n  print *, c\n  \n  !case5\n  mean = 3.7d0\n  c = rand_exponential(mean)\n  print *, c\nend program main",
            "result": [
                "2.4433925612276476E-003",
                "1.4192629517638475",
                "1.7339525806534174E-002",
                "2.9044898285842899",
                "3.7049168645027186"
            ]
        },
        "code": "      function rand_exponential(mean) result(c)\n      double precision :: mean,c,temp\n      if (mean <= 0.0d0) then\n\n        write(*,*) \"mean must be positive\"\n      else\n       call random_number(temp)\n       c=-mean*log(temp)\n      end if\n      end function\n"
    },
    {
        "instruction": [
            "Please provide a Fortran function code named csv_record that takes multiple inputs and returns a character record. The function requires the following inputs:\n- state: a character string representing the state\n- party: a character representing the political party\n- fields: a real array of size nostats representing statistical fields\n- nostats: an integer representing the number of statistical fields\n\nThe function will return a character record containing the input values, separated by commas.",
            "Provide a Fortran function named csv_record that takes in the state name, party name, an array of floating numbers, and the number of statistics as input arguments. The function generates a comma-separated record that combines the state name, party name, and the formatted values of the floating numbers. The number of input arguments is 4, with the data types being [character, character, real array, integer]. The number of output arguments is 1, with the data type being [character].",
            "Give me a Fortran function code named csv_record that takes in various input parameters and returns a string record. The function has 4 input parameters named state, party, fields, and nostats, with types character, character, real array, and integer respectively. The function also has 1 output parameter named record, which is a character string. \n\nThe function's main purpose is to create a CSV (Comma Separated Values) record by concatenating the input parameters together with comma separators. The state and party values are first appended to the record. Then, each element in the fields array is converted to a string and added to the record. The resulting record is returned as the output of the function."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=2) :: state\n  character :: party\n  integer :: nostats\n  real, allocatable :: fields(:)\n  \n  !case1\n  state = \"NY\"\n  party = \"D\"\n  nostats = 3\n  allocate(fields(nostats))\n  fields = [1.234, -0.567, 2.345]\n  print *, csv_record(state, party, fields, nostats)\n  deallocate(fields)\n\n  !case2\n  state = \"CA\"\n  party = \"R\"\n  nostats = 4\n  allocate(fields(nostats))\n  fields = [-1.0, 2.0, -3.0, 4.0]\n  print *, csv_record(state, party, fields, nostats)\n  deallocate(fields)\n\n  !case3\n  state = \"TX\"\n  party = \"I\"\n  nostats = 5\n  allocate(fields(nostats))\n  fields = [100.0, 200.0, 300.0, 400.0, 500.0]\n  print *, csv_record(state, party, fields, nostats)\n  deallocate(fields)\n\n  !case4\n  state = \"FL\"\n  party = \"D\"\n  nostats = 3\n  allocate(fields(nostats))\n  fields = [0.0, 0.0, 0.0]\n  print *, csv_record(state, party, fields, nostats)\n  deallocate(fields)\n\n  !case5\n  state = \"OH\"\n  party = \"R\"\n  nostats = 5\n  allocate(fields(nostats))\n  fields = [2.3132, -1.32, 2.5354, 0.3192, -1.23912]\n  print *, csv_record(state, party, fields, nostats)\n  deallocate(fields)\nend program main",
            "result": [
                "NY,D,1.23399997,-0.566999972,2.34500003",
                "CA,R,-1.00000000,2.00000000,-3.00000000,4.00000000",
                "TX,I,100.000000,200.000000,300.000000,400.000000,500.000000",
                "FL,D,0.00000000,0.00000000,0.00000000",
                "OH,R,2.31320000,-1.32000005,2.53539991,0.319200009,-1.23912001"
            ]
        },
        "code": "function csv_record(state, party, fields, nostats) result(record)\n   implicit none\n   ! dummy arguments\n   character (len=*), intent(in) :: state\n   character, intent(in) :: party\n   real, intent(in), dimension(nostats) :: fields\n   integer, intent(in) :: nostats\n\n   character (len=256) :: record\n   ! local data\n   integer :: i\n   character (len=25) :: str\n   ! processing\n   record=trim(state)//','//trim(party)\n   do i = 1, nostats\n      write (str,*) fields(i)\n      record=trim(record)//','//trim(adjustl(str))\n   end do\nend function csv_record\n"
    },
    {
        "instruction": [
            "Create a Fortran function named fibonacci that calculates the Fibonacci sequence up to a given number. The function takes an integer input argument \"n\" and returns an integer result \"item\". The input argument \"n\" represents the number of terms in the Fibonacci sequence to generate. The output result \"item\" represents the corresponding term in the Fibonacci sequence. The function utilizes recursion to calculate the Fibonacci sequence by summing the previous two terms.",
            "Write a recursive Fortran function named fibonacci that calculates the Fibonacci number at a given position. The function takes one input argument of type integer and returns one output argument, also of type integer. The input argument represents the position of the Fibonacci number to be computed. The function uses a select case statement to handle three different cases: when the input is 0 or 1, the function returns the input value itself; otherwise, it recursively calls itself for the previous two positions and adds the results to compute the Fibonacci number.",
            "Write a recursive Fortran function named \"fibonacci\" that calculates the Fibonacci number for a given input. The function takes one integer input argument named \"n\" and returns an integer result named \"item\". The function uses the select case construct to calculate the Fibonacci number based on the value of \"n\". If \"n\" is 0 or 1, the function returns the value of \"n\" itself. Otherwise, it recursively calls itself with \"n-1\" and \"n-2\" as input arguments and adds the results to compute the Fibonacci number."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n\n  \n  !case1\n  n=0\n  print *, fibonacci(n)\n\n  !case2\n  n=1\n  print *, fibonacci(n)\n\n  !case3\n  n=5\n  print *, fibonacci(n)\n\n  !case4\n  n=10\n  print *, fibonacci(n)\n\n  !case5\n  n=15\n  print *, fibonacci(n)\nend program main",
            "result": [
                "0",
                "1",
                "5",
                "55",
                "610"
            ]
        },
        "code": "recursive function fibonacci(n) result(item)\n    integer(kind=4) :: item\n    integer(kind=4), intent(in) :: n\n    select case (n)\n        case (0:1)\n            item = n\n        case default\n            item = fibonacci(n-1) + fibonacci(n-2)\n    end select\nend function\n"
    },
    {
        "instruction": [
            "Create a Fortran function code named listcontains that checks if a given integer is present in a given integer array. The function takes two input arguments: an integer array called \"list\" and an integer called \"x\". The function returns a logical value indicating whether \"x\" is present in \"list\". The function uses a do loop to iterate over the elements of \"list\" and compares each element with \"x\". If a match is found, the function sets the logical variable \"r\" to true and exits the loop. If no match is found, \"r\" is set to false.",
            "Create a Fortran function called \"listcontains\" to check if a given number is present in a list of integers. The function takes two input parameters: a one-dimensional integer array \"list\" and an integer value \"x\". The function returns a logical value indicating whether \"x\" is present in the \"list\".",
            "Provide a Fortran function code named \"listcontains\" to check if an integer value exists in an integer array. The function takes two input parameters, \"list\" which is an integer array and \"x\" which is the integer value to search for. The function returns a logical value indicating whether the value exists in the array."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer, allocatable :: list(:)\n  integer :: x\n  \n  !case1\n  allocate(list(5))\n  list = [1, 2, 3, 4, 5]\n  x = 3\n  print *, listcontains(list, x)\n  deallocate(list)\n  \n  !case2\n  allocate(list(3))\n  list = [11, 22, 33]\n  x = 44\n  print *, listcontains(list, x)\n  deallocate(list)\n  \n  !case3\n  allocate(list(4))\n  list = [0, 0, 0, 0]\n  x = 0\n  print *, listcontains(list, x)\n  deallocate(list)\n  \n  !case4\n  allocate(list(2))\n  list = [5, 10]\n  x = 10\n  print *, listcontains(list, x)\n  deallocate(list)\n  \n  !case5\n  allocate(list(6))\n  list = [7, 7, 7, 7, 7, 7]\n  x = 7\n  print *, listcontains(list, x)\n  deallocate(list)\n  \nend program main",
            "result": [
                "T",
                "F",
                "T",
                "T",
                "T"
            ]
        },
        "code": "        function listcontains(list, x) result(r)\n            integer, dimension(1:), intent(in) :: list\n            integer, intent(in) :: x\n            logical :: r\n            integer :: i\n        \n            do i=1,size(list)\n                if (list(i) == x) then\n                    r = .true.\n                    return\n                end if\n            end do\n        \n            r = .false.\n    \n        end function listcontains    \n"
    },
    {
        "instruction": [
            "Write a Fortran function called round that rounds a given number to a specified precision. The function takes two input arguments: a real number x and an optional precision value. The precision value, if provided, specifies the number of decimal places to round to. The function returns the rounded value as a real number. If the precision value is not provided, the default precision is set to 100.0.",
            "Create a Fortran function named \"round\" that rounds a given number to a specified precision. The function takes two input arguments: a real number \"x\" to be rounded, and an optional precision value of type real. The function returns a rounded value of type real. If the precision argument is not provided, the function uses a default precision value of 100.0. To round the number, multiply it by the precision value, convert it to an integer, and then divide by the precision value. Return the rounded value.",
            "Provide a Fortran function code named \"round\" that rounds a given floating-point number to a specified precision. The function takes two input arguments: a real number \"x\" and an optional real number \"precision\". If the \"precision\" argument is not provided, a default precision of 100.0 is used. The function returns a real number \"round\", which is the rounded value of \"x\" at the specified precision."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real :: x, precision\n  \n  !case1\n  x = 3.14159\n  print *, round(x)\n  \n  !case2\n  x = 2.71828\n  precision = 10.0\n  print *, round(x, precision)\n  \n  !case3\n  x = 0.123456789\n  precision = 1000.0\n  print *, round(x, precision)\n  \n  !case4\n  x = -5.6789\n  print *, round(x)\n  \n  !case5\n  x = 10.987654321\n  precision = 0.001\n  print *, round(x, precision)\nend program main",
            "result": [
                "3.14000010",
                "2.70000005",
                "0.123000003",
                "-5.67000008",
                "0.00000000"
            ]
        },
        "code": "    function round(x, precision)\n\t\treal :: x, defualt_precision, round\n\t\treal, optional :: precision\n\t\t\n\t\tif (.not. present(precision)) then\n\t\t\tdefualt_precision = 100.0\n\t\telse\n\t\t\tdefualt_precision = precision \n\t\tend if\n\t\tround = int(x * defualt_precision) / defualt_precision\n\t\treturn\n\tend function round\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named elementformat which takes a lower case or upper case letter as input and returns the corresponding letter in upper case or lower case. The function has one input parameter of type character and one output parameter of type character. The function uses the len_trim function to determine the length of the input string and the index function to find the position of the character in the specified character set. The function loops through each character in the input string and updates it to the corresponding case in the output string.",
            "Give me a Fortran function code named elementformat that takes a single input argument of type character and returns a string in which the case of each letter is reversed. The number of input arguments is 1 and the data type is [character]. The number of output arguments is 1 and the data type is [character].",
            "Give me a Fortran function code named elementformat that converts the case of the given string. The function takes one input argument of type character and returns one output argument of the same type. The function converts the lowercase characters in the input string to uppercase and vice versa. The function utilizes the features of Fortran function and utilizes the character manipulation capabilities of the language."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=1) :: lower_upper\n  character(len=1) :: upper_lower\n  \n  !case1\n  lower_upper = 'a'\n  print *, elementformat(lower_upper)\n  \n  !case2\n  lower_upper = 'Z'\n  print *, elementformat(lower_upper)\n  \n  !case3\n  lower_upper = 'b'\n  print *, elementformat(lower_upper)\n  \n  !case4\n  lower_upper = 'X'\n  print *, elementformat(lower_upper)\n  \n  !case5\n  lower_upper = 'g'\n  print *, elementformat(lower_upper)\nend program main",
            "result": [
                "a",
                "Z",
                "b",
                "X",
                "g"
            ]
        },
        "code": "  function elementformat(lower_upper) result(upper_lower)\n    character(*), intent(in)             :: lower_upper\n    character(len=len_trim(lower_upper)) :: upper_lower\n    character(len=*), parameter          :: lc = 'abcdefghijklmnopqrstuvwxyz', &\n                                            uc = 'abcdefghijklmnopqrstuvwxyz'\n    integer                              :: i,j\n\n    upper_lower = lower_upper\n    j = index(lc,lower_upper(1:1))\n    if (j>0) upper_lower(1:1) = uc(j:j)\n    do i = 2, len_trim(lower_upper)\n       j = index(uc,lower_upper(i:i))\n       if (j>0) upper_lower(i:i) = lc(j:j)\n    enddo\n\n  end function elementformat\n"
    },
    {
        "instruction": [
            "Provide a Fortran function named optval_char that takes in two input parameters: opt of type character and default of type character. The function returns a character value. The purpose of this function is to assign a value to the output parameter val based on the input parameters. If the opt parameter is provided, the value of opt is assigned to val. Otherwise, the value of default is assigned to val.",
            "Create a Fortran function named optval_char that takes two input arguments, opt (optional character) and default (character). The function returns a character value. The function checks if the opt argument is provided, and if so, assigns its value to the val variable. If opt is not provided, the function assigns the value of the default argument to val.",
            "Write a Fortran function named optval_char that takes two input arguments: opt (optional character array) and default (character array). The number of input arguments is 2 and the data type of the input arguments is [character array, character array]. The function returns a character array. The number of output arguments is 1 and the data type of the output argument is [character array]. \n\nThe function optval_char is used to get the value of opt if it is provided, otherwise it returns the default value. The value of opt is stored in the dynamically allocated character array val."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=:), allocatable :: opt, default, val\n  \n  !case1\n  opt = \"Hello\"\n  default = \"World\"\n  val = optval_char(opt, default)\n  print *, val\n\n  !case2\n  opt = \"Fortran\"\n  default = \"Programming\"\n  val = optval_char(opt, default)\n  print *, val\n\n  !case3\n  opt = \"Test\"\n  default = \"Case\"\n  val = optval_char(opt, default)\n  print *, val\n\n  !case4\n  opt = \"\"\n  default = \"Default\"\n  val = optval_char(opt, default)\n  print *, val\n\n  !case5\n  opt = \"1\"\n  default = \"2\"\n  val = optval_char(opt, default)\n  print *, val\n\nend program main",
            "result": [
                "Hello",
                "Fortran",
                "Test",
                "Default",
                "1"
            ]
        },
        "code": "    function optval_char(opt, default) result(val)\n        character(len=*), intent(in), optional :: opt\n        character(len=*), intent(in) :: default\n        character(len=:), allocatable :: val\n\n        if (present(opt)) then\n            val = opt\n        else\n            val = default\n        end if\n\n    end function optval_char\n"
    },
    {
        "instruction": [
            "Write a Fortran function named \"sanitize\" that takes in a double precision number as input and returns a new double precision number as output. The function checks if the absolute value of the input number is less than 1.0E-99. If it is, the function sets the output number to 0.0. Otherwise, the function sets the output number to be the same as the input number. The function has 1 input argument of type double precision and 1 output argument of type double precision.",
            "Provide a Fortran function code named sanitize that takes in a double precision input argument and returns a double precision output argument. The purpose of this function is to sanitize the input value by ensuring that if its absolute value is less than 1.0e-99, it is replaced with 0.0. \n\nTo use the function, you need to provide a double precision input value to be sanitized. The function will then return the sanitized value as the output.",
            "Provide a Fortran function code named \"sanitize\" that takes a double precision floating-point number as input and returns a sanitized version of the number. The function has 1 input parameter of type double precision and 1 output parameter of type double precision. The function checks if the absolute value of the input number is less than 1.0e-99. If it is, the function sets the output value to 0.0, otherwise it returns the input value as it is."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  double precision :: val, new_val\n  \n  !case1: val is very small\n  val = 1.0d-100\n  new_val = sanitize(val)\n  print *, new_val\n  \n  !case2: val is positive and not small\n  val = 10.0d0\n  new_val = sanitize(val)\n  print *, new_val\n  \n  !case3: val is negative and not small\n  val = -5.0d0\n  new_val = sanitize(val)\n  print *, new_val\n  \n  !case4: val is 0.0\n  val = 0.0d0\n  new_val = sanitize(val)\n  print *, new_val\n  \n  !case5: val is a large positive number\n  val = 1.0d100\n  new_val = sanitize(val)\n  print *, new_val\n  \nend program main",
            "result": [
                "0.0000000000000000",
                "10.000000000000000",
                "-5.0000000000000000",
                "0.0000000000000000",
                "1.0000000000000000E+100"
            ]
        },
        "code": "  function sanitize(val) result (new_val)\n\n    implicit none\n\n    double precision, intent(in) :: val\n    double precision :: new_val\n\n    if (abs(val) < 1.d-99) then\n       new_val = 0.0d0\n    else\n       new_val = val\n    endif\n\n  end function sanitize\n"
    },
    {
        "instruction": [
            "Create a Fortran function named count_lines to count the number of lines in a file, excluding lines starting with a '#' symbol. The function takes a single input parameter of type character(len=*) named fname, which represents the name of the file to be counted. The function returns an integer result named count_lines, which represents the total number of lines in the file.",
            "Provide a Fortran function named count_lines, which counts the number of lines in a text file, excluding lines that start with a '#' symbol. The function takes a single input parameter of type character, which represents the file name. The function returns an integer value, which is the count of lines in the file.",
            "Provide a Fortran function named count_lines that counts the number of lines in a file, excluding lines that start with the \"#\" character. The function takes one input parameter, fname, which is a character string representing the name of the file. The function returns an integer value representing the count of lines in the file."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=100) :: fname\n  \n  !case1\n  fname = \"test1.txt\"\n  open(90, file=fname, status='replace')\n  write(90,*) \"This is line 1\"\n  write(90,*) \"This is line 2\"\n  write(90,*) \"# This is line 3\"\n  write(90,*) \"This is line 4\"\n  write(90,*) \"This is line 5\"\n  close(90)\n  print *, count_lines(fname)\n\n  !case2\n  fname = \"test2.txt\"\n  open(90, file=fname, status='replace')\n  write(90,*) \"# This is line 1\"\n  write(90,*) \"# This is line 2\"\n  write(90,*) \"# This is line 3\"\n  write(90,*) \"# This is line 4\"\n  write(90,*) \"# This is line 5\"\n  close(90)\n  print *, count_lines(fname)\n\n  !case3\n  fname = \"test3.txt\"\n  open(90, file=fname, status='replace')\n  write(90,*) \"This is line 1\"\n  write(90,*) \"This is line 2\"\n  write(90,*) \"This is line 3\"\n  write(90,*) \"This is line 4\"\n  write(90,*) \"This is line 5\"\n  close(90)\n  print *, count_lines(fname)\n\n  !case4\n  fname = \"test4.txt\"\n  open(90, file=fname, status='replace')\n  close(90)\n  print *, count_lines(fname)\n\n  !case5\n  fname = \"test5.txt\"\n  open(90, file=fname, status='replace')\n  write(90,*) \"# This is line 1\"\n  write(90,*) \"This is line 2\"\n  write(90,*) \"# This is line 3\"\n  write(90,*) \"This is line 4\"\n  write(90,*) \"# This is line 5\"\n  close(90)\n  print *, count_lines(fname)\n  \nend program main",
            "result": [
                "4",
                "0",
                "5",
                "0",
                "2"
            ]
        },
        "code": "function count_lines(fname)\n    character(len=*) :: fname\n    integer :: count_lines\n\t\n    character(100) :: tmp\n    \n    count_lines = 0 \n    open (90, file = fname) \n    do \n        read (90,*, end=10) tmp\n        if (.not.(tmp(1:1) == '#')) then \n            count_lines = count_lines + 1 \n        end if\n    end do \n    10 close (90)\n\t\nend function count_lines\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named select that takes a logical selector, two integer arguments (iftrue and iffalse), and returns an integer result. The function selects the value of iftrue if the selector is true, and iffalse if the selector is false. The number of input arguments is 3 and the test_data type is [logical, integer, integer]. The number of output arguments is 1 and the test_data type is [integer].",
            "Create a Fortran function named select that takes three input arguments: a logical selector, an integer iftrue, and an integer iffalse. The function returns an integer. The purpose of this function is to select and return either the value of iftrue or iffalse based on the value of the selector. If the selector is true, the function returns the value of iftrue. Otherwise, it returns the value of iffalse.",
            "Provide a Fortran function named \"select\" that takes in a logical input argument \"selector\" and two integer input arguments \"iftrue\" and \"iffalse\". The function returns an integer output. \n\nThe purpose of this function is to select and return either the value of \"iftrue\" or \"iffalse\" based on the value of the logical \"selector\" input. If the \"selector\" is true, the function returns the value of \"iftrue\". Otherwise, it returns the value of \"iffalse\". \n\nEnsure that the function is declared as \"pure\" and the input arguments are declared as intent(in) to ensure that they cannot be modified within the function."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  logical :: selector\n  integer :: iftrue, iffalse, result\n\n  !case1\n  selector = .true.\n  iftrue = 10\n  iffalse = 20\n  result = select(selector, iftrue, iffalse)\n  print *, result\n\n  !case2\n  selector = .false.\n  iftrue = 30\n  iffalse = 40\n  result = select(selector, iftrue, iffalse)\n  print *, result\n\n  !case3\n  selector = .true.\n  iftrue = -5\n  iffalse = -10\n  result = select(selector, iftrue, iffalse)\n  print *, result\n\n  !case4\n  selector = .false.\n  iftrue = 5\n  iffalse = 0\n  result = select(selector, iftrue, iffalse)\n  print *, result\n\n  !case5\n  selector = .false.\n  iftrue = 100\n  iffalse = 200\n  result = select(selector, iftrue, iffalse)\n  print *, result\n\nend program main",
            "result": [
                "10",
                "40",
                "-5",
                "0",
                "200"
            ]
        },
        "code": "pure function select (selector, iftrue, iffalse)\n  logical, intent (in) :: selector\n  integer, intent (in) :: iftrue, iffalse\n  integer :: select\n\n  if (selector) then\n    select = iftrue\n  else\n    select = iffalse\n  end if\nend function select\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named create_block_matrix to create a block matrix of size matrix_size x matrix_size, where each block has a size of block_size x block_size. The number of input arguments is 2 and the data type is integer. The number of output arguments is 1 and the data type is integer, dimension(:, :), allocatable.\n\nAllocate memory for the block matrix using the matrix_size. If the allocation fails, display an error message and stop the program. Set all elements of the block matrix to zero.\n\nUsing a forall loop, assign a value of 1 to the elements of the block matrix based on the block structure defined by the block_size. The loop iterates over the rows and columns of the block matrix, ensuring that the indices are within the bounds of the matrix. \n\nThe purpose of this function is to create a block matrix with specified dimensions and a block structure.",
            "Provide a Fortran function named create_block_matrix that creates a block matrix of size matrix_size filled with ones in the block of size block_size. The function has two input parameters, matrix_size (an integer value) and block_size (an integer value). The function returns a two-dimensional integer array b as the output.",
            "Create a Fortran function called create_block_matrix that generates a block matrix with a specified size. The function takes two input arguments of type integer: matrix_size and block_size. The function returns an output argument of type integer, which is the generated block matrix. \n\nTo create the block matrix, the function allocates memory for the matrix using the matrix_size argument. If the allocation is successful, the matrix is initialized with zeros. Then, using a forall loop, the function sets the elements of the matrix to 1 according to the block structure, where each block has dimensions block_size by block_size. The loop iterates over i, j, and k, ensuring that the block indices are within the bounds of the matrix.\n\nMake sure to use the \"use, intrinsic\" statement to access the iso_fortran_env module, which provides the error_unit constant for error handling.\n\nPlease note that the code also includes error handling, where if the memory allocation fails, an error message is written to the error_unit and the program is stopped with a specific error code."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: matrix_size, block_size\n  integer, allocatable :: b(:,:)\n\n  !case1\n  matrix_size = 4\n  block_size = 2\n  allocate(b(matrix_size, matrix_size))\n  b = create_block_matrix(matrix_size, block_size)\n  print *, b\n  deallocate(b)\n\n  !case2\n  matrix_size = 6\n  block_size = 3\n  allocate(b(matrix_size, matrix_size))\n  b = create_block_matrix(matrix_size, block_size)\n  print *, b\n  deallocate(b)\n\n  !case3\n  matrix_size = 5\n  block_size = 2\n  allocate(b(matrix_size, matrix_size))\n  b = create_block_matrix(matrix_size, block_size)\n  print *, b\n  deallocate(b)\n\n  !case4\n  matrix_size = 3\n  block_size = 1\n  allocate(b(matrix_size, matrix_size))\n  b = create_block_matrix(matrix_size, block_size)\n  print *, b\n  deallocate(b)\n\n  !case5\n  matrix_size = 8\n  block_size = 4\n  allocate(b(matrix_size, matrix_size))\n  b = create_block_matrix(matrix_size, block_size)\n  print *, b\n  deallocate(b)\nend program main",
            "result": [
                "1           1           0           0           1           1           0           0           0           0           1           1           0           0           1           1",
                "1           1           1           0           0           0           1           1           1           0           0           0           1           1           1           0           0           0           0           0           0           1           1           1           0           0           0           1           1           1           0           0           0           1           1           1",
                "1           1           0           0           0           1           1           0           0           0           0           0           1           1           0           0           0           1           1           0           0           0           0           0           1",
                "1           0           0           0           1           0           0           0           1",
                "1           1           1           1           0           0           0           0           1           1           1           1           0           0           0           0           1           1           1           1           0           0           0           0           1           1           1           1           0           0           0           0           0           0           0           0           1           1           1           1           0           0           0           0           1           1           1           1           0           0           0           0           1           1           1           1           0           0           0           0           1           1           1           1"
            ]
        },
        "code": "    function create_block_matrix(matrix_size, block_size) result(b)\n        use, intrinsic :: iso_fortran_env, only : error_unit\n        implicit none\n        integer, value :: matrix_size, block_size\n        integer, dimension(:, :), allocatable :: b\n        integer :: i, j, k, status\n\n        allocate (b(matrix_size, matrix_size), stat=status)\n        if (status /= 0) then\n            write (unit=error_unit, fmt='(2a)') &\n                'error: can not allocate matrix'\n            stop 2\n        end if\n        b = 0\n        forall (i = 1:size(b, 1):block_size, &\n                j = 0:block_size - 1, &\n                k = 0:block_size - 1, &\n                i + j <= size(b, 1) .and. i + k <= size(b, 2))\n            b(i + j, i + k) = 1\n        end forall\n    end function create_block_matrix\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named utrue that computes the true solution for comparison. The function takes two input arguments, both of type real(kind=8), and returns one output argument of type real(kind=8).",
            "Write a Fortran function named utrue that calculates the true solution for comparison, if it is known. The function takes two input arguments of type real(kind=8) and returns a single output argument of the same type. The input arguments are named x and y, and the output argument is named utrue. The function computes the value of utrue as the square of x minus the square of y. Make sure to declare the correct data types for the input and output parameters in the function.",
            "Write a Fortran function code named utrue that computes the true solution for a given pair of floating point numbers. The function takes two input arguments of type real and returns a single output argument of type real. The function calculates the value of the true solution by subtracting the square of the second input argument from the square of the first input argument."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real(kind=8) :: x, y\n\n  !case1\n  x = 2.0\n  y = 1.0\n  print *, utrue(x, y)\n\n  !case2\n  x = -3.5\n  y = 2.8\n  print *, utrue(x, y)\n\n  !case3\n  x = 0.0\n  y = 0.0\n  print *, utrue(x, y)\n\n  !case4\n  x = 10.0\n  y = -5.0\n  print *, utrue(x, y)\n\n  !case5\n  x = 3.14\n  y = 1.57\n  print *, utrue(x, y)\n\nend program main",
            "result": [
                "3.0000000000000000",
                "4.4100002670288063",
                "0.0000000000000000",
                "75.000000000000000",
                "7.3947004940986716"
            ]
        },
        "code": "function utrue(x, y)\n\n    ! true solution for comparison, if known.\n\n    implicit none\n    real(kind=8), intent(in) :: x,y\n    real(kind=8) :: utrue\n\n    utrue = x**2 - y**2\n\nend function utrue\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named fak to calculate the factorial of an integer number. The function takes in one input argument of type integer and returns one output argument of type integer. The name of the function is fak and it expects an integer value as input. The function calculates the factorial by iteratively multiplying the numbers from 1 to the given input value. The computed factorial value is then returned as the output of the function.",
            "Create a Fortran function called \"fak\" that calculates the factorial of an input integer. The function takes in one input argument of type integer and returns one output argument of type integer. The input argument is specified using the \"intent(in)\" keyword. The name of the output argument is \"fakultaet\". The function uses a do loop to multiply the numbers from 1 to the input integer to calculate the factorial.",
            "Write a Fortran function named \"fak\" that calculates the factorial of a given integer. The function takes 1 input argument of type integer and returns 1 output argument of type integer. The name of the output argument is \"fakultaet\"."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: k\n\n  !case1\n  k = 5\n  print *, fak(k)\n\n  !case2\n  k = 0\n  print *, fak(k)\n\n  !case3\n  k = 10\n  print *, fak(k)\n\n  !case4\n  k = 3\n  print *, fak(k)\n\n  !case5\n  k = 7\n  print *, fak(k)\nend program main",
            "result": [
                "120",
                "1",
                "3628800",
                "6",
                "5040"
            ]
        },
        "code": "function fak(k) result(fakultaet)\n    implicit none\n    integer, intent(in) :: k\n    integer :: fakultaet\n    integer :: m\n    fakultaet = 1\n    do m=1,k\n        fakultaet = fakultaet*m\n    end do\nend function\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named mhd_grid_gauss_point that returns the value of a specific Gauss point based on the number of points and the index provided as input. The number of input arguments is 2 and the data types are [integer, integer]. The number of output arguments is 1 and the data type is [real].",
            "Provide a Fortran function named mhd_grid_gauss_point that calculates the point of the Gauss quadrature for a given number of points. The number of input arguments is 2, where 'npoints' is an integer representing the number of points and 'k' is also an integer representing the index of the point. The output argument is a real number 'x' representing the calculated point. \n\nTo execute the function, declare the input arguments 'npoints' and 'k' as integers and 'x' as a real number. Initialize the parameters 'x1', 'x2', 'x3', 'x4', and 'x5' as arrays of real numbers. Use a select case statement to check the value of 'npoints'. Based on the value, assign the corresponding value of 'x' from the appropriate array. \n\nIf the value of 'npoints' does not match any of the cases, write an error message and stop the program.",
            "Write a Fortran function named mhd_grid_gauss_point that calculates the grid points for Gauss quadrature. The function takes two integer input parameters npoints and k, and returns a real(8) output parameter x. The function uses multiple parameter arrays x1, x2, x3, x4, and x5 to store the grid points for different numbers of quadrature points. Inside the function, a select case statement is used to select the appropriate parameter array based on the value of npoints. The function then assigns the corresponding grid point from the selected parameter array to the output parameter x based on the value of k. If npoints is not within the range of 1 to 5, an error message is displayed."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: npoints, k\n  real(8) :: x\n  \n  !case1\n  npoints = 1\n  k = 1\n  x = mhd_grid_gauss_point(npoints, k)\n  print *, x\n\n  !case2\n  npoints = 2\n  k = 1\n  x = mhd_grid_gauss_point(npoints, k)\n  print *, x\n\n  !case3\n  npoints = 3\n  k = 2\n  x = mhd_grid_gauss_point(npoints, k)\n  print *, x\n\n  !case4\n  npoints = 4\n  k = 3\n  x = mhd_grid_gauss_point(npoints, k)\n  print *, x\n\n  !case5\n  npoints = 5\n  k = 5\n  x = mhd_grid_gauss_point(npoints, k)\n  print *, x\nend program main",
            "result": [
                "0.0000000000000000",
                "-0.57735026899999997",
                "0.0000000000000000",
                "0.33998104400000001",
                "0.90617984600000001"
            ]
        },
        "code": "function mhd_grid_gauss_point(npoints, k) result(x)\n    !> points of the gauss quadrature.\n    !> {{{\n    integer, intent(in) :: npoints\n    integer, intent(in) :: k\n    real(8) :: x\n    !> }}}\n    real(8), dimension(1:1), parameter :: x1 = [ +0.000000000d0 ]\n    real(8), dimension(1:2), parameter :: x2 = [ -0.577350269d0, +0.577350269d0 ]\n    real(8), dimension(1:3), parameter :: x3 = [ -0.774596669d0, +0.000000000d0, +0.774596669d0 ]\n    real(8), dimension(1:4), parameter :: x4 = [ -0.861136312d0, -0.339981044d0, +0.339981044d0, &\n                                                 +0.861136312d0 ]\n    real(8), dimension(1:5), parameter :: x5 = [ -0.906179846d0, -0.538469310d0, +0.000000000d0, &\n                                                 +0.538469310d0, +0.906179846d0 ]\n    select case ( npoints )\n        case ( 1 )\n            x = x1(k)\n        case ( 2 )\n            x = x2(k)\n        case ( 3 )\n            x = x3(k)\n        case ( 4 )\n            x = x4(k)\n        case ( 5 )\n            x = x5(k)\n        case default\n            write (0,*) 'too many points for gauss quadratures.'\n            error stop -1\n    end select\nend function mhd_grid_gauss_point\n"
    },
    {
        "instruction": [
            "Please provide a Fortran function named mhd_grid_gauss_weight to calculate the weight of the Gauss quadrature for a specified number of points and a given index. The number of input arguments is 2, which are both integers. The number of output arguments is 1, which is a real number.",
            "Create a Fortran function named `mhd_grid_gauss_weight` that calculates the weights of the Gauss quadrature for a given number of points. The function has two input parameters: `npoints` (an integer) and `k` (also an integer). The function returns a single output parameter of type real(8) named `w`, which represents the calculated weight.\n\nTo compute the weight, the function uses pre-defined arrays `w1`, `w2`, `w3`, `w4`, and `w5`, each containing a set of weights for a specific number of points. The appropriate set of weights is selected based on the value of `npoints` using a `select case` construct.\n\nIf `npoints` is 1, the function assigns the `k`th element of array `w1` to the output parameter `w`. If `npoints` is 2, the `k`th element of array `w2` is assigned to `w`, and so on for `npoints` values of 3, 4, and 5.\n\nIf `npoints` does not fall within the defined cases (1, 2, 3, 4, or 5), the function displays an error message stating that there are too many points for Gauss quadrature and terminates with an error code of -1.\n\nPlease note that the code assumes the size of the array `w` based on the number of points specified in `npoints`, and the specific weight values are provided in the pre-defined arrays `w1`, `w2`, `w3`, `w4`, and `w5`.\n\nYour task is to create a function named `mhd_grid_gauss_weight` that takes two input parameters `npoints` and `k` and returns the weight `w` as specified above.",
            "Provide a Fortran function named mhd_grid_gauss_weight to compute the weights of the Gauss quadrature. The function takes two input parameters: npoints (an integer) and k (an integer). The function returns a single real(8) value as the output."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: npoints, k\n  real(8) :: w\n  \n  !case1\n  npoints = 1\n  k = 1\n  w = mhd_grid_gauss_weight(npoints, k)\n  print *, w\n\n  !case2\n  npoints = 2\n  k = 2\n  w = mhd_grid_gauss_weight(npoints, k)\n  print *, w\n\n  !case3\n  npoints = 3\n  k = 3\n  w = mhd_grid_gauss_weight(npoints, k)\n  print *, w\n\n  !case4\n  npoints = 4\n  k = 1\n  w = mhd_grid_gauss_weight(npoints, k)\n  print *, w\n\n  !case5\n  npoints = 5\n  k = 4\n  w = mhd_grid_gauss_weight(npoints, k)\n  print *, w\n\nend program main",
            "result": [
                "1.0000000000000000",
                "0.50000000000000000",
                "0.27777777799999998",
                "0.17392742300000000",
                "0.23931433499999999"
            ]
        },
        "code": "function mhd_grid_gauss_weight(npoints, k) result(w)\n    !> weights of the gauss quadrature.\n    !> {{{\n    integer, intent(in) :: npoints\n    integer, intent(in) :: k\n    real(8) :: w\n    !> }}}\n    real(8), dimension(1:1), parameter :: w1 = [ +1.000000000d0 ]\n    real(8), dimension(1:2), parameter :: w2 = [ +0.500000000d0, +0.50000000d0 ]\n    real(8), dimension(1:3), parameter :: w3 = [ +0.277777778d0, +0.444444444d0, +0.277777778d0 ]\n    real(8), dimension(1:4), parameter :: w4 = [ +0.173927423d0, +0.326072577d0, +0.326072577d0, &\n                                                 +0.173927423d0 ]\n    real(8), dimension(1:5), parameter :: w5 = [ +0.118463443d0, +0.239314335d0, +0.284444444d0, &\n                                                 +0.239314335d0, +0.118463443d0 ]\n    select case ( npoints )\n        case ( 1 )\n            w = w1(k)\n        case ( 2 )\n            w = w2(k)\n        case ( 3 )\n            w = w3(k)\n        case ( 4 )\n            w = w4(k)\n        case ( 5 )\n            w = w5(k)\n        case default\n            write (0,*) 'too many points for gauss quadratures.'\n            error stop -1\n    end select\nend function mhd_grid_gauss_weight\n"
    },
    {
        "instruction": [
            "Write a Fortran function named \"basicanemology\" that performs basic calculations related to wind speed and direction. The function requires 3 input parameters of type \"real, dimension(3)\" and 3 output parameters of type \"real\" and \"integer\". The input parameters are \"rvwindavg\" which represents the average wind velocity in three dimensions. The output parameters are \"rvel\" which represents the horizontal wind speed, \"rdir\" which represents the horizontal wind direction, and \"r3dvel\" which represents the full-vector wind speed. The function calculates the horizontal and full-vector wind speeds using the input parameter \"rvwindavg\" and stores them in \"rvel\" and \"r3dvel\" respectively. It also calculates the horizontal wind direction using the components of \"rvwindavg\" and stores the result in \"rdir\". If the direction is negative, it adds 360 degrees to ensure it falls within the range of 0 to 360 degrees. The function returns an integer \"iretcode\" which is set to 0 to indicate successful execution.",
            "Provide a Fortran function named basicanemology to calculate various wind-related parameters. The function takes in 3 input arguments of type real array and 3 output arguments of type real and integer. The input arguments are rvwindavg (a 3-element real array), and the output arguments are rvel (real), rdir (real), and r3dvel (real). The function computes the horizontal and full-vector wind speeds, the horizontal wind direction, and the 3D wind speed. The function assumes success and returns an integer code indicating the status, with 0 indicating success.",
            "Write a Fortran function named basicanemology that performs basic calculations related to wind speed and direction. The function takes in three input parameters of type real, which represent the average wind velocity components in three dimensions (rvwindavg). It also has three output parameters of type real, which store the computed wind speed (rvel), wind direction (rdir), and 3D wind speed (r3dvel). The function returns an integer value (iretcode) indicating the success or failure of the computation.\n\nIn the function, the wind speed is calculated by taking the square root of the sum of the squares of the first two components of rvwindavg. The 3D wind speed is calculated by taking the square root of the sum of the squares of all three components of rvwindavg. The wind direction is computed using the atan2 function, taking into account the sign of the wind components. The resulting direction is converted from radians to degrees and adjusted to be within the range of 0 to 360 degrees.\n\nMake sure to use this function to perform basic calculations related to wind speed and direction."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real, dimension(3) :: rvwindavg\n  real :: rvel, rdir, r3dvel\n  integer :: iretcode\n  \n  !case1\n  rvwindavg = [1.0, 1.0, 0.0]\n  iretcode = basicanemology(rvwindavg, rvel, rdir, r3dvel)\n  print *, rvel, rdir, r3dvel, iretcode\n  \n  !case2\n  rvwindavg = [-2.0, 3.0, 1.0]\n  iretcode = basicanemology(rvwindavg, rvel, rdir, r3dvel)\n  print *, rvel, rdir, r3dvel, iretcode\n  \n  !case3\n  rvwindavg = [0.0, 4.0, -3.0]\n  iretcode = basicanemology(rvwindavg, rvel, rdir, r3dvel)\n  print *, rvel, rdir, r3dvel, iretcode\n  \n  !case4\n  rvwindavg = [-1.0, -1.0, -1.0]\n  iretcode = basicanemology(rvwindavg, rvel, rdir, r3dvel)\n  print *, rvel, rdir, r3dvel, iretcode\n  \n  !case5\n  rvwindavg = [2.5, -1.5, 0.0]\n  iretcode = basicanemology(rvwindavg, rvel, rdir, r3dvel)\n  print *, rvel, rdir, r3dvel, iretcode\nend program main",
            "result": [
                "1.41421354       225.000000       1.41421354               0",
                "3.60555124       146.309921       3.74165750               0",
                "4.00000000       180.000000       5.00000000               0",
                "1.41421354       45.0000000       1.73205078               0",
                "2.91547585       300.963745       2.91547585               0"
            ]
        },
        "code": "\tfunction basicanemology(rvwindavg, rvel, rdir, r3dvel) result(iretcode)\n\t\n\t\t! routine arguments\n\t\treal, dimension(3), intent(in)\t:: rvwindavg\n\t\treal, intent(out)\t\t\t\t:: rvel\n\t\treal, intent(out)\t\t\t\t:: rdir\n\t\treal, intent(out)\t\t\t\t:: r3dvel\n\t\tinteger\t\t\t\t\t\t\t:: iretcode\n\t\t\n\t\t! locals\n\t\treal, parameter\t:: pi = 3.1415927\n\t\t\n\t\t! assume success (will falsify on failure)\n\t\tiretcode = 0\n\t\t\n\t\t! compute horizontal and full-vector wind speeds\n\t\trvel = sqrt(sum(rvwindavg(1:2)**2))\n\t\tr3dvel = sqrt(sum(rvwindavg**2))\n\t\t\n\t\t! compute horizontal wind direction (provenance convention: see sign of wind components!)\n\t\trdir = 180./pi * atan2(-rvwindavg(1), -rvwindavg(2))\n\t\tif(rdir <    0.) rdir = rdir + 360.\n\t\tif(rdir >= 360.) rdir = rdir - 360.\n\t\t\n\tend function basicanemology\n"
    },
    {
        "instruction": [
            "Write a Fortran function named \"rhocp\" that calculates the product of density (rho) and heat capacity (cp) using the hydrostatic approximation. The function takes two input arguments: rheight (real) representing the station altitude above geoid in meters, and rtemperature (real) representing the sonic temperature in Kelvin. The function returns a single output value rrhocp (real), which is the calculated rho * cp.",
            "Provide a Fortran function named \"rhocp\" that calculates the product of density (rho) and specific heat capacity (cp) using the hydrostatic approximation formula. The function takes in two input parameters, rheight (station altitude above geoid in meters) and rtemperature (sonic temperature in Kelvin), both of which are of type real. The function returns the result, rrhocp, which is also of type real.",
            "Write a Fortran function named rhocp that calculates the value of the product of density (rho) and specific heat (cp) using the hydrostatic approximation. The function takes in two input arguments: rheight (station altitude above geoid in meters) and rtemperature (sonic temperature in Kelvin). The function returns a single output value, rrhocp, which is the computed value of rho * cp."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real :: rheight, rtemperature, rrhocp\n  \n  !case1\n  rheight = 1000.0\n  rtemperature = 300.0\n  rrhocp = rhocp(rheight, rtemperature)\n  print *, rrhocp\n\n  !case2\n  rheight = 0.0\n  rtemperature = 273.15\n  rrhocp = rhocp(rheight, rtemperature)\n  print *, rrhocp\n\n  !case3\n  rheight = -500.0\n  rtemperature = 310.0\n  rrhocp = rhocp(rheight, rtemperature)\n  print *, rrhocp\n\n  !case4\n  rheight = 2000.0\n  rtemperature = 290.0\n  rrhocp = rhocp(rheight, rtemperature)\n  print *, rrhocp\n\n  !case5\n  rheight = 1500.0\n  rtemperature = 280.0\n  rrhocp = rhocp(rheight, rtemperature)\n  print *, rrhocp\nend program main",
            "result": [
                "1054.87683",
                "1298.46838",
                "1144.11816",
                "966.053040",
                "1054.64319"
            ]
        },
        "code": "\tfunction rhocp(rheight, rtemperature) result(rrhocp)\n\t\n\t\t! routine arguments\n\t\treal, intent(in)\t:: rheight\t\t\t! station altitude above geoid (m)\n\t\treal, intent(in)\t:: rtemperature\t\t! sonic temperature, already converted to k\n\t\treal\t\t\t\t:: rrhocp\n\t\t\n\t\t! locals\n\t\treal\t:: rnonnegativeheight\n\t\treal\t:: rpressure\n\t\treal\t:: rtemp\n\t\t\n\t\t! compute rho * cp using hydrostatic approximation\n\t\trnonnegativeheight = max(0., rheight)\n\t\trpressure          = 1013.0 * exp(-0.0342/rtemperature*rnonnegativeheight)\n\t\trrhocp             = 350.125*rpressure/rtemperature\n\t\n\tend function rhocp\n"
    },
    {
        "instruction": [
            "Provide a Fortran function named replace_single that replaces a specified substring with a replacement string in an input string. The function takes four input arguments: \n1. input (character array): The input string to be modified.\n2. substring (character array): The substring to be replaced.\n3. replacement (character array): The string that will replace the substring.\n4. mode (optional integer): Specifies the replacement mode. If not provided, the default mode is 'replace_all'.\n\nThe function returns a character array 'replace_single' that contains the modified input string.\n\nTo use the function, pass the input string, substring, replacement, and optionally the mode as arguments. The function will search for the substring in the input string and replace it with the replacement string based on the specified mode. If the mode is 'replace_all', all occurrences of the substring will be replaced. If the mode is 'last_only', only the last occurrence of the substring will be replaced.\n\nExample usage:\nreplace_single(\"Hello world!\", \"world\", \"universe\", replace_all) => \"Hello universe!\"\nreplace_single(\"Hello world!\", \"world\", \"universe\", last_only) => \"Hello universe!\"",
            "I need a Fortran function code named replace_single. This function takes in four input arguments: input (a character string), substring (a character string), replacement (a character string), and an optional mode (an integer). The function returns a character string.\n\nThe function's main purpose is to replace a single occurrence or multiple occurrences of a substring within the input string with a replacement string. The mode argument determines the behavior of the replacement. If mode is not provided, the default behavior is to replace all occurrences of the substring.\n\nTo implement the function, follow these steps:\n1. Define the input arguments: input, substring, replacement, and mode.\n2. Create a variable to store the replaced string: replace_single (an allocatable character string).\n3. Determine the mode of replacement (default to replace_all if not provided).\n4. Handle the case where the substring is empty to avoid errors.\n5. Initialize variables: pos (position of substring), back (logical variable to control backward search).\n6. Start a loop to find the substring within the input string.\n7. If the substring is found, append the part of the input string before the substring, the replacement string, and update the position.\n8. If the mode is last_only and the substring is found, exit the loop.\n9. If the mode is not replace_all, exit the loop.\n10. Append the remaining part of the input string to the replaced string.\n11. Return the replaced string.\n\nRemember to pay attention to zero-length substrings and ensure that the function handles them correctly.",
            "Write a Fortran function code named replace_single that is used to replace a single occurrence or all occurrences of a specified substring in a given input string. The function takes four parameters as input: \n- \"input\", a character string representing the input string\n- \"substring\", a character string representing the substring to be replaced\n- \"replacement\", a character string representing the replacement for the substring\n- \"mode\", an optional integer representing the mode of replacement (default value is \"replace_all\")\n\nThe function returns a character string \"replace_single\" which is the input string with the specified substring replaced.\n\nTo use the function, provide the input string, the substring to be replaced, the replacement string, and optionally the mode of replacement. The function will then return the modified string with the desired replacement."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=:), allocatable :: input, substring, replacement\n\n  !case1\n  input = \"Hello World\"\n  substring = \"World\"\n  replacement = \"Universe\"\n  print *, replace_single(input, substring, replacement)\n  \n  !case2\n  input = \"Mississippi\"\n  substring = \"ss\"\n  replacement = \"XX\"\n  print *, replace_single(input, substring, replacement)\n\n  !case3\n  input = \"abcde\"\n  substring = \"cd\"\n  replacement = \"XYZ\"\n  print *, replace_single(input, substring, replacement)\n\n  !case4\n  input = \"1234\"\n  substring = \"2\"\n  replacement = \"5\"\n  print *, replace_single(input, substring, replacement)\n\n  !case5\n  input = \"Hello\"\n  substring = \"l\"\n  replacement = \"LL\"\n  print *, replace_single(input, substring, replacement)\n  \nend program main",
            "result": [
                "Hello Universe",
                "MissiXXippi",
                "abXYZe",
                "1534",
                "HelLLo"
            ]
        },
        "code": "function replace_single( input, substring, replacement, mode )\r\n    character(len=*), intent(in)  :: input\r\n    character(len=*), intent(in)  :: substring\r\n    character(len=*), intent(in)  :: replacement\r\n    integer, intent(in), optional :: mode\r\n\r\n    character(len=:), allocatable :: replace_single\r\n\r\n    integer                       :: k, pos, mode_\r\n    logical                       :: back\r\n\r\n    ! careful with zero-length substrings\r\n    if ( substring == '' ) then\r\n        replace_single = input\r\n        return\r\n    endif\r\n\r\n    mode_ = replace_all\r\n    if ( present(mode) ) then\r\n        mode_ = mode\r\n    endif\r\n\r\n    back = ( mode_ == last_only )\r\n\r\n    !\r\n    ! find the substring\r\n    !\r\n    pos            = 1\r\n    replace_single = ''\r\n\r\n    do\r\n         k = index( input(pos:), substring, back )\r\n         !write(*,*) 'k = ', k\r\n\r\n         if ( k >= 1 ) then\r\n             replace_single = replace_single // input(pos:pos+k-2) // replacement\r\n             pos = pos + k + len(substring) - 1\r\n         else\r\n             exit\r\n         endif\r\n\r\n         if ( mode_ /= replace_all ) then\r\n             exit\r\n         endif\r\n    enddo\r\n\r\n    replace_single = replace_single // input(pos:)\r\n\r\nend function replace_single\r\n"
    },
    {
        "instruction": [
            "Create a Fortran function named insert that inserts a given string into another string at a specified position. The function takes three input parameters: input (a character string), pos (an integer representing the position where the string should be inserted), and string (the string to be inserted). The function returns a character string as output. \n\nTo implement the function, first check if the position is at the end of the input string. If true, append the string to the end of the input string and return the result. If not, check if the position is at the beginning of the input string. If true, prepend the string to the input string and return the result. \n\nIf neither condition is met, insert the string at the specified position within the input string by concatenating the substring before the position, the string to be inserted, and the substring after the position. Finally, return the resulting string.",
            "Provide a Fortran function named \"insert\" that allows you to insert a string into another string at a specified position. The function takes three input parameters: \"input\" of type character, \"pos\" of type integer, and \"string\" of type character. It returns a character string \"insert\" as the output. \n\nTo use the function, provide the \"input\" string, the position \"pos\" at which you want to insert the \"string\", and the \"string\" you want to insert. The function will return the modified string with the \"string\" inserted at the specified position.",
            "Create a Fortran function named \"insert\" that takes in three parameters: an input string, a position integer, and a string to be inserted. These parameters should be of type \"character(len=*)\" and \"integer\" respectively. The function will return a string that is the result of inserting the second string into the input string at the specified position.\n\nTo use the function, call it by providing the input string, the position at which to insert, and the string to be inserted. The function will then return the modified string with the insertion."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=20) :: input\n  integer :: pos\n  character(len=20) :: string\n  \n  !case1\n  input = \"Hello World\"\n  pos = 6\n  string = \"Beautiful \"\n  print *, insert(input, pos, string)\n\n  !case2\n  input = \"Fortran is\"\n  pos = 1\n  string = \"Amazing \"\n  print *, insert(input, pos, string)\n\n  !case3\n  input = \"Hello\"\n  pos = 5\n  string = \" World\"\n  print *, insert(input, pos, string)\n\n  !case4\n  input = \"Programming\"\n  pos = 11\n  string = \" in Fortran\"\n  print *, insert(input, pos, string)\n\n  !case5\n  input = \"This is a test\"\n  pos = 15\n  string = \" for the insert function\"\n  print *, insert(input, pos, string)\nend program main",
            "result": [
                "Hello Beautiful           World",
                "FAmazing             ortran is",
                "Hello World",
                "Programming in Fortran",
                "This is a test  for the insert func"
            ]
        },
        "code": "function insert( input, pos, string )\r\n    character(len=*), intent(in)         :: input\r\n    integer, intent(in)                  :: pos\r\n    character(len=*), intent(in)         :: string\r\n\r\n    character(len=:), allocatable        :: insert\r\n\r\n    ! check the position - in this order\r\n    if ( pos >= len(input) .or. pos == append ) then\r\n        insert = input // string\r\n        return\r\n    endif\r\n    if ( pos < 1 .or. pos == prepend ) then\r\n        insert = string // input\r\n        return\r\n    endif\r\n\r\n    ! position within the string\r\n    insert = input(1:pos) // string // input(pos+1:)\r\n\r\nend function insert\r\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named trimx to remove leading and trailing characters from a given input string based on a specified set of characters. The function takes two input arguments of type character, input and set, and returns a single output argument of type character. The name of the function is trimx.",
            "Provide a Fortran function named trimx that trims a given input string by removing leading and trailing characters that are present in a given set of characters. The function accepts two input arguments: the input string of any length (character) and the set of characters to be trimmed (character). The function returns the trimmed string as output, which is also a character of variable length.",
            "Create a Fortran function called trimx that trims a given string, removing any leading or trailing characters that match a given set of characters. The function takes two input arguments: 'input', which is the string to be trimmed, and 'set', which is the set of characters to be removed. Both input arguments are of type character. The function returns a trimmed version of the input string, with leading and trailing characters removed. The output is of type character and is stored in the allocatable variable 'trimx'."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=:), allocatable :: input\n  character(len=:), allocatable :: set\n  character(len=:), allocatable :: result\n\n  !case1\n  input = \"   hello world   \"\n  set = \" \"\n  result = trimx(input, set)\n  print *, trim(result)\n\n  !case2\n  input = \"abcdefg\"\n  set = \"abc\"\n  result = trimx(input, set)\n  print *, trim(result)\n\n  !case3\n  input = \"Programming\"\n  set = \"ing\"\n  result = trimx(input, set)\n  print *, trim(result)\n\n  !case4\n  input = \"1234567890\"\n  set = \"0123456789\"\n  result = trimx(input, set)\n  print *, trim(result)\n\n  !case5\n  input = \"   remove leading and trailing spaces    \"\n  set = \" \"\n  result = trimx(input, set)\n  print *, trim(result)\n\nend program main",
            "result": [
                "hello world",
                "defg",
                "Programm",
                "\u0000",
                "remove leading and trailing spaces"
            ]
        },
        "code": "function trimx( input, set )\r\n    character(len=*), intent(in)         :: input\r\n    character(len=*), intent(in)         :: set\r\n    character(len=:), allocatable        :: trimx\r\n\r\n    integer                              :: start, stop\r\n\r\n    start = verify( input, set )\r\n    stop  = verify( input, set, .true. )\r\n\r\n    trimx = input(start:stop)\r\n\r\nend function trimx\r\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named trimxleft to remove leading characters from a given input string. The function takes two input arguments of type character(len=*), named input and set. The function returns a new string, trimxleft, which is the input string with all leading characters that match the set removed.",
            "Write a Fortran function code called trimxleft that removes leading characters from a given input string. The function takes two input arguments: \"input\" of type character and \"set\" of type character. The function also returns a character string as output, which is allocated dynamically. \n\nTo execute the function, you should pass the input string and the set of characters to remove as arguments. The function will find the position of the first character in the input string that is not present in the set of characters. Then, it will allocate a new string starting from that position and assign it to the output variable.",
            "Provide a Fortran function named trimxleft that trims characters from the left side of a given string. The function takes two input arguments, both of type character, and one output argument, also of type character. The input argument \"input\" represents the string that needs to be trimmed, while the input argument \"set\" represents the set of characters to be trimmed. The function calculates the starting index of the first character in the input string that is not present in the set, and then returns a new string starting from that index. The output argument \"trimxleft\" is an allocatable character variable that holds the trimmed string."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=:), allocatable :: input\n  character(len=:), allocatable :: set\n\n  !case1\n  input = \"   Hello, World!   \"\n  set = \" \"\n  print *, trimxleft(input, set)\n\n  !case2\n  input = \"abcdefg\"\n  set = \"xy\"\n  print *, trimxleft(input, set)\n\n  !case3\n  input = \"1234\"\n  set = \"1234\"\n  print *, trimxleft(input, set)\n\n  !case4\n  input = \"   \"\n  set = \" \"\n  print *, trimxleft(input, set)\n\n  !case5\n  input = \"Hello, World!\"\n  set = \"HeloWrd!\"\n  print *, trimxleft(input, set)\n\nend program main",
            "result": [
                "Hello, World!",
                "abcdefg",
                "\u00001234",
                "\u0000",
                ", World!"
            ]
        },
        "code": "function trimxleft( input, set )\r\n    character(len=*), intent(in)         :: input\r\n    character(len=*), intent(in)         :: set\r\n    character(len=:), allocatable        :: trimxleft\r\n\r\n    integer                              :: start\r\n\r\n    start = verify( input, set )\r\n\r\n    trimxleft = input(start:)\r\n\r\nend function trimxleft\r\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named checkempty to check if a given string is empty. The function takes in one input argument of type character and returns a logical value. The number of input arguments is 1 and the test_data type is [character]. The number of output arguments is 1 and the test_data type is [logical].",
            "Write a Fortran function named \"checkempty\" that checks if a given string is empty or not. The function takes one input argument of type character(len=*) named \"string\". The output of the function is a logical value indicating whether the input string is empty or not. The function should return true if the length of the trimmed string is zero, and false otherwise.",
            "Give me a Fortran function code named checkempty to check if a given string is empty. The function takes a single input parameter of type string and returns a logical value. The number of input arguments is 1 and the test_data type is [character(len=*)]. The number of output arguments is 1 and the test_data type is [logical]."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=100) :: string\n  \n  !case1\n  string = \"\"\n  print *, checkempty(string)\n\n  !case2\n  string = \"Hello World\"\n  print *, checkempty(string)\n\n  !case3\n  string = \"   \"\n  print *, checkempty(string)\n\n  !case4\n  string = \"12345\"\n  print *, checkempty(string)\n\n  !case5\n  string = \"Fortran\"\n  print *, checkempty(string)\nend program main",
            "result": [
                "T",
                "F",
                "T",
                "F",
                "F"
            ]
        },
        "code": " function checkempty(string)\n \n!***********************************************************************\n!     \n\n!     originally written in jetspin by m. lauricella et al.\n!     \n!     licensed under the 3-clause bsd license (bsd-3-clause)\n!     author: m. lauricella\n!     last modification july 2018\n!     \n!***********************************************************************\n  \n  implicit none\n  \n  character(len=*), intent(in) :: string\n  \n  logical :: checkempty\n  \n  integer :: i\n  \n  i=len(trim(string))\n  \n  checkempty=(i==0)\n\n  return\n  \n end function checkempty\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named int_to_str to convert an integer to a string. The function takes in one input argument of type integer and returns a string as the output.",
            "Provide a Fortran function named int_to_str that converts an integer to a string representation. The function takes an integer as input, specified with the \"intent(in)\" keyword, and returns a character string. The function utilizes Fortran's character and integer data types. The number of input arguments is 1, with a test_data type of [integer]. The number of output arguments is 1, with a test_data type of [character].",
            "Provide a Fortran function named int_to_str that converts an integer to a string. The function takes an integer as input and returns a character string. The input parameter is of type integer and has a intent of \"in\". The output parameter is of type character and is dynamically allocated. The function uses the Fortran feature of character allocation and string manipulation to convert the integer to a string representation."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: i\n  character(:), allocatable :: s\n\n  !case1\n  i = 12345\n  s = int_to_str(i)\n  print *, trim(s)\n\n  !case2\n  i = -9876\n  s = int_to_str(i)\n  print *, trim(s)\n\n  !case3\n  i = 0\n  s = int_to_str(i)\n  print *, trim(s)\n\n  !case4\n  i = 99999999\n  s = int_to_str(i)\n  print *, trim(s)\n\n  !case5\n  i = -123456789\n  s = int_to_str(i)\n  print *, trim(s)\n\nend program main",
            "result": [
                "12345",
                "-9876",
                "0",
                "99999999",
                "-123456789"
            ]
        },
        "code": "  function int_to_str(i) result(s)\n    implicit none\n    \n    character(:), allocatable :: s\n    integer, intent(in) :: i\n    character(range(i)+2) :: scratch\n\n    write(scratch,'(i0)') i\n    s = trim(scratch)\n  end function int_to_str\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named deboor to perform De Boor's algorithm for spline interpolation. The function takes four input arguments: i (integer), k (integer), x (real), and t (real array). The function returns a real value. The purpose of the code is to recursively calculate the value of a spline curve at a given point using De Boor's algorithm. The algorithm evaluates the spline by recursively applying weighted combinations of control points based on the given knot vector.",
            "Provide a Fortran function named \"deboor\" that implements the de Boor algorithm for computing the value of a B-spline basis function. The function takes four input parameters: an integer \"i\" representing the starting index of the knot interval, an integer \"k\" representing the degree of the B-spline, a real number \"x\" representing the evaluation point, and a real array \"t\" representing the knot vector. The function returns a real value \"db\" which represents the value of the B-spline basis function at the given evaluation point.",
            "Create a recursive Fortran function named \"deboor\" that calculates the value of a de Boor basis function for a given index, degree, target point, and knot vector. The function takes four input parameters: an integer \"i\" representing the index of the basis function, an integer \"k\" representing the degree of the basis function, a real number \"x\" representing the target point, and a one-dimensional real array \"t\" representing the knot vector. The function returns a real number \"db\" as the result of the computation."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: i, k\n  real :: x\n  real, allocatable :: t(:)\n  \n  !case1\n  i = 1\n  k = 3\n  x = 0.5\n  allocate(t(4))\n  t = [0.0, 0.2, 0.4, 0.6]\n  print *, deboor(i, k, x, t)\n  deallocate(t)\n\n  !case2\n  i = 3\n  k = 2\n  x = 0.8\n  allocate(t(5))\n  t = [0.0, 0.1, 0.4, 0.8, 1.0]\n  print *, deboor(i, k, x, t)\n  deallocate(t)\n\n  !case3\n  i = 2\n  k = 4\n  x = 0.6\n  allocate(t(6))\n  t = [0.0, 0.1, 0.3, 0.5, 0.7, 1.0]\n  print *, deboor(i, k, x, t)\n  deallocate(t)\n\n  !case4\n  i = 1\n  k = 1\n  x = 0.2\n  allocate(t(3))\n  t = [0.0, 0.3, 0.5]\n  print *, deboor(i, k, x, t)\n  deallocate(t)\n\n  !case5\n  i = 2\n  k = 3\n  x = 0.7\n  allocate(t(5))\n  t = [0.0, 0.2, 0.3, 0.7, 1.0]\n  print *, deboor(i, k, x, t)\n  deallocate(t)\nend program main",
            "result": [
                "0.125000030",
                "1.00000000",
                "0.547023773",
                "1.00000000",
                "0.428571463"
            ]
        },
        "code": "  recursive function deboor(i, k, x, t) result(db)\n    real :: db\n    integer, intent(in) :: i, k\n    real, intent(in) :: x\n    real, dimension(:), intent(in) :: t\n    real :: a1, a2\n\n    if ( k .eq. 1 ) then\n      if ( x .ne. t(size(t)) ) then\n        if ( ( x .ge. t(i) ) .and. ( x .lt. t(i+1) ) ) then\n          db = 1.\n        else\n          db = 0.\n        end if\n      else\n        if ( ( x .ge. t(i) ) .and. ( x .le. t(i+1) ) ) then\n          db = 1.\n        else\n          db = 0.\n        end if\n      end if\n    else\n      if ( t(i+k-1) - t(i) .ne. 0. ) then\n        a1 = ( x - t(i) ) / ( t(i+k-1) - t(i) )\n      else\n        a1 = 0.\n      end if\n      if ( t(i+k) - t(i+1) .ne. 0. ) then\n        a2 = ( t(i+k) - x ) / ( t(i+k) - t(i+1) )\n      else\n        a2 = 0.\n      end if\n      db = a1 * deboor(i, k-1, x, t) + a2 * deboor(i+1, k-1, x, t)\n    end if\n    return\n  end function deboor\n"
    },
    {
        "instruction": [
            "Write a Fortran function named has_duplicates that determines whether an array of integers contains any duplicate values. The function takes an input array of integers, specified by the intent(in) keyword, and returns a logical value indicating whether duplicates are present. The input parameter is an integer array of any size. The output parameter is a logical value.",
            "Create a Fortran function called \"has_duplicates\" that checks whether an input integer array contains duplicates. The function takes in an integer array as the input parameter. The number of input arguments is 1 and the data type is [integer, dimension(:)]. The function returns a logical value indicating whether duplicates are found. The number of output arguments is 1 and the data type is [logical].",
            "Create a Fortran function named \"has_duplicates\" that determines whether an input integer array contains any duplicate elements. The function takes one input argument, an integer array named \"data\", and returns one output argument, a logical value named \"result\". The input array is specified using the \"intent(in)\" keyword. The function uses two nested do-loops to compare each element with all the subsequent elements in the array. If a duplicate is found, the function sets \"result\" to true and exits the outer loop using the \"exit\" statement. If no duplicates are found, \"result\" is set to false."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer, allocatable :: data(:)\n  \n  !case1\n  allocate(data(5))\n  data = [1, 2, 3, 4, 5]\n  print *, has_duplicates(data)\n  deallocate(data)\n\n  !case2\n  allocate(data(5))\n  data = [1, 2, 3, 4, 4]\n  print *, has_duplicates(data)\n  deallocate(data)\n\n  !case3\n  allocate(data(3))\n  data = [3, 3, 3]\n  print *, has_duplicates(data)\n  deallocate(data)\n\n  !case4\n  allocate(data(6))\n  data = [1, 2, 1, 2, 1, 2]\n  print *, has_duplicates(data)\n  deallocate(data)\n\n  !case5\n  allocate(data(8))\n  data = [4, 5, 6, 7, 4, 5, 6, 7]\n  print *, has_duplicates(data)\n  deallocate(data)\n  \nend program main",
            "result": [
                "F",
                "T",
                "T",
                "T",
                "T"
            ]
        },
        "code": "    function has_duplicates(data) result(result)\n        integer, dimension(:), intent(in) :: data\n        logical :: result\n        integer :: i, j\n\n        result = .false.\n        outer: do i = 1, size(data) - 1\n            do j = i + 1, size(data)\n                if (data(i) == data(j)) then\n                    result = .true.\n                    exit outer\n                end if\n            end do\n        end do outer\n    end function has_duplicates\n"
    },
    {
        "instruction": [
            "Create a Fortran function named fib, which uses recursion to calculate the Fibonacci number for a given input integer. The function takes one input parameter of type integer, named \"n\". It returns one output parameter of type integer, named \"f\". The function first checks if \"n\" is equal to 0 and assigns 0 to \"f\" if true. If \"n\" is less than 3, it assigns 1 to \"f\". Otherwise, it calculates \"f\" by recursively calling the fib function with \"n-1\" and \"n-2\", and adding their results.",
            "Create a Fortran function called fib that calculates the Fibonacci number for a given input value. The function takes an integer input argument, n, and returns an integer output argument, f. The function uses recursion to compute the Fibonacci number by checking the base cases (0 and 1) and recursively calling itself to calculate the Fibonacci number for n-1 and n-2. Use the following command to call the function: fib(n).",
            "Provide a Fortran function code named fib that calculates the Fibonacci number for a given input integer. The function takes in one input argument of type integer and returns one output argument of type integer. The input argument represents the number for which the Fibonacci number needs to be calculated. The output argument represents the calculated Fibonacci number."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n\n  \n  !case1\n  n = 0\n  print *, fib(n)\n  \n  !case2\n  n = 1\n  print *, fib(n)\n  \n  !case3\n  n = 5\n  print *, fib(n)\n  \n  !case4\n  n = 10\n  print *, fib(n)\n  \n  !case5\n  n = 15\n  print *, fib(n)\n  \nend program main",
            "result": [
                "0",
                "1",
                "5",
                "55",
                "610"
            ]
        },
        "code": "recursive function fib(n) result(f)\n  implicit none\n  integer :: f, n\n  if (n == 0) then\n    f = 0\n  else if (n < 3) then\n    f = 1\n  else\n    f = fib(n-1) + fib(n-2)\n  end if\nend function\n"
    },
    {
        "instruction": [
            "Create a Fortran function named factorial2 that calculates the factorial of a given number. The input parameter is an integer (n) and the output parameter is also an integer (fact2). The function uses an if-else statement to check if the input number is even or odd. If the number is even, it calculates the factorial by multiplying even numbers from 2 to n. If the number is odd, it calculates the factorial by multiplying odd numbers from 1 to n.",
            "Write a Fortran function code named factorial2 that calculates the factorial of a given integer number. The function takes an input argument, 'n', of type integer. The output is an integer named 'fact2'. The code uses an iterative approach to calculate the factorial, where even numbers are multiplied together from 2 to 'n', and odd numbers are multiplied together from 1 to 'n'.",
            "Please provide me with a Fortran function named factorial2. This function takes an integer input parameter named n. The function calculates the factorial of n using an iterative approach and returns the result as an integer output parameter named fact2. The function handles both even and odd values of n. If n is -1, the factorial is set to 1. The number of input arguments is 1 and the data type is an integer. The number of output arguments is 1 and the data type is also an integer."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n\n  \n  !case1\n  n = 5\n  print *, factorial2(n)\n  \n  !case2\n  n = -1\n  print *, factorial2(n)\n  \n  !case3\n  n = 10\n  print *, factorial2(n)\n  \n  !case4\n  n = 7\n  print *, factorial2(n)\n  \n  !case5\n  n = 0\n  print *, factorial2(n)\n  \nend program main",
            "result": [
                "15",
                "1",
                "3840",
                "105",
                "1"
            ]
        },
        "code": "        function factorial2(n) result(fact2)\n            implicit none\n\n            ! input\n            integer, intent(in) :: n\n\n            ! intermediate variable\n            integer :: i\n\n            ! output\n            integer :: fact2\n\n            if (n == -1) then\n                fact2 = 1\n            else if (mod(n,2) == 0) then ! even number\n                fact2 = 1\n\n                do i = 2, n, 2\n                    fact2 = fact2 * i\n                end do\n            else ! odd number\n                fact2 = 1\n\n                do i = 1, n, 2\n                    fact2 = fact2 * i\n                end do\n            end if\n\n        end function factorial2\n"
    },
    {
        "instruction": [
            "Provide a Fortran function named \"lin_scale_back\" that scales back a given value using linear scaling. The function takes three input arguments: val_scaled of type double precision, val_max of type double precision, and val_min of type double precision. The function returns a single output argument, val of type double precision, which represents the scaled back value.",
            "Provide a Fortran function named \"lin_scale_back\" that scales back a given value from a scaled range to its original range. The function takes three double precision input arguments: \"val_scaled\" (the scaled value), \"val_max\" (the maximum value in the original range), and \"val_min\" (the minimum value in the original range). The function returns a double precision output value, \"val\", which is the scaled back value.",
            "Create a Fortran function called \"lin_scale_back\" that scales back a given value using linear scaling. The function takes three double precision input parameters: \"val_scaled\", \"val_max\", and \"val_min\". The function returns a double precision output parameter called \"val\". To use the function, provide the scaled value, the maximum value, and the minimum value as inputs, and it will calculate and return the unscaled value."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  double precision :: val_scaled, val_max, val_min, val\n\n  !case1\n  val_scaled = 0.5\n  val_max = 10.0\n  val_min = 0.0\n  val = lin_scale_back(val_scaled, val_max, val_min)\n  print *, val\n\n  !case2\n  val_scaled = 0.2\n  val_max = 100.0\n  val_min = -100.0\n  val = lin_scale_back(val_scaled, val_max, val_min)\n  print *, val\n\n  !case3\n  val_scaled = 0.8\n  val_max = 20.0\n  val_min = -20.0\n  val = lin_scale_back(val_scaled, val_max, val_min)\n  print *, val\n\n  !case4\n  val_scaled = 1.0\n  val_max = 1000.0\n  val_min = 500.0\n  val = lin_scale_back(val_scaled, val_max, val_min)\n  print *, val\n\n  !case5\n  val_scaled = 0.0\n  val_max = 1.0\n  val_min = -1.0\n  val = lin_scale_back(val_scaled, val_max, val_min)\n  print *, val\nend program main",
            "result": [
                "5.0000000000000000",
                "-59.999999403953552",
                "12.000000476837158",
                "1000.0000000000000",
                "-1.0000000000000000"
            ]
        },
        "code": "    function lin_scale_back(val_scaled, val_max, val_min) result(val)\n    implicit none\n        double precision    :: val_scaled, val_max, val_min\n        double precision    :: val\n        \n        val = (val_max-val_min)*val_scaled + val_min\n    end function\n"
    },
    {
        "instruction": [
            "Provide a Fortran function named compasspoint to convert a heading angle into a compass point. The input parameter is a single precision real number (h) representing the heading angle. The output of the function is a character variable (compasspoint) representing the corresponding compass point.\n\nTo compute the compass point, divide the heading angle by 11.25 and add 1.5. If the result is greater than or equal to 33.0, subtract 32.0 from it. Then, use the integer part of the resulting value to index into an array of 32 compass points. Finally, assign the corresponding compass point to the compasspoint variable.\n\nPlease note that the compass points are stored in an array named points, and the resulting compass point should be left-aligned within an 18-character string.\n\nExample usage: \n```fortran\ncharacter(18) :: cp\nreal :: heading\n\nheading = 135.0\ncp = compasspoint(heading)\n```\n\nMake sure to provide the correct input and output data types when using the compasspoint function.",
            "Give me a Fortran function code named compasspoint that converts an angle in degrees to a corresponding compass point. The input argument is a single floating-point number h representing the angle in degrees. The function returns a string representing the compass point.",
            "Write a Fortran function named compasspoint that takes a floating-point number as input and returns a character string representing the corresponding compass point. The function uses the input value to calculate an index, which is then used to access the corresponding compass point from an array. The number of input arguments is 1 and the test data type is [real]. The number of output arguments is 1 and the test data type is [character(18)]."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real :: h\n\n  !case1\n  h = 0.0\n  print *, compasspoint(h)\n\n  !case2\n  h = 22.5\n  print *, compasspoint(h)\n\n  !case3\n  h = 45.0\n  print *, compasspoint(h)\n\n  !case4\n  h = 135.0\n  print *, compasspoint(h)\n\n  !case5\n  h = 348.75\n  print *, compasspoint(h)\n\nend program main",
            "result": [
                "north",
                "north-northeast",
                "northeast",
                "southeast",
                "north by west"
            ]
        },
        "code": "function compasspoint(h)\n  character(18) :: compasspoint\n  character(18) :: points(32) = (/ \"north             \", \"north by east     \", \"north-northeast   \", &\n             \"northeast by north\", \"northeast         \", \"northeast by east \", \"east-northeast    \", &\n             \"east by north     \", \"east              \", \"east by south     \", \"east-southeast    \", &\n             \"southeast by east \", \"southeast         \", \"southeast by south\", \"south-southeast   \", &\n             \"south by east     \", \"south             \", \"south by west     \", \"south-southwest   \", &\n             \"southwest by south\", \"southwest         \", \"southwest by west \", \"west-southwest    \", &\n             \"west by south     \", \"west              \", \"west by north     \", \"west-northwest    \", &\n             \"northwest by west \", \"northwest         \", \"northwest by north\", \"north-northwest   \", &\n             \"north by west     \"  /)\n  real, intent(in) :: h\n  real :: x\n\n  x = h / 11.25 + 1.5\n  if (x >= 33.0) x = x - 32.0\n  compasspoint = points(int(x))\nend function compasspoint\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named clampint to convert a floating-point color value to an integer within the range of 0 to 255. The number of input arguments is 1 and the data type is real. The number of output arguments is 1 and the data type is integer.",
            "Create a Fortran function called clampint that takes in a single precision floating point number as an input and returns an integer as an output. The function clamps the value of the input number between 0 and 255, inclusive, and then converts it to an integer. The input argument should be of type real(8) and is specified using the intent(in) keyword. The output argument should be of type integer(1).",
            "Create a Fortran function named clampint that takes a single input argument of type real(8) and returns an output value of type integer(1). This function is used to clamp the input color value within the range of 0 to 255. The input argument is named \"color\" and is passed by value using the \"intent(in)\" specifier. The output value is named \"clampint\" and is of type integer(1). Inside the function, the input color value is multiplied by 255.0d and then converted to an integer using the int() function. If the resulting value is greater than 255, it is set to 255. If the resulting value is less than 0, it is set to 0. Finally, the clamped value is converted back to integer with a kind of 1 and assigned to the output variable \"clampint\"."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real(8) :: color\n  \n  !case1: color is within the range [0, 1]\n  color = 0.5\n  print *, clampint(color)\n  \n  !case2: color is negative\n  color = -0.2\n  print *, clampint(color)\n  \n  !case3: color is greater than 1\n  color = 1.5\n  print *, clampint(color)\n  \n  !case4: color is exactly 0\n  color = 0.0\n  print *, clampint(color)\n  \n  !case5: color is exactly 1\n  color = 1.0\n  print *, clampint(color)\n  \nend program main",
            "result": [
                "127",
                "0",
                "-1",
                "0",
                "-1"
            ]
        },
        "code": "    pure function clampint(color)\n        real(8), intent(in) :: color\n        integer :: v\n        integer(1) :: clampint\n\n        v = int(color*255.0d+0)\n\n        if (v > 255) then\n            v = 255\n        else if (v < 0) then\n            v = 0\n        endif\n\n        clampint = int(v, kind=1)\n    end function\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named step to compute the sum of the squares of the individual digits of a given positive integer. The function takes one input argument of type integer and returns one output argument of type integer.",
            "Provide a Fortran function code named \"step\" that computes the sum of squares of the digits of a given positive integer. The function takes one input argument of type integer, specified as \"n\". The function returns one output argument of type integer, specified as \"step\".",
            "Write a Fortran function named \"step\" that takes an integer input argument \"n\". The function calculates the sum of squares of the individual digits of the input number. The function returns an integer output value named \"step\". The function is defined as a \"pure\" function, meaning it does not have any side effects and its output depends only on the input parameters."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n\n\n  !case1\n  n = 12345\n  print *, step(n)\n\n  !case2\n  n = 987654321\n  print *, step(n)\n\n  !case3\n  n = 0\n  print *, step(n)\n\n  !case4\n  n = 111111\n  print *, step(n)\n\n  !case5\n  n = 9999\n  print *, step(n)\n\nend program main",
            "result": [
                "55",
                "285",
                "0",
                "6",
                "324"
            ]
        },
        "code": "  pure function step(n)\n    implicit none\n    integer, intent(in) :: n\n    integer             :: step,remaining\n\n    step=0\n    remaining=n\n    do while (remaining>0)\n       step=step+mod(remaining,10)**2\n       remaining=remaining/10\n    end do\n    \n  end function step\n"
    },
    {
        "instruction": [
            "Provide a Fortran function named numbersonline to count the number of non-empty lines in a given string. The function has one input parameter, rec, of type character. The function returns the number of non-empty lines as an integer value.",
            "Provide a Fortran function code named numbersonline that counts the number of non-empty lines in a given string. The function takes one input parameter of type character, representing the string to be analyzed. The function returns an integer value, indicating the total number of non-empty lines found in the string.",
            "Provide a Fortran function code named \"numbersonline\" that counts the number of non-empty lines in a given character record. The function takes one input argument of type character, named \"rec\". The function returns an integer value, representing the number of non-empty lines in the record."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(100) :: rec\n\n  !case1\n  rec = \"This is a test case\"\n  print *, numbersonline(rec)\n\n  !case2\n  rec = \"1 2 3 4 5\"\n  print *, numbersonline(rec)\n\n  !case3\n  rec = \"SingleWord\"\n  print *, numbersonline(rec)\n\n  !case4\n  rec = \"\"\n  print *, numbersonline(rec)\n\n  !case5\n  rec = \"This   is    a    test\"\n  print *, numbersonline(rec)\nend program main",
            "result": [
                "5",
                "5",
                "1",
                "0",
                "4"
            ]
        },
        "code": "function numbersonline(rec       )\n    implicit none\n!\n! global variables\n!\n    integer         :: numbersonline\n    character(*)    :: rec\n!\n!\n! local variables\n!\n    integer                        :: i\n    integer                        :: istarti\n    integer                        :: leeg\n    integer                        :: lend\n!\n!\n!! executable statements -------------------------------------------------------\n!\n    !\n    numbersonline = 0\n    leeg = 1\n    lend = len_trim(rec)\n    do i = 1, lend\n       if (index(rec(i:i), ' ')==0) then\n          !           hier staat iets\n          if (leeg==1) then\n             leeg = 0\n             istarti = i\n             numbersonline = numbersonline + 1\n          endif\n       else\n          leeg = 1\n       endif\n    enddo\nend function numbersonline\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named toupper that converts all lowercase characters in a given string to uppercase. The input parameter is a character string (strin), and the output parameter is an allocated character string (strout). The number of input arguments is 1 and the data type is character(len=*). The number of output arguments is 1 and the data type is character(len=:), allocatable.",
            "Provide a Fortran function code named \"toupper\" to convert a given string to uppercase. The function takes a single input argument of type character array (string) and returns a modified version of the input string with all lowercase letters converted to uppercase. The function uses the \"len\" and \"allocatable\" features of Fortran to handle strings of variable length. The function also utilizes the \"iachar\" and \"achar\" functions to convert characters to their ASCII values and vice versa. The number of input arguments is 1 and the data type is \"character(len=*)\". The number of output arguments is 1 and the data type is \"character(len=:), allocatable\".",
            "Give me a Fortran function code named toupper to convert a given string to uppercase. The input parameter is a character string, and the output parameter is an allocatable character string. The function uses a loop to iterate through each character of the input string, checks if it is a lowercase letter, and converts it to uppercase if so. The function returns the converted string."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=:), allocatable :: strin, strout\n  \n  !case1\n  strin = \"Hello World\"\n  strout = toupper(strin)\n  print *, strout\n\n  !case2\n  strin = \"FoRtRaN\"\n  strout = toupper(strin)\n  print *, strout\n\n  !case3\n  strin = \"123abcXYZ\"\n  strout = toupper(strin)\n  print *, strout\n\n  !case4\n  strin = \"fortran\"\n  strout = toupper(strin)\n  print *, strout\n\n  !case5\n  strin = \"LowerCASE\"\n  strout = toupper(strin)\n  print *, strout\nend program main",
            "result": [
                "Hello World",
                "FoRtRaN",
                "123abcXYZ",
                "fortran",
                "LowerCASE"
            ]
        },
        "code": "    function toupper(strin) result(strout)\n        character(len=*), intent(in) :: strin\n        character(len=:), allocatable :: strout\n        integer :: i\n        integer :: j\n        integer :: offset\n  \n        offset=iachar('a')-iachar('a')\n        strout = strin\n        do i = 1, len(strin)\n            j = iachar(strin(i:i))\n            if (j>= iachar(\"a\") .and. j<=iachar(\"z\") ) then\n                strout(i:i) = achar(iachar(strin(i:i)) + offset)\n            else\n                strout(i:i) = strin(i:i)\n            end if\n        end do\n    end function toupper\n"
    },
    {
        "instruction": [
            "Create a Fortran function called tolower that converts all characters in a given string to lowercase. The function takes one input argument of type character and returns the modified string as the output.",
            "Provide a Fortran function code named tolower that converts a given string to lowercase. The function takes a single input argument of type character(len=*) and returns an allocatable character string. The function uses the features of Fortran, such as character manipulation and conditional statements, to perform the conversion. The function loops through each character in the input string and checks if it is a lowercase letter. If it is, the function subtracts the offset to convert it to lowercase. If it is not a lowercase letter, the function leaves it unchanged. The result is stored in an allocatable character string, which is returned as the output of the function.",
            "Provide a Fortran function code named tolower that converts all uppercase letters in a given string to lowercase. The function takes a single input parameter of type character and returns the converted string as output. The function uses the features of Fortran, such as the \"character\" and \"allocatable\" data types, as well as the \"intent(in)\" attribute to specify the input parameter. The function also includes a do loop to iterate over each character in the input string and convert it to lowercase if it is an uppercase letter. The resulting lowercase string is stored in an allocatable string variable named \"strout\"."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=:), allocatable :: strin, strout\n  \n  !case1\n  strin = \"Hello World\"\n  strout = tolower(strin)\n  print *, strout\n\n  !case2\n  strin = \"UPPER CASE\"\n  strout = tolower(strin)\n  print *, strout\n\n  !case3\n  strin = \"1234\"\n  strout = tolower(strin)\n  print *, strout\n\n  !case4\n  strin = \"Mixed Case 123\"\n  strout = tolower(strin)\n  print *, strout\n\n  !case5\n  strin = \"!@#$%^&*()_+\"\n  strout = tolower(strin)\n  print *, strout\nend program main",
            "result": [
                "Hello World",
                "UPPER CASE",
                "1234",
                "Mixed Case 123",
                "!@#$%^&*()_+"
            ]
        },
        "code": "    pure function tolower(strin) result(strout)\n        character(len=*), intent(in) :: strin\n        character(len=:), allocatable :: strout\n        integer :: i\n        integer :: j\n        integer :: offset\n \n        offset=iachar('a')-iachar('a')\n        strout = strin\n        do i = 1, len(strin)\n            j = iachar(strin(i:i))\n            if (j>= iachar(\"a\") .and. j<=iachar(\"z\") ) then\n                strout(i:i) = achar(iachar(strin(i:i)) - offset)\n            else\n                strout(i:i) = strin(i:i)\n            end if\n        end do\n    end function tolower\n"
    },
    {
        "instruction": [
            "Provide a Fortran function named \"gamma\" that calculates the gamma function for a given input value. The gamma function computes the factorial of a real number and is commonly used in various mathematical applications. \n\nThe function \"gamma\" takes one input parameter of type real, named \"x\", which represents the value for which the gamma function is to be computed. The function returns a real value, also named \"gamma\", as the result.\n\nThe function code includes a parameter declaration for the mathematical constant pi and an array \"g\" containing predefined values. Inside the function, there are conditional statements and loops to handle different cases based on the value of \"x\" and compute the gamma function accordingly.\n\nThe function checks if the input value \"x\" is an integer. If it is, the function calculates the factorial of \"x\" by iterating from 2 to \"x-1\". If the input value is not an integer, the function applies a series approximation using the array \"g\" to compute the gamma function. \n\nThe function utilizes various mathematical operations such as multiplication, subtraction, and trigonometric functions to compute the gamma function accurately for different input values.\n\nOverall, the \"gamma\" function provides a way to calculate the gamma function of a real number in Fortran.",
            "Provide a Fortran function code named gamma to calculate the gamma function of a real number x. The function takes 1 input argument of type real and returns 1 output argument of type real. \n\nThe gamma function is computed using a series of calculations and iterations. If the input x is an integer, the function calculates the factorial of x. If x is not an integer, the function uses a series approximation to calculate the gamma function. The function utilizes a data array g to store pre-defined values for the approximation. \n\nThe function uses control flow statements such as if-else and do loops to perform the necessary calculations. At the end, the calculated gamma function value is assigned to the variable gamma.",
            "Write a Fortran function named \"gamma\" to calculate the gamma function for a given input value. The function takes one input argument of type real and returns one output argument of type real. \n\nThe function uses a series expansion and a lookup table to compute the gamma function. If the input argument is an integer, the function uses a factorial calculation method. If the input argument is not an integer, the function uses a continued fraction approximation. \n\nThe function utilizes the \"intent(in)\" attribute to specify that the input argument is read-only and the \"parameter\" attribute to declare a constant value for pi. \n\nProvide this code as a function named \"gamma\" with the appropriate input and output parameters and types."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real :: x\n\n  !case1\n  x = 1.0\n  print *, gamma(x)\n\n  !case2\n  x = 2.5\n  print *, gamma(x)\n\n  !case3\n  x = -3.7\n  print *, gamma(x)\n\n  !case4\n  x = 0.5\n  print *, gamma(x)\n\n  !case5\n  x = 10.0\n  print *, gamma(x)\n\nend program main",
            "result": [
                "8.66045013E-10",
                "9.97050527E-19",
                "3.35510304E+17",
                "1.32940063E-18",
                "3.14270437E-04"
            ]
        },
        "code": "function gamma( x )\n        real, intent(in) :: x\n        real, parameter :: pi = 3.141592653589793e0\n        integer :: k, m, m1\n        real :: gr, r, z\n        real :: g(26)\n        real :: gamma\n        data g/1.0e0,0.5772156649015329, &\n            -0.6558780715202538e0, -0.420026350340952e-1, &\n            0.1665386113822915e0,-.421977345555443e-1, &\n            -.96219715278770e-2, .72189432466630e-2, &\n            -.11651675918591e-2, -.2152416741149e-3, &\n            .1280502823882e-3, -.201348547807e-4, &\n            -.12504934821e-5, .11330272320e-5, &\n            -.2056338417e-6, .61160950e-8, &\n            .50020075e-8, -.11812746e-8, &\n            .1043427e-9, .77823e-11, &\n            -.36968e-11, .51e-12, &\n            -.206e-13, -.54e-14, .14e-14, .1e-15/\nis_integer : &\n        if( x == real( int(x) ) ) then\n          if( x > zero ) then\n            gamma = one\n            m1 = int(x) - 1\n            do k = 2,m1\n              gamma = gamma*real(k)\n            end do\n          else\n            gamma = 1.0e36\n          endif\n        else is_integer\n          if( abs(x) > one ) then\n            z = abs(x)\n            m = int(z)\n            r = one\n            do k = 1,m\n              r = r*(z - real(k))\n            end do\n            z = z - real(m)\n          else\n            z = x\n          endif\n          gr = g(26)\n          do k = 25,1,-1\n            gr = gr*z + g(k)\n          end do\n          gamma = one/(gr*z)\n          if( abs(x) > one ) then\n            gamma = gamma*r\n            if( x < zero ) then\n              gamma = -pi/(x*gamma*sin( pi*x ))\n            endif\n          endif\n        endif is_integer\nend function gamma\n"
    },
    {
        "instruction": [
            "Write a Fortran function called \"trimtext\" that trims any trailing blanks and null characters from a given string. The function takes one input argument of type \"character(len=*)\" which represents the input string. The function returns one output argument of type \"integer\" which represents the index of the last non-blank character in the trimmed string. \n\nTo implement this function, the code iterates through the input string from the beginning, searching for the first null character. Once found, it sets the \"last\" variable to the index of the previous character. Then, it iterates through the string from \"last\" to the beginning, searching for the first non-blank character. Once found, it sets the \"trimtext\" variable to that index. Finally, the function returns the value of \"trimtext\".",
            "Provide a Fortran function named trimtext that trims a given string by removing any leading and trailing white spaces. The function takes a single input argument of type character(len=*), representing the string to be trimmed. The function returns an integer value, indicating the position of the last non-blank character in the trimmed string.",
            "Provide a Fortran function code named \"trimtext\" that trims any trailing whitespace characters from a given string. The function takes one input argument of type character(len=*), representing the string to be trimmed. The output argument is an integer value, indicating the position of the last non-blank character in the trimmed string. The function utilizes the features of Fortran, such as the \"character\" data type and the \"do\" loop, to iterate through the string and identify the last non-blank character. The generated instructions should be written in an imperative tone."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=50) :: string\n\n  !case1\n  string = \"Hello World\"\n  print *, trimtext(string)\n\n  !case2\n  string = \"   Remove   Spaces   \"\n  print *, trimtext(string)\n\n  !case3\n  string = \"NoNullCharacter\"\n  print *, trimtext(string)\n\n  !case4\n  string = \"\"\n  print *, trimtext(string)\n\n  !case5\n  string = \"   \"\n  print *, trimtext(string)\n\nend program main",
            "result": [
                "11",
                "18",
                "15",
                "0",
                "0"
            ]
        },
        "code": "function trimtext (string)\nimplicit none\ninteger::i,size,last\ninteger::len,trimtext\ncharacter(len=1)::char\ncharacter(len=1)::null\ncharacter(len=*)::string\n!\n!     move forward through the string, one character\n!     at a time, looking for first null character\n!\ntrimtext = 0\nsize = len(string)\nnull = char(0)\nlast = size\ndo i = 1, size\n   if (string(i:i) .eq. null) then\n      last = i - 1\n      exit\n   end if\nend do\n!\n!     move backward through the string, one character\n!     at a time, looking for first non-blank character\n!\ndo i = last, 1, -1\n   if (string(i:i) .gt. ' ') then\n      trimtext = i\n      exit\n   end if\nend do\n\nreturn\nend function trimtext\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named hash_index that calculates the index of a key in a hash table. The function takes two input arguments: key (an integer) and n (an integer). It returns one output argument: indx (an integer). \n\nTo use the function, provide the key and the size of the hash table. The function will calculate the index of the key in the hash table by taking the modulus of the key with the size of the hash table. If the calculated index is less than 1, it will be set to 1.\n\nTo use the function, call it with the key and the size of the hash table, and it will return the calculated index.",
            "Create a Fortran function named hash_index that calculates the index of a given key in a hash table. The function takes two input parameters: key (an integer) and n (an integer representing the size of the hash table). The function returns an output parameter named indx (an integer) which is the calculated index. \n\nTo calculate the index, the function uses the modulo operator to find the remainder of key divided by n. Then, it takes the maximum of the calculated index and 1 to ensure that the index is always positive and within the range of the hash table size.\n\nPlease note that the function code provided should be used as the implementation of the hash_index function.",
            "Give me a Fortran function code named hash_index to compute the hash index for a given key and number of elements. The number of input arguments is 2 and the test_data type is [integer, integer]. The number of output arguments is 1 and the test_data type is [integer].\n\nTo compute the hash index, use the mod function to find the remainder of dividing the key by the number of elements. Then, use the max function to ensure the index is at least 1, as Fortran arrays start from 1."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: key, n, indx\n\n  !case1\n  key = 7\n  n = 5\n  indx = hash_index(key, n)\n  print *, indx\n\n  !case2\n  key = 10\n  n = 3\n  indx = hash_index(key, n)\n  print *, indx\n\n  !case3\n  key = 0\n  n = 7\n  indx = hash_index(key, n)\n  print *, indx\n\n  !case4\n  key = -5\n  n = 4\n  indx = hash_index(key, n)\n  print *, indx\n\n  !case5\n  key = 100\n  n = 10\n  indx = hash_index(key, n)\n  print *, indx\n\nend program main",
            "result": [
                "2",
                "1",
                "1",
                "1",
                "1"
            ]
        },
        "code": "function hash_index(key,n) result(indx)\n  integer::key\n  integer::n\n  integer::indx\n\n  indx = mod(key,n)\n  indx = max(indx,1)\nend function\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named prod that calculates the product of a series of numbers. The function takes in two input arguments: a real number (a) and an integer (b). The function returns a real value (prod). The function uses a do loop to multiply each number in the series starting from 'a' and incrementing by 1 until 'b' times.",
            "Create a Fortran function named \"prod\" that calculates the product of consecutive floating numbers. The function takes in two parameters: a real number \"a\" and an integer \"b\". The number of input arguments is 2 and their data types are [real, integer]. The function returns a real number \"prod\", which represents the product of \"b\" consecutive floating numbers starting from \"a\". The number of output arguments is 1 and its data type is [real].",
            "Provide a Fortran function code named prod to calculate the product of a floating number and consecutive integers. The function takes two input arguments, the first argument is a real number, and the second argument is an integer. The function returns a single output argument, which is also a real number. The function iterates through a loop, multiplying the input number by consecutive integers starting from zero up to the specified integer. The final product is stored in the output argument."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real :: a\n  integer :: b\n  \n  !case1\n  a = 2.0\n  b = 3\n  print *, prod(a, b)\n\n  !case2\n  a = -1.5\n  b = 4\n  print *, prod(a, b)\n\n  !case3\n  a = 0.0\n  b = 5\n  print *, prod(a, b)\n\n  !case4\n  a = 1.2\n  b = 0\n  print *, prod(a, b)\n\n  !case5\n  a = 0.5\n  b = 6\n  print *, prod(a, b)\nend program main",
            "result": [
                "24.0000000",
                "0.562500000",
                "0.00000000",
                "1.00000000",
                "162.421875"
            ]
        },
        "code": "function prod(a,b)\n  implicit none\n  real :: a,prod\n  integer :: b,i\n  prod = 1.\n  do i = 0,b-1\n     prod = prod*(a+i)\n  end do\n  return\nend function prod\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named tunneling_ to simulate a tunneling process. The function takes two input arguments: an integer named \"k\" and an integer array named \"state\". The function returns a double precision array named \"new_state\". \nThe function first creates a new array \"new_state\" and sets it equal to the input array \"state\". It then checks if the value at position \"k\" in the \"state\" array is greater than zero. If it is, it decreases the value at position \"k\" in the \"new_state\" array by 1 and increases the value at position \"k+1\" in the \"new_state\" array by 1. If the value at position \"k\" in the \"state\" array is not greater than zero, it sets all elements in the \"new_state\" array to 0.\n",
            "Please provide a Fortran function named \"tunneling_\" that performs a tunneling operation. The function takes two input parameters: an integer value \"k\" and an integer array \"state\". The function returns a double precision array \"new_state\". The purpose of the function is to update the \"new_state\" array based on the values of the \"state\" array. If the element at index \"k\" in the \"state\" array is greater than 0, the corresponding element in the \"new_state\" array is decreased by 1, and the element at index \"k+1\" in the \"new_state\" array is increased by 1. If the element at index \"k\" in the \"state\" array is 0 or less, the \"new_state\" array is set to 0.",
            "Give me a Fortran function code named tunneling_ to simulate a tunneling effect. The function takes two input arguments, k (an integer) and state (an integer array). It returns an output argument named new_state (a double precision array). The function calculates the new state of the system based on the input state and the value of k. If the value of state(k) is greater than 0, it decreases the value of new_state(k) by 1 and increases the value of new_state(k+1) by 1. If the value of state(k) is 0, it sets new_state to 0."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: k\n  integer, allocatable :: state(:)\n  \n  !case1\n  k = 2\n  allocate(state(3))\n  state = [1, 2, 3]\n  print *, tunneling_(k, state)\n  deallocate(state)\n\n  !case2\n  k = 1\n  allocate(state(4))\n  state = [0, 0, 0, 0]\n  print *, tunneling_(k, state)\n  deallocate(state)\n\n  !case3\n  k = 4\n  allocate(state(5))\n  state = [1, 2, 3, 4, 5]\n  print *, tunneling_(k, state)\n  deallocate(state)\n\n  !case4\n  k = 3\n  allocate(state(3))\n  state = [0, 0, 0]\n  print *, tunneling_(k, state)\n  deallocate(state)\n\n  !case5\n  k = 1\n  allocate(state(5))\n  state = [5, 4, 3, 2, 1]\n  print *, tunneling_(k, state)\n  deallocate(state)\nend program main",
            "result": [
                "1.0000000000000000        1.0000000000000000        4.0000000000000000",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000",
                "1.0000000000000000        2.0000000000000000        3.0000000000000000        3.0000000000000000        6.0000000000000000",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000",
                "4.0000000000000000        5.0000000000000000        3.0000000000000000        2.0000000000000000        1.0000000000000000"
            ]
        },
        "code": "    function tunneling_(k,state) result(new_state)\n\n    \n        integer, intent(in) :: k\n        integer, dimension(:), intent(in) :: state\n    \n        double precision, dimension(size(state,1)) :: new_state\n            \n        new_state      = state \n        if(state(k).gt.0) then\n            new_state(k)   = new_state(k) - 1            \n            new_state(k+1) = new_state(k+1) + 1            \n        else\n            new_state = 0\n        end if  \n    \n    end function tunneling_\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named tunneling_f_ to perform a tunneling operation on an array of integers.The number of input arguments is 2 and the test_data types are [integer, integer_array]. The number of output arguments is 1 and the test_data type is [double_precision_array].",
            "Create a Fortran function called \"tunneling_f_\" that takes two input parameters: an integer \"k\" and an integer array \"state\". The function calculates and returns a double precision array \"new_state\". \n\nThe main purpose of this function is to simulate a tunneling process. It checks the values of adjacent elements in the \"state\" array and performs a tunneling operation if the conditions are met. The function updates the \"new_state\" array based on the tunneling process and returns it.\n\nMake sure to handle different cases based on the value of \"k\" and the adjacent elements in the \"state\" array.\n\nNote: The code provided does not include any explicit outputs or instructions on how the \"new_state\" array should be initialized.",
            "Provide a Fortran function named \"tunneling_f_\" that performs a tunneling operation on an input state array. The function takes two input parameters: \"k\" (an integer) and \"state\" (an integer array). It returns a new state array of double precision.\n\nIn the function, the new state array is initialized as a copy of the input state array. Then, based on the value of \"k\" and the neighboring elements in the state array, the function performs the tunneling operation. If the element at index \"k\" is 1 and the element at index \"k+1\" is 0, the function subtracts 1 from the element at index \"k\" and adds 1 to the element at index \"k+1\" in the new state array. If \"k\" is equal to the size of the state array, the function checks if the element at index \"k\" is 1 and the element at index \"k-1\" is 0. If this condition is met, it performs the same tunneling operation.\n\nIf none of the tunneling conditions are met, the new state array is set to 0.\n\nPlease note that the input state array is modified by the function, and the new state array is returned as the result."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: k\n  integer, allocatable :: state(:)\n  double precision, allocatable :: new_state(:)\n  \n  !case1\n  k=2\n  allocate(state(3))\n  allocate(new_state(3))\n  state = [1, 1, 0]\n  new_state = tunneling_f_(k, state)\n  print *, new_state\n  deallocate(state)\n  deallocate(new_state)\n\n  !case2\n  k=4\n  allocate(state(5))\n  allocate(new_state(5))\n  state = [0, 1, 1, 0, 1]\n  new_state = tunneling_f_(k, state)\n  print *, new_state\n  deallocate(state)\n  deallocate(new_state)\n\n  !case3\n  k=1\n  allocate(state(3))\n  allocate(new_state(3))\n  state = [1, 0, 1]\n  new_state = tunneling_f_(k, state)\n  print *, new_state\n  deallocate(state)\n  deallocate(new_state)\n\n  !case4\n  k=3\n  allocate(state(4))\n  allocate(new_state(4))\n  state = [1, 1, 1, 1]\n  new_state = tunneling_f_(k, state)\n  print *, new_state\n  deallocate(state)\n  deallocate(new_state)\n\n  !case5\n  k=2\n  allocate(state(3))\n  allocate(new_state(3))\n  state = [0, 0, 1]\n  new_state = tunneling_f_(k, state)\n  print *, new_state\n  deallocate(state)\n  deallocate(new_state)\nend program main",
            "result": [
                "1.0000000000000000        0.0000000000000000        1.0000000000000000",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000",
                "0.0000000000000000        1.0000000000000000        1.0000000000000000",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000"
            ]
        },
        "code": "    function tunneling_f_(k,state) result(new_state)\n\n    \n        integer, intent(in) :: k\n        integer, dimension(:), intent(in) :: state\n    \n        double precision, dimension(size(state,1)) :: new_state\n    \n        new_state      = state \n        if(k.lt.size(state,1))then\n            if(state(k).eq.1 .and. state(k+1).eq.0) then\n                new_state(k)   = new_state(k) - 1            \n                new_state(k+1) = new_state(k+1) + 1\n            else\n                new_state = 0\n            end if  \n        else\n!            write(*,*) 'mw,k',k,state(k),state(k-1)\n            if(state(k).eq.1 .and. state(k-1).eq.0) then\n                new_state(k)   = new_state(k) - 1            \n                new_state(k-1) = new_state(k-1) + 1\n            else\n                new_state = 0\n            end if  \n        end if\n            \n\n    end function tunneling_f_\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named a_dagger_int that takes an integer k and an integer array state as input. The function computes a new array called new_state, which is a copy of the input state array with the element at index k incremented by 1. The new_state array is then multiplied element-wise by the square root of the incremented element. The number of input arguments is 2, with types integer and integer array, respectively. The number of output arguments is 1, with type double precision array.",
            "Give me a Fortran function code named a_dagger_int that takes an integer value and an integer array as input. The function calculates a new array by incrementing the element at index k by 1 and multiplying it with the square root of the previous value at index k. The size of the input array remains the same. The function returns the new array.\n\nThe number of input arguments is 2 and the data type is [integer, integer array]. The number of output arguments is 1 and the data type is [double precision array].",
            "Write a Fortran function called a_dagger_int that takes in an integer value k and an integer array state as input. The function returns a double precision array called new_state. The function calculates the value of new_state by copying the elements of the input state array, incrementing the element at index k by 1, and then multiplying the entire array by the square root of the updated element at index k. The function updates and returns the new_state array. The number of input arguments is 2 and their types are [integer, integer array]. The number of output arguments is 1 and its type is [double precision array]."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: k, n\n  integer, allocatable :: state(:)\n  \n  !case1\n  k = 2\n  n = 4\n  allocate(state(n))\n  state = [1, 0, 1, 0]\n  print *, a_dagger_int(k, state)\n  deallocate(state)\n\n  !case2\n  k = 3\n  n = 5\n  allocate(state(n))\n  state = [0, 1, 0, 1, 0]\n  print *, a_dagger_int(k, state)\n  deallocate(state)\n\n  !case3\n  k = 1\n  n = 3\n  allocate(state(n))\n  state = [2, 1, 0]\n  print *, a_dagger_int(k, state)\n  deallocate(state)\n\n  !case4\n  k = 4\n  n = 6\n  allocate(state(n))\n  state = [1, 0, 0, 1, 0, 1]\n  print *, a_dagger_int(k, state)\n  deallocate(state)\n\n  !case5\n  k = 2\n  n = 4\n  allocate(state(n))\n  state = [0, 1, 1, 0]\n  print *, a_dagger_int(k, state)\n  deallocate(state)\nend program main",
            "result": [
                "1.0000000000000000        1.0000000000000000        1.0000000000000000        0.0000000000000000",
                "0.0000000000000000        1.0000000000000000        1.0000000000000000        1.0000000000000000        0.0000000000000000",
                "5.1961524227066320        1.7320508075688772        0.0000000000000000",
                "1.4142135623730951        0.0000000000000000        0.0000000000000000        2.8284271247461903        0.0000000000000000        1.4142135623730951",
                "0.0000000000000000        2.8284271247461903        1.4142135623730951        0.0000000000000000"
            ]
        },
        "code": "    function a_dagger_int(k,state) result(new_state)\n\n    \n        integer, intent(in) :: k\n        integer, dimension(:), intent(in) :: state\n    \n        double precision, dimension(size(state,1)) :: new_state\n    \n        !write(*,*) k,new_state\n        new_state    = state \n        new_state(k) = new_state(k) + 1\n        new_state    = sqrt(1.0*new_state(k))*new_state\n               !write(*,*) k,new_state\n    end function a_dagger_int\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named a_int that operates on an integer array to perform a specific mathematical operation. The function takes two input parameters - an integer \"k\" and an integer array \"state\", and returns a double precision array \"new_state\". The code calculates the new_state array based on the values in the state array and the value of k using a mathematical formula. The code follows the imperative programming style and makes use of Fortran language features like intent(in) for input parameters and dimension statements for array declarations.",
            "Write a Fortran function named a_int that computes the result of applying the operator a_dagger to a quantum state. The function takes two input parameters: an integer k and an integer array state. The output is a double precision array new_state. The function performs the following steps: \n1. Copies the state array to the new_state array.\n2. If the element of state at index k is greater than 0, subtracts 1 from new_state at index k and multiplies the entire new_state array by the square root of (1.0 * new_state at index k).\n3. If the element of state at index k is not greater than 0, sets new_state to 0.\n",
            "Write a Fortran function named a_int that takes two input arguments: an integer k and an integer array named state. The function calculates the square root of the element at index k in the state array and multiplies it by the whole array. The result is stored in a double precision array named new_state. If the element at index k in the state array is greater than zero, it subtracts 1 from it and performs the calculation. If the element at index k is zero or negative, the new_state array is set to zero. The function returns the new_state array as the output."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: k, n\n  integer, allocatable :: state(:)\n  \n  !case1\n  k = 2\n  n = 3\n  allocate(state(n))\n  state = [1, 0, 1]\n  print *, a_int(k, state)\n  deallocate(state)\n\n  !case2\n  k = 1\n  n = 4\n  allocate(state(n))\n  state = [1, 0, 0, 0]\n  print *, a_int(k, state)\n  deallocate(state)\n\n  !case3\n  k = 3\n  n = 5\n  allocate(state(n))\n  state = [0, 1, 0, 1, 0]\n  print *, a_int(k, state)\n  deallocate(state)\n\n  !case4\n  k = 4\n  n = 6\n  allocate(state(n))\n  state = [1, 1, 1, 1, 1, 1]\n  print *, a_int(k, state)\n  deallocate(state)\n\n  !case5\n  k = 2\n  n = 7\n  allocate(state(n))\n  state = [0, 0, 0, 0, 0, 0, 0]\n  print *, a_int(k, state)\n  deallocate(state)\nend program main",
            "result": [
                "0.0000000000000000        0.0000000000000000        0.0000000000000000",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000"
            ]
        },
        "code": "    function a_int(k,state) result(new_state)\n    !a_dagger |n> = sqrt(n+1) |n+1>\n        implicit none\n        integer, intent(in) :: k\n        integer, dimension(:), intent(in) :: state\n    \n        double precision, dimension(size(state,1)) :: new_state\n\n        new_state    = state \n!        write(*,*) k,new_state\n        if(state(k).gt.0) then\n            new_state(k) = new_state(k) - 1\n            new_state    = sqrt(1.0*new_state(k))*new_state\n        else\n            new_state =0\n        end if\n !       write(*,*) k,new_state\n    end function a_int\n"
    },
    {
        "instruction": [
            "Write a Fortran function named norm2 that calculates the Euclidean norm of a vector. The function takes two input parameters: an integer n and a double precision array x of size n. It returns a double precision value norm2, which represents the calculated norm. To use this function, provide the size of the vector and the vector itself as input arguments. The norm2 function iterates over the elements of the vector, squares each element, sums them up, takes the square root of the sum, and finally divides it by the number of elements in the vector.",
            "Give me a Fortran function code named norm2 to calculate the Euclidean norm of a vector. The function takes two input arguments: an integer n and a double precision array x of size n. The function returns a double precision value norm2.",
            "Please provide a Fortran function code named norm2 that calculates the Euclidean norm of a vector. The function takes an integer input argument \"n\" and a double precision array input argument \"x\" of size \"n\". The function returns a double precision value \"norm2\" as the output. The norm2 function iterates over the elements of the input array \"x\", squares each element, sums them up, takes the square root of the sum, and divides it by the size of the array \"n\"."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n\n  real*8, allocatable :: x(:)\n  \n  !case1\n  n=3\n  allocate(x(n))\n  x = [1.0, 2.0, 3.0]\n  print *, norm2(n, x)\n  deallocate(x)\n\n  !case2\n  n=4\n  allocate(x(n))\n  x = [0.0, 0.0, 0.0, 0.0]\n  print *, norm2(n, x)\n  deallocate(x)\n\n  !case3\n  n=5\n  allocate(x(n))\n  x = [-1.0, -2.0, -3.0, -4.0, -5.0]\n  print *, norm2(n, x)\n  deallocate(x)\n\n  !case4\n  n=2\n  allocate(x(n))\n  x = [4.25, -2.5]\n  print *, norm2(n, x)\n  deallocate(x)\n\n  !case5\n  n=6\n  allocate(x(n))\n  x = [1e-6, 2e-6, 3e-6, 4e-6, 5e-6, 6e-6]\n  print *, norm2(n, x)\n  deallocate(x)\nend program main",
            "result": [
                "1.2472191289246470",
                "0.0000000000000000",
                "1.4832396974191326",
                "2.4653853654145026",
                "1.5898986848768329E-006"
            ]
        },
        "code": "  function norm2 (n,x )\n    ! description :\n    ! calcul de la norme euclidienne d'un vecteur.\n    implicit none\n    ! inputs :\n    integer, intent(in)                                     :: n\n    double precision, dimension(n), intent(in)              :: x\n    ! outputs :                                           \n    double precision                                        :: norm2\n                                                            \n    ! variables :                                           \n    integer                                                 :: i\n    \n    ! calcul de la norme euclidienne\n    norm2 = 0.0d0\n    do i = 1, n\n      norm2 = norm2 + x(i)*x(i)\n    enddo\n    norm2 = sqrt(norm2)/dble(n)\n    \n    return\n  end function norm2 \n"
    },
    {
        "instruction": [
            "Write a Fortran function code named t1 that calculates the unit vector between two 3-dimensional points. The function takes two input arguments, r_a and r_b, both of type double precision and dimension 3. The function returns an output argument named var, also of type double precision and dimension 3.\n\nTo calculate the unit vector, the function performs the following steps:\n1. Declares variables: r, r2 as double precision and dr as double precision and dimension 3.\n2. Computes the difference between r_b and r_a and assigns it to dr.\n3. Computes the dot product of dr with itself and assigns it to r2.\n4. Calculates the square root of r2 and assigns it to r.\n5. Divides dr by the product of r, r2, and assigns the result to var.\n\nThe t1 function computes the unit vector between two 3-dimensional points, given the coordinates of the points.",
            "Create a Fortran function named t1 that takes two arrays as input parameters and calculates another array as the output. The input arrays should be of type double precision and have a dimension of 3. The output array should also have a dimension of 3 and be of type double precision. \n\nThe function calculates the difference between the elements of the second input array and the first input array and stores it in a temporary array called dr. It then calculates the dot product of dr and dr, storing the result in r2. Next, it calculates the square root of r2 and stores it in r. Finally, the function divides each element of dr by the product of r, r2, and stores the result in the output array var.\n\nEnsure that the Fortran code complies with these requirements and follows the imperative tone.",
            "Give me a Fortran function code named t1 that calculates the normalized displacement vector between two vectors. The number of input arguments is 2, both of which are double precision arrays of size 3. The output argument is also a double precision array of size 3. The function uses the dot product and square root functions from Fortran to calculate the magnitude of the displacement vector and then divides the displacement vector by the magnitude to obtain the normalized displacement vector."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  double precision :: r_a(3), r_b(3)\n  double precision, dimension(3) :: var\n  \n  !case1\n  r_a = [1.0, 2.0, 3.0]\n  r_b = [4.0, 5.0, 6.0]\n  var = t1(r_a, r_b)\n  print *, var\n\n  !case2\n  r_a = [0.0, 0.0, 0.0]\n  r_b = [1.0, 1.0, 1.0]\n  var = t1(r_a, r_b)\n  print *, var\n\n  !case3\n  r_a = [-2.0, -3.0, -4.0]\n  r_b = [0.0, 0.0, 0.0]\n  var = t1(r_a, r_b)\n  print *, var\n\n  !case4\n  r_a = [2.5, -1.8, 3.2]\n  r_b = [-0.4, 2.7, -1.3]\n  var = t1(r_a, r_b)\n  print *, var\n\n  !case5\n  r_a = [-0.1, 0.2, -0.3]\n  r_b = [0.5, -0.8, 1.1]\n  var = t1(r_a, r_b)\n  print *, var\nend program main",
            "result": [
                "2.1383343303319473E-002   2.1383343303319473E-002   2.1383343303319473E-002",
                "0.19245008972987526       0.19245008972987526       0.19245008972987526",
                "1.2806575046693233E-002   1.9209862570039850E-002   2.5613150093386466E-002",
                "-8.4781579653676661E-003   1.3155762333013807E-002  -1.3155762333013807E-002",
                "9.9184566623210638E-002 -0.16530761309141384       0.23143066079125474"
            ]
        },
        "code": "function t1(r_a, r_b) result(var)\n  double precision, intent(in), dimension(3) :: r_a\n  double precision, intent(in), dimension(3) :: r_b\n  double precision, dimension(3) :: var\n\n  double precision :: r, r2\n  double precision, dimension(3) :: dr\n\n  dr = r_b - r_a\n  r2 = dot_product(dr, dr)\n  r = sqrt(r2)\n  var = dr / (r*r2)\n\nend function t1\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named t2 that calculates the various elements of a tensor based on the input vectors r_a and r_b. The input parameters are two 3-dimensional floating-point arrays, r_a and r_b. The output parameter is a 6-dimensional floating-point array, var. \n\nFirst, the function calculates the difference between r_b and r_a and stores it in the dr array. Then, it calculates the squared magnitude of dr and stores it in the r2 variable. Next, it calculates the magnitude of dr and stores it in the r variable.\n\nAfter that, the function calculates the elements of the tensor using the formulas provided in the code. The elements are stored in the var array in the following order: xx, xy, xz, yy, yz, zz.\n\nFinally, the function normalizes the var array by dividing each element by the product of r, r2, and r2.\n\nNote: The code assumes that the input and output arrays have already been declared and allocated appropriately.",
            "Write a Fortran function named \"t2\" that calculates the tensor components for a given displacement vector between two points. The function takes two input arguments of type double precision arrays with dimensions (3) each. It returns an output array of type double precision with dimensions (6). The function computes the tensor components based on the displacement vector and stores the results in the output array. The function uses the dot product and square root functions to calculate the magnitude of the displacement vector and then performs mathematical operations on the components of the displacement vector to compute the tensor components. Finally, the function normalizes the tensor components by dividing them by the magnitude of the displacement vector raised to the power of 4.",
            "Write a Fortran function named t2 that calculates the tensor components for a given displacement vector between two points in three-dimensional space. The number of input arguments is 2 and the data type is double precision arrays of size 3. The number of output arguments is 1 and the data type is a double precision array of size 6.\n\nIn the function, calculate the displacement vector by subtracting the input arrays. Then, compute the square of the magnitude of the displacement vector. Next, compute the individual tensor components using the displacement vector. Finally, normalize the tensor components by dividing them by the product of the displacement magnitude and its square.\n\nUse the dot_product function to calculate the dot product of two arrays and the sqrt function to compute the square root. Divide the final tensor components by the normalization factor.\n\nThe function should be defined as follows:\nfunction t2(r_a, r_b) result(var)\n  double precision, intent(in), dimension(3) :: r_a\n  double precision, intent(in), dimension(3) :: r_b\n  double precision, dimension(6) :: var\n\n  ! Calculate displacement vector\n  double precision :: r, r2\n  double precision, dimension(3) :: dr\n  dr = r_b - r_a\n  \n  ! Calculate displacement magnitude\n  r2 = dot_product(dr, dr)\n  r = sqrt(r2)\n\n  ! Compute tensor components\n  var(1) = 3 * dr(1) * dr(1) - r2   ! xx\n  var(2) = 3 * dr(1) * dr(2)        ! xy\n  var(3) = 3 * dr(1) * dr(3)        ! xz\n  var(4) = 3 * dr(2) * dr(2) - r2   ! yy\n  var(5) = 3 * dr(2) * dr(3)        ! yz\n  var(6) = 3 * dr(3) * dr(3) - r2   ! zz\n\n  ! Normalize tensor components\n  var = var / (r*r2*r2)\n\nend function t2"
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  double precision :: r_a(3), r_b(3)\n  double precision, dimension(6) :: var\n  \n  !case1\n  r_a = [1.0, 2.0, 3.0]\n  r_b = [4.0, 5.0, 6.0]\n  var = t2(r_a, r_b)\n  print *, var\n\n  !case2\n  r_a = [-1.0, -2.5, 3.7]\n  r_b = [0.0, 0.0, 0.0]\n  var = t2(r_a, r_b)\n  print *, var\n\n  !case3\n  r_a = [2.5, 3.2, -1.9]\n  r_b = [-6.7, 8.9, -3.1]\n  var = t2(r_a, r_b)\n  print *, var\n\n  !case4\n  r_a = [0.0, 0.0, 0.0]\n  r_b = [1.0, 1.0, 1.0]\n  var = t2(r_a, r_b)\n  print *, var\n\n  !case5\n  r_a = [0.123, -0.456, 0.789]\n  r_b = [0.987, 0.654, -0.321]\n  var = t2(r_a, r_b)\n  print *, var\n\nend program main",
            "result": [
                "0.0000000000000000        7.1277811011064909E-003   7.1277811011064909E-003   0.0000000000000000        7.1277811011064909E-003   0.0000000000000000",
                "-8.9408896669083103E-003   3.7378300547872625E-003  -5.5319885523785993E-003  -1.0914465518550595E-003  -1.3829971380946498E-002   1.0032336218763371E-002",
                "8.8414049559224991E-004  -1.0276540186159272E-003   2.1634821783897399E-004  -1.3783058827354847E-004  -1.3404182330456718E-004  -7.4630990731870130E-004",
                "0.0000000000000000       0.19245008972987526       0.19245008972987526        0.0000000000000000       0.19245008972987526        0.0000000000000000",
                "-5.2579240410647911E-002  0.15576146632630650      -0.15576146632630650        2.6289620205323955E-002 -0.20011021779893462        2.6289620205323955E-002"
            ]
        },
        "code": "function t2(r_a, r_b) result(var)\n  double precision, intent(in), dimension(3) :: r_a\n  double precision, intent(in), dimension(3) :: r_b\n  double precision, dimension(6) :: var\n\n  double precision :: r, r2\n  double precision, dimension(3) :: dr\n\n  dr = r_b - r_a\n  r2 = dot_product(dr, dr)\n  r = sqrt(r2)\n\n  var(1) = 3 * dr(1) * dr(1) - r2   ! xx\n  var(2) = 3 * dr(1) * dr(2)        ! xy\n  var(3) = 3 * dr(1) * dr(3)        ! xz\n  var(4) = 3 * dr(2) * dr(2) - r2   ! yy\n  var(5) = 3 * dr(2) * dr(3)        ! yz\n  var(6) = 3 * dr(3) * dr(3) - r2   ! zz\n\n  var = var / (r*r2*r2)\n\nend function t2\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named string_count_substring that counts the number of occurrences of a substring within a given string. The function takes two input arguments: a string and a substring, both of type character. The function returns an output argument of type integer, representing the count of occurrences.",
            "Provide a Fortran function code named string_count_substring that counts the number of occurrences of a given substring within a given string. The function takes two input arguments: a string and a substring, both of type character. The function returns one output argument of type integer, representing the count of occurrences. Use the index function to find the starting position of the substring within the string. Initialize the count to 0 and start to 0. Use a do loop to iterate until no more occurrences are found. Increment the count by 1 each time and exit the loop when no more occurrences are found.",
            "Provide a Fortran function named string_count_substring to count the number of occurrences of a substring within a given string. The function takes two input parameters, both of type character. The first parameter is the main string, and the second parameter is the substring to be counted. The function returns an output parameter of type integer, which represents the count of the occurrences of the substring within the main string."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=100) :: string\n  character(len=10) :: substr\n\n  !case1\n  string = \"abcdefg\"\n  substr = \"c\"\n  print *, string_count_substring(string, substr)\n\n  !case2\n  string = \"aaaabbbbccccdddd\"\n  substr = \"bb\"\n  print *, string_count_substring(string, substr)\n\n  !case3\n  string = \"Hello, World!\"\n  substr = \"o\"\n  print *, string_count_substring(string, substr)\n\n  !case4\n  string = \"fortran\"\n  substr = \"FOR\"\n  print *, string_count_substring(string, substr)\n\n  !case5\n  string = \"aaaaaa\"\n  substr = \"aa\"\n  print *, string_count_substring(string, substr)\n\nend program main",
            "result": [
                "1",
                "1",
                "1",
                "1",
                "2"
            ]
        },
        "code": "function string_count_substring( string, substr ) result( count )\n    character(len=*)           :: string\n    character(len=*)           :: substr\n\n    integer                    :: start\n    integer                    :: count\n\n    count  = 0\n    start  = 0\n    do\n        start = index( string(start+1:), substr )\n        count = count + 1\n        if ( start == 0 ) exit\n    enddo\nend function string_count_substring\n"
    },
    {
        "instruction": [
            "Write a Fortran function named getstoragesize that calculates the size of an array based on specified minimum size, old size, and new size. The function takes in three input arguments of type integer, namely minsize, oldsize, and newsize, and returns an output argument of type integer, arraysize.\n\nTo understand the function, it first checks if the old size is between the new size and twice the new size. If it is, then the array size remains the same as the old size. Otherwise, it calculates an overallocation value based on the new size. If the new size is less than 9, the overallocation is incremented by 3, otherwise by 6. The array size is then calculated as the sum of the new size and the overallocation.\n\nFinally, the function checks if the calculated array size is smaller than the specified minimum size. If it is, then the array size is set to the maximum value between the old size and the minimum size.\n\nYour task is to provide detailed instructions for implementing the getstoragesize function, specifying the number and type of input and output parameters, and highlighting the imperative tone.",
            "Write a Fortran function named getstoragesize that calculates the size of an array based on the minimum size, old size, and new size provided as input arguments. The function takes 3 integer input arguments (minsize, oldsize, newsize) and returns an integer output argument (arraysize). The function determines the appropriate size for the array by checking if the old size is within a certain range of the new size. If it is, the function sets the array size to the old size. Otherwise, it calculates an overallocation value based on the new size and adds it to the new size to get the final array size. If the final array size is less than the minimum size, the function sets the array size to the maximum value between the old size and the minimum size.",
            "Write a Fortran function code named getstoragesize that calculates the required size of an array based on certain conditions. The function takes three input arguments, all integers: minsize, oldsize, and newsize. It returns a single integer output argument, arraysize. \n\nTo summarize the function's purpose: \n- If the oldsize is greater than or equal to the newsize and less than or equal to twice the newsize, the arraysize is set to oldsize.\n- Otherwise, the arraysize is calculated based on the newsize and some additional allocation. If newsize is less than 9, the additional allocation is increased by 3; otherwise, it is increased by 6. The arraysize is then set to newsize plus the additional allocation.\n- Finally, if the resulting arraysize is less than the minsize, it is set to the maximum of oldsize and minsize.\n\nPlease note that the instruction uses the imperative tone and specifies the number and data types of the input and output parameters, as well as the name of the function."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: minsize, oldsize, newsize, arraysize\n  \n  !case1\n  minsize = 10\n  oldsize = 5\n  newsize = 15\n  arraysize = getstoragesize(minsize, oldsize, newsize)\n  print *, arraysize\n\n  !case2\n  minsize = 20\n  oldsize = 30\n  newsize = 25\n  arraysize = getstoragesize(minsize, oldsize, newsize)\n  print *, arraysize\n\n  !case3\n  minsize = 100\n  oldsize = 75\n  newsize = 90\n  arraysize = getstoragesize(minsize, oldsize, newsize)\n  print *, arraysize\n\n  !case4\n  minsize = 50\n  oldsize = 60\n  newsize = 55\n  arraysize = getstoragesize(minsize, oldsize, newsize)\n  print *, arraysize\n\n  !case5\n  minsize = 200\n  oldsize = 180\n  newsize = 210\n  arraysize = getstoragesize(minsize, oldsize, newsize)\n  print *, arraysize\n\nend program main",
            "result": [
                "22",
                "30",
                "107",
                "60",
                "242"
            ]
        },
        "code": "  function getstoragesize(minsize, oldsize, newsize) result(arraysize)\n    integer, intent(in) :: minsize, oldsize, newsize\n    integer :: arraysize\n\n    integer :: overalloc\n    \n    if (oldsize >= newsize .and. oldsize <= 2 * newsize) then\n      arraysize = oldsize\n    else\n      overalloc = newsize / 8\n      if (newsize < 9) then\n        overalloc = overalloc + 3\n      else\n        overalloc = overalloc + 6\n      end if\n      arraysize = newsize + overalloc\n      if (arraysize < minsize) then\n        arraysize = max(oldsize, minsize)\n      end if\n    end if\n\n  end function getstoragesize\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named cell_index that calculates the index of a cell based on the provided input parameter. The input parameter is an integer named \"cin\" (intent(in)). The function returns an integer named \"indx\" as the result. \n\nTo determine the index, the code checks the value of \"cin\" against different thresholds for different cell types (ntetra, npyra, nprizm, and nhexa). Depending on the value of \"cin\", the code assigns a corresponding index value to \"indx\". \n\nEnsure that the input parameter \"cin\" is an integer, and the output result \"indx\" is also an integer.",
            "Provide a Fortran function named cell_index that takes an integer input parameter cin. The function calculates and returns an integer output parameter indx. The function determines the index value based on the value of cin using conditional statements. The function checks the value of cin against different thresholds to determine the appropriate formula to calculate the index. The function uses if-elseif-endif statements to handle different ranges of values for cin. The calculated index value is stored in the variable indx, which is returned as the output of the function.",
            "Write a Fortran function named \"cell_index\" that takes an integer input parameter \"cin\". This function calculates and returns the index \"indx\" based on the value of \"cin\". The input parameter \"cin\" represents the cell number. \n\nThe function uses an if-elseif block to determine the value of \"indx\" based on the range of \"cin\". The calculated index \"indx\" is then returned as the output of the function. \n\nThe function has one input parameter of type integer and one output parameter of type integer."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: cin, indx\n\n  !case1\n  cin = 10\n  indx = cell_index(cin)\n  print *, indx\n  \n  !case2\n  cin = 20\n  indx = cell_index(cin)\n  print *, indx\n  \n  !case3\n  cin = 35\n  indx = cell_index(cin)\n  print *, indx\n  \n  !case4\n  cin = 50\n  indx = cell_index(cin)\n  print *, indx\n  \n  !case5\n  cin = 65\n  indx = cell_index(cin)\n  print *, indx\nend program main",
            "result": [
                "32764",
                "10938",
                "10938",
                "10938",
                "10938"
            ]
        },
        "code": "    function cell_index(cin) result (indx)\n      integer, intent(in) :: cin\n      integer :: indx\n      if (cin <= ntetra) then\n         indx=4*(cin-1)\n      elseif (cin <= ntetra+npyra) then\n         indx=5*(cin-(ntetra)-1)+4*ntetra\n      elseif (cin <= ntetra+npyra+nprizm) then\n         indx=5*(cin-(ntetra+npyra)-1)+4*ntetra+5*npyra\n      elseif (cin <= ntetra+npyra+nprizm+nhexa) then\n         indx=6*(cin-(ntetra+npyra+nprizm)-1)+4*ntetra+5*npyra+5*nprizm\n      endif\n    end function cell_index    \n"
    },
    {
        "instruction": [
            "Write a Fortran function code named pr_findtimeindex to find the index of the next stopping time in an array of time points. The function takes in four input parameters: an integer timepointscount, an array of double precision timeseriespoints, a double precision currenttime, and a double precision maximumtime. The function returns an integer index indicating the position of the next stopping time in the timeseriespoints array.\n\nTo understand the code, the function iterates through the timeseriespoints array and checks if each time point is greater than the currenttime and less than or equal to the maximumtime. If a stopping time is found, the function updates the index variable and exits the loop. If no stopping time is found or if the maximumtime is less than the stopping time found, the function returns -1.\n\nTo use the function, pass the appropriate values for the input parameters, and the function will return the index of the next stopping time or -1 if none is found.",
            "Please provide a Fortran function code named pr_findtimeindex that finds the index in an array of time series points for the next stopping time after the current time value. The function takes 4 input parameters: timepointscount (integer), timeseriespoints (array of double precision), currenttime (double precision), and maximumtime (double precision). The function returns an integer index. If no stopping time is found or if the maximum time is less than the stopping time found in the array, the function returns -1.\n\nTo provide the instruction, please follow the requirements mentioned above.",
            "Create a Fortran function named pr_findtimeindex that takes in four input parameters: an integer timepointscount, an array of double precision values called timeseriespoints, and two double precision values called currenttime and maximumtime. The function is responsible for finding the index in the timeseriespoints array of the next stopping time after the currenttime value. If no stopping time is found or if the maximumtime is less than the stopping time found in the timeseriespoints array, the function returns -1. The function should return an integer value called index as the output parameter."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: timepointscount, index\n  double precision, allocatable :: timeseriespoints(:)\n  double precision :: currenttime, maximumtime\n\n  !case1\n  timepointscount = 5\n  allocate(timeseriespoints(timepointscount))\n  timeseriespoints = [1.0, 2.0, 3.0, 4.0, 5.0]\n  currenttime = 0.5\n  maximumtime = 4.0\n  index = pr_findtimeindex(timeseriespoints, currenttime, maximumtime, timepointscount)\n  print *, index\n  deallocate(timeseriespoints)\n\n  !case2\n  timepointscount = 3\n  allocate(timeseriespoints(timepointscount))\n  timeseriespoints = [0.0, 0.0, 0.0]\n  currenttime = 1.0\n  maximumtime = 5.0\n  index = pr_findtimeindex(timeseriespoints, currenttime, maximumtime, timepointscount)\n  print *, index\n  deallocate(timeseriespoints)\n\n  !case3\n  timepointscount = 5\n  allocate(timeseriespoints(timepointscount))\n  timeseriespoints = [1.5, 2.5, 3.5, 4.5, 5.5]\n  currenttime = 2.0\n  maximumtime = 4.0\n  index = pr_findtimeindex(timeseriespoints, currenttime, maximumtime, timepointscount)\n  print *, index\n  deallocate(timeseriespoints)\n\n  !case4\n  timepointscount = 0\n  allocate(timeseriespoints(timepointscount))\n  currenttime = 1.0\n  maximumtime = 5.0\n  index = pr_findtimeindex(timeseriespoints, currenttime, maximumtime, timepointscount)\n  print *, index\n  deallocate(timeseriespoints)\n\n  !case5\n  timepointscount = 4\n  allocate(timeseriespoints(timepointscount))\n  timeseriespoints = [1.0, 2.0, 3.0, 4.0]\n  currenttime = 3.5\n  maximumtime = 10.0\n  index = pr_findtimeindex(timeseriespoints, currenttime, maximumtime, timepointscount)\n  print *, index\n  deallocate(timeseriespoints)\n  \nend program main",
            "result": [
                "1",
                "-1",
                "2",
                "-1",
                "4"
            ]
        },
        "code": "function pr_findtimeindex(timeseriespoints, currenttime, maximumtime, timepointscount) result(index)\n!***************************************************************************************************************\n! find the index in the timeseriespoints array of the next stopping time after the currenttime value. \n! return -1 if none is found or if maximumtime is less than the stopping time found in the timeseriespoints \n! array.\n!***************************************************************************************************************\n!\n! specifications\n!---------------------------------------------------------------------------------------------------------------\n  implicit none\n  integer,intent(in) :: timepointscount\n  doubleprecision,dimension(timepointscount),intent(in) :: timeseriespoints\n  doubleprecision,intent(in) :: currenttime, maximumtime\n  integer :: index, n\n  doubleprecision :: t\n!---------------------------------------------------------------------------------------------------------------\n  index = -1\n  \n  if(timepointscount .lt. 1) return\n  do n = 1, timepointscount\n      if((timeseriespoints(n) .gt. currenttime) .and. (timeseriespoints(n) .le. maximumtime)) then\n          index = n\n          return\n      end if\n  end do\n\nend function pr_findtimeindex\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named outer3d that calculates the outer product of two 3-dimensional vectors. The function takes two double precision 3-dimensional input vectors, ri and rj, and returns a 3x3 double precision matrix as the output.",
            "Write a Fortran function named outer3d that calculates the outer product of two 3-dimensional vectors. The function takes two input arguments of type double precision arrays with dimensions (3) and is named ri and rj. The function returns a 3x3 double precision array named outer3d as the output.",
            "Provide a Fortran function code named outer3d that calculates the outer product of two 3-dimensional arrays. The function takes two input arrays of type double precision with dimensions (3) and returns an output array of type double precision with dimensions (3,3). The input arrays are passed by reference using the intent(in) keyword. The function uses the spread function to replicate the elements of the input arrays and then performs element-wise multiplication to compute the outer product."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  double precision :: ri(3), rj(3)\n  double precision, dimension(3,3) :: result\n  \n  !case1\n  ri = [1.0, 2.0, 3.0]\n  rj = [4.0, 5.0, 6.0]\n  result = outer3d(ri, rj)\n  print *, result\n\n  !case2\n  ri = [0.0, 0.0, 0.0]\n  rj = [1.0, 1.0, 1.0]\n  result = outer3d(ri, rj)\n  print *, result\n\n  !case3\n  ri = [-1.0, -2.0, -3.0]\n  rj = [0.5, 0.5, 0.5]\n  result = outer3d(ri, rj)\n  print *, result\n\n  !case4\n  ri = [2.0, 2.0, 2.0]\n  rj = [2.0, 2.0, 2.0]\n  result = outer3d(ri, rj)\n  print *, result\n\n  !case5\n  ri = [1.0, 0.0, -1.0]\n  rj = [0.0, 1.0, 0.0]\n  result = outer3d(ri, rj)\n  print *, result\nend program main",
            "result": [
                "4.0000000000000000        8.0000000000000000        12.000000000000000        5.0000000000000000        10.000000000000000        15.000000000000000        6.0000000000000000        12.000000000000000        18.000000000000000",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000",
                "-0.50000000000000000       -1.0000000000000000       -1.5000000000000000      -0.50000000000000000       -1.0000000000000000       -1.5000000000000000      -0.50000000000000000       -1.0000000000000000       -1.5000000000000000",
                "4.0000000000000000        4.0000000000000000        4.0000000000000000        4.0000000000000000        4.0000000000000000        4.0000000000000000        4.0000000000000000        4.0000000000000000        4.0000000000000000",
                "0.0000000000000000        0.0000000000000000       -0.0000000000000000        1.0000000000000000        0.0000000000000000       -1.0000000000000000        0.0000000000000000        0.0000000000000000       -0.0000000000000000"
            ]
        },
        "code": "function outer3d(ri, rj)\n\n    implicit none\n\n    double precision, dimension(3), intent(in) :: ri, rj\n    double precision, dimension(3,3) :: outer3d\n\n    !write (*,*) \"ri\", ri(:3)\n    ! write (*,*) \"rj\", rj(:3)\n\n    outer3d(:3,:3) = spread(ri(:3), dim=2, ncopies=3) * spread(rj(:3), dim=1, ncopies=3)\n    ! write (*,*) \"outer[0,:3] = \", outer3d(1,1), outer3d(1,2), outer3d(1,3)\n    ! write (*,*) \"outer[1,:3] = \", outer3d(2,1), outer3d(2,2), outer3d(2,3)\n    ! write (*,*) \"outer[2,:3] = \", outer3d(3,1), outer3d(3,2), outer3d(3,3)\n\nend function outer3d\n"
    },
    {
        "instruction": [
            "Write a Fortran function named \"periodic_distance\" that calculates the periodic distance between two points in a grid. The function takes four input arguments, which are:\n- zi: an integer array of size 2 representing the coordinates of the first point.\n- zj: an integer array of size 2 representing the coordinates of the second point.\n- r_width: a double precision value representing the width of the row.\n- c_width: a double precision value representing the width of the column.\n\nThe function returns a double precision value representing the periodic distance between the two points.\n\nTo calculate the periodic distance, the function computes the row distance and column distance between the two points by taking the absolute difference of their coordinates and dividing it by the respective width. Then, it exponentiates the result using the \"exp\" function.\n\nThe periodic distance is obtained by multiplying the row distance and column distance together.\n\nThe function code is enclosed within the \"function\" and \"end function\" statements and the return value is assigned to the variable \"periodic_distance\".",
            "Write a Fortran function named periodic_distance that calculates the periodic distance between two points in a 2D grid. The function takes four input parameters: two integer arrays (zi and zj) representing the coordinates of the two points, and two double precision values (r_width and c_width) representing the row and column widths of the grid. The function returns a double precision value representing the periodic distance between the points.",
            "Provide a Fortran function named \"periodic_distance\" that calculates the distance between two points in a periodic grid system. The function takes four input parameters: two integer arrays of size 2 representing the coordinates of the two points, and two double precision variables representing the width of the rows and columns in the grid. The function returns a double precision value representing the periodic distance between the points."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer, dimension(2) :: zi, zj\n  double precision :: c_width, r_width\n  \n  !case1\n  zi = [1, 2]\n  zj = [3, 4]\n  c_width = 0.5\n  r_width = 1.0\n  print *, periodic_distance(zi, zj, r_width, c_width)\n\n  !case2\n  zi = [10, 20]\n  zj = [30, 40]\n  c_width = 2.0\n  r_width = 0.8\n  print *, periodic_distance(zi, zj, r_width, c_width)\n\n  !case3\n  zi = [100, 200]\n  zj = [300, 400]\n  c_width = 1.5\n  r_width = 0.2\n  print *, periodic_distance(zi, zj, r_width, c_width)\n\n  !case4\n  zi = [0, 0]\n  zj = [0, 0]\n  c_width = 1.0\n  r_width = 1.0\n  print *, periodic_distance(zi, zj, r_width, c_width)\n\n  !case5\n  zi = [-5, -10]\n  zj = [5, 10]\n  c_width = 0.5\n  r_width = 2.0\n  print *, periodic_distance(zi, zj, r_width, c_width)\nend program main",
            "result": [
                "2.4787521766663585E-003",
                "6.3051191089864127E-016",
                "0.0000000000000000",
                "1.0000000000000000",
                "2.8625185805493937E-020"
            ]
        },
        "code": "function periodic_distance(zi, zj, r_width, c_width)\n\n    implicit none\n\n    integer, dimension(2), intent(in) :: zi\n    integer, dimension(2), intent(in) :: zj\n    double precision, intent(in) :: c_width\n    double precision, intent(in) :: r_width\n    double precision :: periodic_distance\n\n    double precision  :: dr, dc\n\n    ! row-distance\n    dr = exp(-dble(abs(zi(1) - zj(1)))/r_width)\n\n    ! column-distance\n    dc = exp(-dble(abs(zi(2) - zj(2)))/c_width)\n\n    periodic_distance = dr * dc\n\nend function periodic_distance\n"
    },
    {
        "instruction": [
            "Provide a recursive Fortran function named factorial that calculates the factorial of an integer number. The function takes one input argument of type integer*8, representing the number for which the factorial is to be computed. The output argument, also of type integer*8, stores the resulting factorial value.",
            "Write a recursive Fortran function named factorial that calculates the factorial of a given integer. The function takes one input parameter of type integer and returns the factorial as an integer. The function uses the \"integer*8\" data type for both the input and output parameters.",
            "Write a recursive Fortran function named factorial that computes the factorial of a given integer. The function takes an integer number as input and returns the factorial as an integer. The input argument should have the type integer*8 and be declared as intent(in). The output argument should have the type integer*8 and be declared as result(fact)."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer*8 :: n, fact\n  \n  !case1\n  n = 5\n  fact = factorial(n)\n  print *, fact\n\n  !case2\n  n = 0\n  fact = factorial(n)\n  print *, fact\n\n  !case3\n  n = 10\n  fact = factorial(n)\n  print *, fact\n\n  !case4\n  n = 3\n  fact = factorial(n)\n  print *, fact\n\n  !case5\n  n = 7\n  fact = factorial(n)\n  print *, fact\nend program main",
            "result": [
                "120",
                "1",
                "3628800",
                "6",
                "5040"
            ]
        },
        "code": "recursive function factorial(n)  result(fact)\n\nimplicit none\ninteger*8 :: fact\ninteger*8, intent(in) :: n\n\nif (n == 0) then\n   fact = 1\nelse\n   fact = n * factorial(n-1)\nend if\n\nend function factorial\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named cscalarprod to compute the scalar product of two complex vectors. The number of input arguments is 2 and the data type is complex arrays of size 4. The number of output arguments is 1 and the data type is complex.",
            "Create a Fortran function named cscalarprod that calculates the scalar product of two complex vectors. The function takes two complex vector inputs, p1 and p2, with a dimension of 0 to 3. The output is a complex scalar value, cscalarprod.",
            "Create a Fortran function named cscalarprod that calculates the scalar product of two complex numbers. The function takes two complex number arrays, p1 and p2, as input parameters and returns a complex number as the result. The input arrays are of type complex(kind(1d0)) and have a dimension of 0 to 3. The function calculates the scalar product by subtracting the product of corresponding elements in p1 and p2. The result is assigned to the variable cscalarprod."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  complex(kind(1d0)), dimension(0:3) :: p1, p2\n  \n  !case1\n  p1 = [1.0, 2.0, 3.0, 4.0]\n  p2 = [2.0, 3.0, 4.0, 5.0]\n  print *, cscalarprod(p1, p2)\n\n  !case2\n  p1 = [0.0, 0.0, 0.0, 0.0]\n  p2 = [1.0, 2.0, 3.0, 4.0]\n  print *, cscalarprod(p1, p2)\n\n  !case3\n  p1 = [1.0, 1.0, 1.0, 1.0]\n  p2 = [1.0, 2.0, 3.0, 4.0]\n  print *, cscalarprod(p1, p2)\n\n  !case4\n  p1 = [1.0, -2.0, 3.0, -4.0]\n  p2 = [1.0, 2.0, -3.0, 4.0]\n  print *, cscalarprod(p1, p2)\n\n  !case5\n  p1 = [2.0, 2.0, 2.0, 2.0]\n  p2 = [-1.0, -1.0, -1.0, -1.0]\n  print *, cscalarprod(p1, p2)\nend program main",
            "result": [
                "( -36.000000000000000     ,  0.0000000000000000     )",
                "(  0.0000000000000000     ,  0.0000000000000000     )",
                "( -8.0000000000000000     ,  0.0000000000000000     )",
                "(  30.000000000000000     ,  0.0000000000000000     )",
                "(  4.0000000000000000     ,  0.0000000000000000     )"
            ]
        },
        "code": "  function cscalarprod(p1,p2)\n    implicit none\n    complex(kind(1d0))::cscalarprod\n    complex(kind(1d0)),dimension(0:3),intent(in)::p1,p2\n!    real(kind(1d0)),parameter::eps2=1d-6\n!    real(kind(1d0))::max\n    cscalarprod=p1(0)*p2(0)-p1(1)*p2(1)-p1(2)*p2(2)-p1(3)*p2(3)\n!    max=abs(p1(0)*p2(0))+abs(p1(1)*p2(1))+abs(p1(2)*p2(2))+abs(p1(3)*p2(3))\n!    if(abs(cscalarprod/max).lt.eps2)cscalarprod=dcmplx(0d0)\n  end function cscalarprod\n"
    },
    {
        "instruction": [
            "Write a Fortran function named \"wrap\" that takes three integer inputs: \"x\", \"ub\", and \"isper\". The function should return an integer output. The purpose of this function is to wrap the value of \"x\" within the range of 1 to \"ub\" if \"isper\" is equal to 1. If \"isper\" is not equal to 1, the function should return without making any changes.",
            "Write a Fortran function code named \"wrap\" that takes three input arguments: \"x\" (an integer), \"ub\" (an integer), and \"isper\" (an integer). The function calculates the wrapped value of \"x\" within the range of 1 to \"ub\". If \"isper\" is not equal to 1, the function returns without performing any calculations. The function returns an integer value \"wrap\" which represents the wrapped value of \"x\" within the specified range.",
            "Write a Fortran function named \"wrap\" that takes three input arguments: \"x\" (an integer), \"ub\" (an integer), and \"isper\" (an integer). The function calculates the wrapped value of \"x\" within the range from 1 to \"ub\". The function returns an integer as the wrapped value.\n\nTo write the function, first check if \"isper\" is equal to 1. If not, exit the function. Otherwise, calculate the wrapped value by subtracting 1 from \"x\", taking the modulo of the result with \"ub\", and adding 1 to the final result.\n\nEnsure to correctly specify the number and type of input and output parameters in the instruction."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: x, ub, isper, result\n\n  !case1\n  x = 5\n  ub = 10\n  isper = 1\n  result = wrap(x, ub, isper)\n  print *, result\n\n  !case2\n  x = 15\n  ub = 10\n  isper = 1\n  result = wrap(x, ub, isper)\n  print *, result\n\n  !case3\n  x = -2\n  ub = 10\n  isper = 0\n  result = wrap(x, ub, isper)\n  print *, result\n\n  !case4\n  x = 10\n  ub = 10\n  isper = 1\n  result = wrap(x, ub, isper)\n  print *, result\n\n  !case5\n  x = 8\n  ub = 5\n  isper = 1\n  result = wrap(x, ub, isper)\n  print *, result\nend program main",
            "result": [
                "5",
                "5",
                "0",
                "10",
                "3"
            ]
        },
        "code": " pure function wrap(x, ub, isper)\n  implicit none\n  integer, intent(in) :: x, ub, isper\n  integer :: wrap\n\n  if(isper /= 1) return\n\n  wrap = modulo(x-1, ub) + 1\n end function wrap\n"
    },
    {
        "instruction": [
            "Write a Fortran function named cumsum_i that calculates the cumulative sum of an array of integers. The function takes an input array of integers and returns an output array of integers. The number of input arguments is 1 and the test_data type is [integer, dimension(:)]. The number of output arguments is 1 and the test_data type is [integer, dimension(size(x))].",
            "Provide a Fortran function code named cumsum_i to compute the cumulative sum of an input integer array. The function takes in one input argument of type integer array and returns one output argument of the same type. The input argument is specified with the \"intent(in)\" attribute and the output argument is of type integer array with the same size as the input array. The function computes the cumulative sum by iterating over the elements of the input array and storing the cumulative sum in the output array. The function uses a do loop to iterate from the second element of the input array to the last element, where each element of the output array is computed as the sum of the previous element of the output array and the corresponding element of the input array.",
            "Create a Fortran function named cumsum_i that computes the cumulative sum of an input integer array. The function takes an integer array as input and returns an integer array as output. The number of input arguments is 1 and the data type is integer array. The number of output arguments is 1 and the data type is integer array. Use a do loop to iterate through the elements of the input array and calculate the cumulative sum. The cumulative sum is stored in the output array."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer, allocatable :: x(:)\n  integer, allocatable :: cumsum(:)\n  \n  !case1\n  allocate(x(5))\n  x = [1, -2, 3, -4, 5]\n  cumsum = cumsum_i(x)\n  print *, cumsum\n  deallocate(x)\n  deallocate(cumsum)\n\n  !case2\n  allocate(x(3))\n  x = [10, 20, 30]\n  cumsum = cumsum_i(x)\n  print *, cumsum\n  deallocate(x)\n  deallocate(cumsum)\n\n  !case3\n  allocate(x(6))\n  x = [3, 6, 9, 12, 15, 18]\n  cumsum = cumsum_i(x)\n  print *, cumsum\n  deallocate(x)\n  deallocate(cumsum)\n\n  !case4\n  allocate(x(4))\n  x = [0, 0, 0, 0]\n  cumsum = cumsum_i(x)\n  print *, cumsum\n  deallocate(x)\n  deallocate(cumsum)\n\n  !case5\n  allocate(x(7))\n  x = [5, -2, 7, -4, 9, -6, 11]\n  cumsum = cumsum_i(x)\n  print *, cumsum\n  deallocate(x)\n  deallocate(cumsum)\nend program main",
            "result": [
                "1          -1           2          -2           3",
                "10          30          60",
                "3           9          18          30          45          63",
                "0           0           0           0",
                "5           3          10           6          15           9          20"
            ]
        },
        "code": "  function cumsum_i(x) result (cumsum)\r\n    integer, dimension(:), intent(in) :: x\r\n    integer, dimension(size(x)) :: cumsum\r\n\r\n    integer :: i\r\n\r\n    cumsum(1) = x(1)\r\n    do i = 2, size(x)\r\n       cumsum(i) = cumsum(i - 1) + x(i)\r\n    end do\r\n  end function cumsum_i\r\n"
    },
    {
        "instruction": [
            "Create a Fortran function named get_len that calculates the length of a given string. The function takes one input argument, a character string, and returns one output argument of type integer. The name of the input parameter is \"string\" and the name of the output parameter is \"get_len\".",
            "Give me a Fortran function code named get_len to determine the length of a string. The function takes a single input argument of type character and returns an integer value representing the length of the string. The input argument is declared as intent(in) to specify that it is read-only. The output value is initialized to zero and then incremented until a space character is encountered in the string.",
            "Write a Fortran function called get_len that calculates the length of a given string. The function takes one input argument, a string of any length. The input argument is of type character with unspecified length. The function returns one output argument, an integer representing the length of the string. To use the function, call it with the desired string as the argument, and the function will return the length of the string. Remember to declare the function using the keyword \"function\" and specify the input and output data types in the function definition."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=20) :: string\n\n  !case1\n  string = \"Hello World\"\n  print *, get_len(string)\n\n  !case2\n  string = \"This is a test\"\n  print *, get_len(string)\n\n  !case3\n  string = \"12345\"\n  print *, get_len(string)\n\n  !case4\n  string = \"This string has spaces \"\n  print *, get_len(string)\n\n  !case5\n  string = \"Testing123\"\n  print *, get_len(string)\n\nend program main",
            "result": [
                "5",
                "4",
                "5",
                "4",
                "10"
            ]
        },
        "code": "  function get_len(string)\n    character(len=*), intent(in):: string\n    integer:: get_len\n    get_len = 0\n    do while (string(get_len+1:get_len+1)/=' ')\n      get_len = get_len+1\n    end do\n  end function\n"
    },
    {
        "instruction": [
            "Provide a Fortran function named \"equalto\" that checks if two floating-point numbers are almost equal. The function takes in three input parameters: \"a\" and \"b\" of type double precision, representing the two floats to be compared, and \"abs_tol\" (optional) of type double precision, representing the absolute tolerance for comparison. The function returns a logical value indicating whether the two floats are almost equal. The number of input arguments is 2 (or 3 if \"abs_tol\" is provided), and the data type of the input arguments is [double precision, double precision] (or [double precision, double precision, double precision] if \"abs_tol\" is provided). The number of output arguments is 1, and the data type of the output argument is [logical].",
            "Write a Fortran function named equalto that checks if two floating-point numbers are almost equal. The function takes two input arguments, both of type double precision, which represent the two floats to be compared. Additionally, an optional input argument abs_tol of type double precision can be provided to specify the absolute tolerance for the comparison. The function returns a logical value indicating whether the floats are almost equal.\n\nTo understand if the floats are equal, the function first checks if they are exactly equal. If they are, it sets the result to true and returns. If not, it sets a default absolute tolerance value of 1.0d-8. However, if abs_tol is provided, the function uses the specified value. The difference between the floats is calculated using the absolute value of the subtraction. If the difference is less than or equal to the absolute tolerance, the function sets the result to true. Otherwise, it sets the result to false.\n\nThe function is useful for comparing floats within a given tolerance and can be used in various applications where precise float comparison is required.",
            "Create a Fortran function named \"equalto\" that checks if two floating-point numbers are almost equal. The function takes in three input arguments: \"a\" and \"b\" as double precision floating-point numbers, and \"abs_tol\" as an optional double precision floating-point number representing the absolute tolerance. The function returns a logical value indicating whether the two numbers are almost equal. \n\nIn the function, first, it checks if \"a\" is equal to \"b\" exactly. If they are equal, it returns true. Otherwise, it sets a default absolute tolerance value of 1.0e-8. If the \"abs_tol\" argument is present, it updates the absolute tolerance accordingly. Then, it calculates the absolute difference between \"a\" and \"b\". If the difference is less than or equal to the absolute tolerance, it returns true. Otherwise, it returns false."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  double precision :: a, b, abs_tol\n  \n  !case1\n  a = 1.0\n  b = 1.0\n  abs_tol = 1.0e-8\n  print *, equalto(a, b, abs_tol)\n  \n  !case2\n  a = 1.0\n  b = 2.0\n  abs_tol = 1.0e-8\n  print *, equalto(a, b, abs_tol)\n  \n  !case3\n  a = 0.0\n  b = 0.0\n  abs_tol = 1.0e-8\n  print *, equalto(a, b, abs_tol)\n  \n  !case4\n  a = 1.23456789\n  b = 1.23456789\n  abs_tol = 1.0e-9\n  print *, equalto(a, b, abs_tol)\n  \n  !case5\n  a = -3.14159\n  b = 3.14159\n  abs_tol = 1.0e-5\n  print *, equalto(a, b, abs_tol)\n  \nend program main",
            "result": [
                "T",
                "F",
                "T",
                "T",
                "F"
            ]
        },
        "code": "function equalto(a, b, abs_tol) result(equal_to)\n    !> check if two floats are almost equal.\n    !> a - first float.\n    !> b - other float.\n    !> abs_tol - absolute toleranace.\n    \n    ! input\n    double precision, intent(in) :: a, b\n    double precision, intent(in), optional :: abs_tol\n    \n    ! output\n    logical :: equal_to\n    \n    ! working\n    double precision :: atol, diff\n    \n    ! in case they are exact.\n    if (a .eq. b) then\n        equal_to = .true.\n        return\n    end if\n    \n    ! set defaults.\n    atol = 1.0d-8\n    if (present(abs_tol)) then\n        atol = abs_tol\n    end if\n    \n    diff = dabs(b - a)\n    ! absolute comparison.\n    if (diff .le. atol) then\n        equal_to = .true.\n        return\n    end if\n    equal_to = .false.\nend function equalto\n"
    },
    {
        "instruction": [
            "Write a Fortran function named check_bounds that checks if a given floating point number falls within a specified range. The function takes three input arguments, which are all of type double precision: x (the number to be checked), a (the lower bound), and b (the upper bound). The function returns an updated value of x, which is also of type double precision.\n\nTo use the function, provide the values for x, a, and b. The function will compare x with the lower and upper bounds. If x is less than a, the function will update x to be equal to a. If x is greater than b, the function will update x to be equal to b. The updated value of x will be returned by the function.\n\nNote that the function is implemented using an imperative approach, where the value of xout is initially set to the input value of x. If x is found to be outside the bounds, xout is updated accordingly. The updated value of xout is then returned by the function.",
            "Create a Fortran function named check_bounds that checks if a given double precision number is within a specified range. The function takes three input arguments, all of which are double precision: x - the number to check, a - the lower bound, and b - the upper bound. The function returns an updated value of x, with any values outside the specified range replaced by the corresponding bound.",
            "Create a Fortran function named check_bounds that checks if a given floating point number is within a specified range. The function takes in three double precision inputs: x (the number to be checked), a (the lower bound), and b (the upper bound). The function returns a double precision value xout, which is the updated value of x if it is outside the bounds, or the same value if it is within the bounds."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  double precision :: x, a, b, xout\n\n  !case1\n  x = 5.0\n  a = 0.0\n  b = 10.0\n  xout = check_bounds(x, a, b)\n  print *, xout\n\n  !case2\n  x = -3.0\n  a = -5.0\n  b = 0.0\n  xout = check_bounds(x, a, b)\n  print *, xout\n\n  !case3\n  x = 12.0\n  a = 0.0\n  b = 10.0\n  xout = check_bounds(x, a, b)\n  print *, xout\n\n  !case4\n  x = 2.5\n  a = 0.0\n  b = 10.0\n  xout = check_bounds(x, a, b)\n  print *, xout\n\n  !case5\n  x = -10.0\n  a = -5.0\n  b = 0.0\n  xout = check_bounds(x, a, b)\n  print *, xout\n  \nend program main",
            "result": [
                "5.0000000000000000",
                "-3.0000000000000000",
                "10.000000000000000",
                "2.5000000000000000",
                "-5.0000000000000000"
            ]
        },
        "code": "function check_bounds(x, a, b) result(xout)\n    !> check that a float is between the bounds and return an updated value\n    !> if not.\n    !> x - float to check.\n    !> a - lower bound.\n    !> b - upper bound.\n    \n    ! input\n    double precision, intent(in) :: x, a, b\n    \n    ! output\n    double precision :: xout\n    \n    xout = x\n    \n    if ( x .lt. a) then\n        xout = a\n        return\n    end if\n    \n    if ( x .gt. b) then\n        xout = b\n        return\n    end if\n\nend function check_bounds\n"
    },
    {
        "instruction": [
            "Provide a Fortran function named replace_text to replace occurrences of a specific text within a given string. The function takes three input arguments - a character string (str), a character string to be replaced (text), and a character string to replace it with (rep). The output argument (outs) is a character string that contains the modified version of the input string.\n\nTo use the function, provide the input string, the text to be replaced, and the replacement text as arguments. The function will return the modified string with all occurrences of the specified text replaced.\n\nMake sure to specify the number and type of input and output parameters correctly.",
            "Provide a Fortran function code named replace_text that replaces all occurrences of a specified text with another specified text within a given string. The number of input arguments is 3 and the data type for each argument is character. The number of output arguments is 1 and the data type is character.",
            "Write a Fortran function code named replace_text that replaces occurrences of a specific string with another string in a given input string. The function takes three input arguments: str (character array), text (character array), and rep (character array). The function returns an output argument named outs (character array). The function searches for the text in the input string and replaces it with the rep string. The lengths of the input and output strings are determined by the length of the input string. The function uses a do loop to iterate through the input string and replaces all occurrences of the text with the rep string."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=20) :: str, text, rep, outs\n  \n  !case1\n  str = \"Hello, World!\"\n  text = \"o\"\n  rep = \"a\"\n  outs = replace_text(str, text, rep)\n  print *, outs\n\n  !case2\n  str = \"I love cats and dogs.\"\n  text = \"cats\"\n  rep = \"dogs\"\n  outs = replace_text(str, text, rep)\n  print *, outs\n\n  !case3\n  str = \"abcdefg\"\n  text = \"c\"\n  rep = \"xyz\"\n  outs = replace_text(str, text, rep)\n  print *, outs\n\n  !case4\n  str = \"The sun is shining.\"\n  text = \"sun\"\n  rep = \"moon\"\n  outs = replace_text(str, text, rep)\n  print *, outs\n\n  !case5\n  str = \"1234567890\"\n  text = \"5\"\n  rep = \"0\"\n  outs = replace_text(str, text, rep)\n  print *, outs\n  \nend program main",
            "result": [
                "Hella, Warld!",
                "I love dogs and dogs",
                "abxyzdefg",
                "The moon is shining.",
                "1234067890"
            ]
        },
        "code": "   function replace_text(str, text, rep) result(outs)\n      character(*) :: str, text, rep\n      character(len=len(str)) :: outs\n      integer :: i, nt, nr\n\n      outs = str\n      nt = len_trim(text)\n      nr = len_trim(rep)\n      do\n         i = index(outs, text(:nt))\n         if (i == 0) exit\n         outs = outs(:i-1) // rep(:nr) // outs(i+nt:)\n      end do\n   end function replace_text\n"
    },
    {
        "instruction": [
            "Please provide a Fortran function named \"kim_l\" that takes a logical input argument and returns an integer. The number of input arguments is 1 and the data type is logical. The number of output arguments is 1 and the data type is integer. The function should return 1 if the logical input is true and 0 if it is false.",
            "Provide a Fortran function code called kim_l that converts a logical value to an integer value. The function takes one input argument, a logical value, and returns one output argument, an integer value. Use the keyword \"logical\" for the input parameter and \"integer\" for the output parameter. The function should be named \"kim_l\".",
            "Provide a Fortran function code called \"kim_l\" that takes a logical input argument and returns an integer. The input argument is of type logical, and the output argument is of type integer. The function determines whether the logical input is true or false. If the input is true, the function returns 1, and if the input is false, the function returns 0."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  logical :: l\n\n  !case1\n  l = .true.\n  print *, kim_l(l)\n\n  !case2\n  l = .false.\n  print *, kim_l(l)\n\n  !case3\n  l = .true.\n  print *, kim_l(l)\n\n  !case4\n  l = .false.\n  print *, kim_l(l)\n\n  !case5\n  l = .true.\n  print *, kim_l(l)\nend program main",
            "result": [
                "1",
                "0",
                "1",
                "0",
                "1"
            ]
        },
        "code": "function kim_l(l)\n   logical, intent(in) :: l\n   integer :: kim_l\n\n   if (l) then\n      kim_l = 1\n   else\n      kim_l = 0\n   endif\nend function kim_l\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named pascaltriangle to compute the value of a specific entry in the Pascal's triangle. The function takes two integer inputs (a and b) and returns an integer output (pascaltriangle). To use the function, provide the values of a and b as input arguments. The function will calculate the corresponding entry in Pascal's triangle and return the result.",
            "Provide a Fortran function named pascaltriangle that calculates the value of the Pascal's triangle at a specific row and column. The function takes two input parameters, both integers, representing the row (a) and column (b) of the desired value. The function returns an integer value.",
            "Write a Fortran function named pascaltriangle that calculates the value of a specific element in Pascal's triangle. The function takes two integer input arguments, a and b, and returns an integer value. The input arguments are specified using the intent(in) attribute. The function uses a loop to calculate the value by iteratively multiplying and dividing numbers."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: a, b\n\n  !case1\n  a = 5\n  b = 2\n  print *, pascaltriangle(a, b)\n\n  !case2\n  a = 7\n  b = 4\n  print *, pascaltriangle(a, b)\n\n  !case3\n  a = 10\n  b = 0\n  print *, pascaltriangle(a, b)\n\n  !case4\n  a = 3\n  b = 3\n  print *, pascaltriangle(a, b)\n\n  !case5\n  a = 6\n  b = 1\n  print *, pascaltriangle(a, b)\n\nend program main",
            "result": [
                "10",
                "35",
                "1",
                "1",
                "6"
            ]
        },
        "code": "  pure function pascaltriangle (a,b)\n    implicit none\n    integer :: pascaltriangle\n    integer, intent (in) :: a,b\n    integer i\n    pascaltriangle = 1\n    do i = 0, b-1\n      pascaltriangle = pascaltriangle*(a-i)/(i+1)\n    end do\n  end function pascaltriangle\n"
    },
    {
        "instruction": [
            "Write a Fortran function named neural_sigmoid_vector to compute the sigmoid function for each element in a given array. The function takes in a one-dimensional array of double precision floating-point numbers as input. The number of input arguments is 1 and the test_data type is [double precision, dimension(:), intent(in)]. The function returns a one-dimensional array of double precision floating-point numbers as output, with the same size as the input array. The number of output arguments is 1 and the test_data type is [double precision, dimension(size(x))].",
            "Create a Fortran function named neural_sigmoid_vector that takes in an array of double precision numbers as input. The function calculates the sigmoid function for each element of the input array and returns a new array with the sigmoid values. The number of input arguments is 1 and the type is [double precision, dimension(:)]. The number of output arguments is 1 and the type is [double precision, dimension(size(x))].",
            "Write a Fortran function named \"neural_sigmoid_vector\" that calculates the sigmoid function for each element in an input vector. The function takes an array of double precision numbers as input and returns an array of the same size. The number of input arguments is 1 and the test data type is [double precision, dimension(:)]. The number of output arguments is 1 and the test data type is [double precision, dimension(size(x))]."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n\n  double precision, allocatable :: x(:)\n  \n  !case1\n  n=3\n  allocate(x(n))\n  x = [1.0, 2.0, 3.0]\n  print *, neural_sigmoid_vector(x)\n  deallocate(x)\n\n  !case2\n  n=4\n  allocate(x(n))\n  x = [-1.0, -2.0, -3.0, -4.0]\n  print *, neural_sigmoid_vector(x)\n  deallocate(x)\n\n  !case3\n  n=5\n  allocate(x(n))\n  x = [0.0, 0.0, 0.0, 0.0, 0.0]\n  print *, neural_sigmoid_vector(x)\n  deallocate(x)\n\n  !case4\n  n=2\n  allocate(x(n))\n  x = [10.0, 20.0]\n  print *, neural_sigmoid_vector(x)\n  deallocate(x)\n\n  !case5\n  n=5\n  allocate(x(n))\n  x = [2.3132, -1.32, 2.5354, 0.3192, -1.23912]\n  print *, neural_sigmoid_vector(x)\n  deallocate(x)\nend program main",
            "result": [
                "0.73105857863000490       0.88079707797788231       0.95257412682243336",
                "0.26894142136999510       0.11920292202211755        4.7425873177566781E-002   1.7986209962091559E-002",
                "0.50000000000000000       0.50000000000000000       0.50000000000000000       0.50000000000000000       0.50000000000000000",
                "0.99995460213129761       0.99999999793884631",
                "0.90996437269758945       0.21081828475108677       0.92658652399335328       0.57912927587538376       0.22458919846935899"
            ]
        },
        "code": "  function neural_sigmoid_vector(x)\n\n    double precision, dimension(:), intent(in) :: x\n    double precision, dimension(size(x)) :: neural_sigmoid_vector\n    integer :: i\n\n    do i=1, size(x)\n      neural_sigmoid_vector(i) = 1.0 / (1.0 + exp(-x(i)))\n    end do\n\n  end function neural_sigmoid_vector\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named random_int that generates a random integer within a specified range. The function takes two input arguments of type integer: from_val and to_val, which define the range for the random integer. The function returns a single output argument of type integer: r_int, which holds the randomly generated integer.",
            "Provide a Fortran function code named random_int to generate a random integer within a specified range. The number of input arguments is 2 and the data type of both arguments is integer. The number of output arguments is 1 and the data type is integer.",
            "Create a Fortran function named random_int that generates a random integer within a given range. The function takes two input parameters, from_val and to_val, both of type integer. The output of the function is a single integer value, which is the randomly generated integer. Make sure to use the \"implicit none\" statement at the beginning of the function to enforce explicit variable declarations."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: from_val, to_val, r_int\n  \n  !case1: Generating a random integer between 0 and 10\n  from_val = 0\n  to_val = 10\n  r_int = random_int(from_val, to_val)\n  print *, r_int\n  \n  !case2: Generating a random integer between -100 and 100\n  from_val = -100\n  to_val = 100\n  r_int = random_int(from_val, to_val)\n  print *, r_int\n  \n  !case3: Generating a random integer between 1 and 1000\n  from_val = 1\n  to_val = 1000\n  r_int = random_int(from_val, to_val)\n  print *, r_int\n  \n  !case4: Generating a random integer between -50 and 50\n  from_val = -50\n  to_val = 50\n  r_int = random_int(from_val, to_val)\n  print *, r_int\n  \n  !case5: Generating a random integer between 100 and 200\n  from_val = 100\n  to_val = 200\n  r_int = random_int(from_val, to_val)\n  print *, r_int\nend program main",
            "result": [
                "9",
                "13",
                "965",
                "24",
                "136"
            ]
        },
        "code": "    function random_int(from_val, to_val) result(r_int)\n        implicit none\n        integer ,value :: from_val, to_val\n        integer ::  r_int\n        real :: r\n        \n        call random_number(r)\n        r_int = int(from_val + r*(to_val - from_val))\n    end function random_int\n"
    },
    {
        "instruction": [
            "Create a Fortran function named \"io_str_get_num_tokens\" that counts the number of tokens in a given string. The function requires one input parameter, \"str\", which is a character string. The output of the function is an integer value representing the number of tokens found in the input string.",
            "Give me a Fortran function code named io_str_get_num_tokens to count the number of tokens in a given input string. The input parameter is a character string named \"str\". The function returns an integer value representing the number of tokens in the string.",
            "Please provide a Fortran function named io_str_get_num_tokens that calculates the number of tokens in a given string. The function takes one input argument of type character(len=*), which represents the string to be analyzed. The function returns an integer value, indicating the number of tokens found in the string.\n\nTo understand the functionality of this code, it scans the input string and counts the number of spaces present. The number of spaces is then incremented by one to determine the number of tokens in the string.\n\nNow, as a Fortran expert, your task is to write the instructions for the function named io_str_get_num_tokens."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=100) :: str\n\n  !case1\n  str = \"Hello World\"\n  print *, io_str_get_num_tokens(str)\n\n  !case2\n  str = \"The quick brown fox jumps over the lazy dog\"\n  print *, io_str_get_num_tokens(str)\n\n  !case3\n  str = \"1 2 3 4 5\"\n  print *, io_str_get_num_tokens(str)\n\n  !case4\n  str = \"This is a test\"\n  print *, io_str_get_num_tokens(str)\n\n  !case5\n  str = \"Fortran is awesome\"\n  print *, io_str_get_num_tokens(str)\nend program main",
            "result": [
                "2",
                "9",
                "5",
                "4",
                "3"
            ]
        },
        "code": "function io_str_get_num_tokens(str)\n  implicit none\n\n  integer                       ::  io_str_get_num_tokens\n  character(len=*), intent(in)  ::  str\n\n  character(len=1), parameter ::  space = ' '\n  integer ::  i, j, strlen\n\n  ! if we assume that we have used str_shrink before then we can just count the spaces..\n  strlen = len_trim(str)\n  io_str_get_num_tokens = 1 ! always n-1 spaces to n tokens\n  i = 1 ! get into loop\n  j = 1\n  do while (i .gt. 0)\n    i = index(str(j:strlen), space)\n    j = j+i\n    if (i .gt. 0) io_str_get_num_tokens = io_str_get_num_tokens + 1\n  end do\nend function io_str_get_num_tokens\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named \"lcase\" that converts all uppercase characters in a given character string to lowercase. The function takes a single input argument of type character string and returns a modified character string with all lowercase characters.",
            "Provide a Fortran function named \"lcase\" that converts a given character string to lowercase. The function takes a single input argument of type character, and returns a character string in lowercase.",
            "Please provide me a Fortran function named \"lcase\" to convert all characters in a given string to lowercase. The function should take a single input argument of type character string and return a character string."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=100) :: cs\n\n  !case1\n  cs = \"Hello World\"\n  print *, lcase(cs)\n\n  !case2\n  cs = \"FORTRAN\"\n  print *, lcase(cs)\n\n  !case3\n  cs = \"12345\"\n  print *, lcase(cs)\n\n  !case4\n  cs = \"AbCdEfG123!@#\"\n  print *, lcase(cs)\n\n  !case5\n  cs = \"This is a Test\"\n  print *, lcase(cs)\n\nend program main",
            "result": [
                "Hello World",
                "FORTRAN",
                "12345",
                "AbCdEfG123!@#",
                "This is a Test"
            ]
        },
        "code": " function lcase (cs) \n!\n    integer, parameter :: co=iachar('a')-iachar('a') ! case offset\n    \n    character(len=*), intent(in) :: cs ! character string \n    character(len=len(cs)) :: lcase \n    character :: ca(len(cs)) ! character array\n    \n    ca=transfer(cs,\"x\",len(cs)) \n    where (ca >= \"a\" .and. ca <= \"z\") ca=achar(iachar(ca)+co) \n    lcase=transfer(ca,cs) \n    return\n    \n end function lcase \n"
    },
    {
        "instruction": [
            "Provide a Fortran function called \"toupper\" to convert lowercase letters in a given string to uppercase. The function takes in one input parameter of type character and returns the modified string as output.",
            "Provide a Fortran function code named toupper that converts all lowercase ASCII letters in a given string to uppercase. The function takes a single input argument of type character, and returns a character of the same length as the input string. The name of the function is \"toupper\".",
            "Create a Fortran function named \"toupper\" that converts the lowercase ASCII letters in a given string to uppercase. The function takes one input argument of type character and returns a new string with the converted uppercase letters. The name of the function is \"toupper\"."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(10) :: str\n  \n  !case1\n  str = \"Hello\"\n  print *, toupper(str)\n\n  !case2\n  str = \"fortran\"\n  print *, toupper(str)\n\n  !case3\n  str = \"12345\"\n  print *, toupper(str)\n\n  !case4\n  str = \"UPPERCASE\"\n  print *, toupper(str)\n\n  !case5\n  str = \"AbCdEfG\"\n  print *, toupper(str)\n  \nend program main",
            "result": [
                "Hello",
                "fortran",
                "12345",
                "UPPERCASE",
                "AbCdEfG"
            ]
        },
        "code": "elemental function toupper(str)\n!! ascii letters to uppercase\ncharacter(*), intent(in) :: str\ncharacter(len(str)) :: toupper\ncharacter(*), parameter :: lower=\"abcdefghijklmnopqrstuvwxyz\", &\n                            upper=\"abcdefghijklmnopqrstuvwxyz\"\ninteger :: i,j\n\ntoupper = str\n\n!do concurrent (i = 1:len(str))  ! fixme: flang\ndo i = 1,len(str)\n  j = index(lower,str(i:i))\n  if (j > 0) toupper(i:i) = upper(j:j)\nend do\n\nend function toupper\n"
    },
    {
        "instruction": [
            "Please create a Fortran function named \"to_lower\" that converts a given input string to lowercase. The function takes one input argument of type \"character(len=*)\" (a string) and returns a lowercase version of the input string as the output argument. The function is an elemental function, meaning it can operate on arrays of strings.",
            "You need to create a Fortran function named \"to_lower\" that converts a given input string to lowercase. The function takes one input parameter of type character(len=*), which represents the input string. The output of the function is a lowercase version of the input string, also of type character(len=*).",
            "Write a Fortran function named \"to_lower\" that converts a given input string to lowercase characters. The function takes a single input parameter of type character(len=*), named \"str\". The function returns a string of the same length as the input string, with all characters converted to lowercase. The function should be declared as \"elemental\" to allow element-wise operations on arrays."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=100) :: str\n  \n  !case1\n  str = \"Hello World!\"\n  print *, to_lower(str)\n  \n  !case2\n  str = \"FORTRAN\"\n  print *, to_lower(str)\n  \n  !case3\n  str = \"12345\"\n  print *, to_lower(str)\n  \n  !case4\n  str = \"AbCdEfG\"\n  print *, to_lower(str)\n  \n  !case5\n  str = \"ThIs Is A TeSt\"\n  print *, to_lower(str)\n  \nend program main",
            "result": [
                "Hello World!",
                "FORTRAN",
                "12345",
                "AbCdEfG",
                "ThIs Is A TeSt"
            ]
        },
        "code": "elemental function to_lower(str) result(lcstr)\n\n   !> input string\n   character(len=*), intent(in) :: str\n\n   !> lowercase version of string\n   character(len=len(str)):: lcstr\n\n   integer :: ilen, iquote, i, iav, iqc\n   integer, parameter :: offset = iachar('a') - iachar('a')\n\n   ilen = len(str)\n   iquote = 0\n   lcstr = str\n\n   do i = 1, ilen\n      iav = iachar(str(i:i))\n      if (iquote == 0 .and. (iav == 34 .or.iav == 39)) then\n         iquote = 1\n         iqc = iav\n         cycle\n      end if\n      if (iquote == 1 .and. iav==iqc) then\n         iquote=0\n         cycle\n      end if\n      if (iquote == 1) cycle\n      if (iav >= iachar('a') .and. iav <= iachar('z')) then\n         lcstr(i:i) = achar(iav - offset)\n      else\n         lcstr(i:i) = str(i:i)\n      end if\n   end do\n\nend function to_lower\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named frac_lay that calculates the fraction of overlap between a linear location and a layer depth slice. The function takes in four input arguments: top_loc (real), bot_loc (real), top_lay (real), and bot_lay (real). The function returns a single output argument, frac_lay (real).",
            "Write a Fortran function named \"frac_lay\" that calculates the fraction of overlap between a linear location and a layer depth slice. The function takes in four real numbers as input arguments: \"top_loc\" representing the top location, \"bot_loc\" representing the bottom location, \"top_lay\" representing the top of the layer, and \"bot_lay\" representing the bottom of the layer. The function returns a real number \"frac_lay\" as the output argument. \n\nHere's how the function works:\n1. If the top location is within the layer and the bottom location is also within the layer, the fraction of overlap is 1.0.\n2. If the top location is not within the layer, but the bottom location is within the layer, the fraction of overlap is calculated as (bot_loc - top_lay) divided by (bot_loc - top_loc).\n3. If the top location is within the layer, but the bottom location is not within the layer, the fraction of overlap is calculated as (bot_lay - top_loc) divided by (bot_loc - top_loc).\n4. If neither the top location nor the bottom location is within the layer, the fraction of overlap is 0.0.\n\nMake sure to define the function \"frac_lay\" as a real type and include the \"implicit none\" statement at the beginning of your code.",
            "Please provide a Fortran function code called \"frac_lay\" to calculate the fraction of overlap between a linear location and a layer depth slice. The function takes four input arguments: \"top_loc\" and \"bot_loc\" of type real representing the top and bottom locations, and \"top_lay\" and \"bot_lay\" of type real representing the top and bottom values of the layer. The function returns a single output argument \"frac_lay\" of type real, which represents the fraction of overlap between the linear location and the layer depth slice."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real :: top_loc, bot_loc, top_lay, bot_lay, frac\n\n  !case1\n  top_loc = 1.0\n  bot_loc = 2.0\n  top_lay = 0.5\n  bot_lay = 1.5\n  frac = frac_lay(top_loc, bot_loc, top_lay, bot_lay)\n  print *, frac\n\n  !case2\n  top_loc = 1.0\n  bot_loc = 2.0\n  top_lay = 0.5\n  bot_lay = 2.0\n  frac = frac_lay(top_loc, bot_loc, top_lay, bot_lay)\n  print *, frac\n\n  !case3\n  top_loc = 0.5\n  bot_loc = 1.5\n  top_lay = 1.0\n  bot_lay = 2.0\n  frac = frac_lay(top_loc, bot_loc, top_lay, bot_lay)\n  print *, frac\n\n  !case4\n  top_loc = 1.0\n  bot_loc = 3.0\n  top_lay = 0.5\n  bot_lay = 2.5\n  frac = frac_lay(top_loc, bot_loc, top_lay, bot_lay)\n  print *, frac\n\n  !case5\n  top_loc = 0.5\n  bot_loc = 1.5\n  top_lay = 1.0\n  bot_lay = 1.5\n  frac = frac_lay(top_loc, bot_loc, top_lay, bot_lay)\n  print *, frac\nend program main",
            "result": [
                "0.500000000",
                "1.00000000",
                "0.500000000",
                "0.750000000",
                "0.500000000"
            ]
        },
        "code": "function frac_lay(top_loc,bot_loc,top_lay,bot_lay)\n!\n\n! is contained in a layer. it could also be viewed as the\n! fraction of \"overlap\" of the linear location with a layer\n! depth slice. it was written assuming that top values are\n! less than bottom values\n!\nimplicit none\n!\n! dummy arguments\n!\nreal :: bot_lay,bot_loc,top_lay,top_loc\nreal :: frac_lay\n!\n\n!\n!\nif (top_lay<=top_loc.and.bot_lay>top_loc) then\n          ! top location is in layer\n  if (bot_lay>=bot_loc) then\n              ! bottom location is also in layer\n     frac_lay = 1.0\n  else\n              ! bottom location is below layer, proportion\n     frac_lay = (bot_lay-top_loc)/(bot_loc-top_loc)\n  end if\nelse if (top_lay<bot_loc.and.bot_lay>=bot_loc) then\n          ! bottom location is in layer\n          ! if we are here, top location is not in layer so proportion\n  frac_lay = (bot_loc-top_lay)/(bot_loc-top_loc)\nelse if (top_lay>top_loc.and.bot_lay<bot_loc) then\n          ! location completely spans layer\n  frac_lay = (bot_lay-top_lay)/(bot_loc-top_loc)\nelse\n          ! location is not in the layer at all\n  frac_lay = 0.0\nend if\n!\nend function frac_lay\n"
    },
    {
        "instruction": [
            "Write a Fortran function code named func that takes an integer input argument and returns an integer output. The function is designed to increment the input integer by 1. The number of input arguments is 1 and the data type is integer. The number of output arguments is 1 and the data type is integer.",
            "Give me a Fortran function code named func that takes an integer input argument and returns an integer output. The number of input arguments is 1 and the data type is integer. The number of output arguments is 1 and the data type is integer. The function calculates the value of the output by adding 1 to the input argument.",
            "Give me a Fortran function code named func that takes an integer as input and returns an integer as output. The input parameter is passed by value. The function increments the input integer by 1 and assigns the result to the output integer. Use the OpenACC routine directive to indicate that this function can be offloaded to an accelerator device."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n, rc\n  \n  !case1\n  n = 0\n  rc = func(n)\n  print *, rc\n  \n  !case2\n  n = 5\n  rc = func(n)\n  print *, rc\n  \n  !case3\n  n = -10\n  rc = func(n)\n  print *, rc\n  \n  !case4\n  n = 100\n  rc = func(n)\n  print *, rc\n  \n  !case5\n  n = -999\n  rc = func(n)\n  print *, rc\n  \nend program main",
            "result": [
                "1",
                "6",
                "-9",
                "101",
                "-998"
            ]
        },
        "code": "    function func (n) result (rc)\n    !$acc routine\n    integer, intent (in) :: n\n    integer :: rc\n\n    rc = n\n    rc = rc + 1\n\n    end function\n"
    },
    {
        "instruction": [
            "Write a Fortran function code named lsm_getsign that returns the sign of a floating-point number. The function takes one input argument of type real and returns one output argument of type real. The function returns 1.0 if the input number is positive and -1.0 if the input number is negative.",
            "Write a Fortran function code named lsm_getsign that returns the sign of a given floating-point number. The function takes one input argument, a real number named \"a\". The function returns a real number, which represents the sign of the input number. The returned sign is either 1.0 if the input number is positive or zero, or -1.0 if the input number is negative.",
            "Write a Fortran function named lsm_getsign that determines the sign of a given real number. The function takes a single input argument of type real and returns a single output argument of type real. The number of input arguments is 1 and the data type is [real]. The number of output arguments is 1 and the data type is [real]. The function initializes the output variable with a value of 1.0 and checks if the input number is less than 0. If the input number is less than 0, the function updates the output variable with a value of -1.0. Finally, the function returns the updated output variable."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real :: a\n\n  !case1\n  a = 2.5\n  print *, lsm_getsign(a)\n\n  !case2\n  a = -3.8\n  print *, lsm_getsign(a)\n\n  !case3\n  a = 0.0\n  print *, lsm_getsign(a)\n\n  !case4\n  a = 1.234\n  print *, lsm_getsign(a)\n\n  !case5\n  a = -0.123\n  print *, lsm_getsign(a)\nend program main",
            "result": [
                "1.00000000",
                "-1.00000000",
                "1.00000000",
                "1.00000000",
                "-1.00000000"
            ]
        },
        "code": "function lsm_getsign(a)\n\timplicit none\n\treal\t\t\t\t\t:: lsm_getsign\n\treal\t\t\t\t\t:: a\n\tlsm_getsign = 1.0\n\tif( a < 0 ) then\n\t\tlsm_getsign = -1.0\n\tend if\n\treturn\nend function lsm_getsign\n"
    },
    {
        "instruction": [
            "Write a Fortran function named lsm_getupwind that determines the value to be returned based on the input arguments. The function takes in three arguments: u (real), n (real), and p (real). The return type of the function is also real. \n\nThe function first assigns the value of n to the return variable lsm_getupwind. Then, it checks if the value of u is less than 0. If it is, the return variable is updated with the value of p. Finally, the function returns the value of lsm_getupwind.\n\nTo use this function, provide the values for u, n, and p as input arguments and the function will return the appropriate value based on the conditions.",
            "Create a Fortran function named lsm_getupwind that determines the upwind value based on the input values of u, n, and p. The function takes in three real numbers as input arguments (u, n, p) and returns a real number as the output. The function first assigns the value of n to the output variable lsm_getupwind and then checks if u is less than 0. If u is less than 0, the output value is changed to p. Finally, the function returns the updated value of lsm_getupwind.",
            "Create a Fortran function called lsm_getupwind that takes in three real numbers as input arguments: u, n, and p. The function returns a single real number. The purpose of this function is to determine the value to be returned based on the value of the input argument u. \n\nTo create the function, initialize the return value to be equal to the input argument n. Then, check if the value of u is less than 0. If it is, update the return value to be equal to the input argument p. Finally, return the updated value."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real :: u, n, p\n  \n  !case1\n  u = 1.5\n  n = 10.0\n  p = 20.0\n  print *, lsm_getupwind(u, n, p)\n\n  !case2\n  u = -2.0\n  n = 5.0\n  p = 15.0\n  print *, lsm_getupwind(u, n, p)\n\n  !case3\n  u = 0.0\n  n = 100.0\n  p = 200.0\n  print *, lsm_getupwind(u, n, p)\n\n  !case4\n  u = -1.5\n  n = -10.0\n  p = -20.0\n  print *, lsm_getupwind(u, n, p)\n\n  !case5\n  u = 2.5\n  n = 0.0\n  p = 0.0\n  print *, lsm_getupwind(u, n, p)\nend program main\n    ",
            "result": [
                "10.0000000",
                "15.0000000",
                "100.000000",
                "-20.0000000",
                "0.00000000"
            ]
        },
        "code": "function lsm_getupwind(u, n, p)\n\timplicit none\n\treal\t\t\t\t\t:: lsm_getupwind\n\treal\t\t\t\t\t:: u\n\treal\t\t\t\t\t:: n, p\n\tlsm_getupwind = n\n\tif( u .lt. 0 ) then\n\t\tlsm_getupwind = p\n\tendif\n\treturn\nend function lsm_getupwind\n"
    },
    {
        "instruction": [
            "Provide a Fortran function named lacz_gamma that calculates the gamma function for a given real number. The input parameter is a single real number (a) and the output parameter is also a real number (g). The gamma function is evaluated using a recursive algorithm and precomputed values. The function computes the gamma function based on the input value of 'a' by applying different calculations depending on its value. The computation involves mathematical operations such as sine, exponential, square root, and power.",
            "Write a recursive Fortran function named lacz_gamma that calculates the value of the gamma function for a given input argument. The function takes a single input argument of type real and returns a single output argument of type real. The input argument represents the value for which the gamma function needs to be computed. The function uses precomputed values, such as the value of pi and an array of constants, to perform the calculations. The function utilizes conditional statements and loops to determine the appropriate calculation method based on the value of the input argument. The computed gamma value is then returned as the output of the function.",
            "Create a Fortran function named lacz_gamma that calculates the gamma function for a given input value. The function accepts one input argument of type real and returns one output argument of type real. The input argument represents the value for which the gamma function is to be calculated. The output argument represents the result of the gamma function calculation. The function uses a recursive approach and includes precomputed values to improve efficiency. The code includes mathematical operations such as sin, sqrt, and exp, as well as loop iteration."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real :: a\n  \n  !case1\n  a = 0.5\n  print *, lacz_gamma(a)\n  \n  !case2\n  a = 1.5\n  print *, lacz_gamma(a)\n  \n  !case3\n  a = 2.0\n  print *, lacz_gamma(a)\n  \n  !case4\n  a = 3.7\n  print *, lacz_gamma(a)\n  \n  !case5\n  a = 5.5\n  print *, lacz_gamma(a)\n  \nend program main",
            "result": [
                "1.77245414",
                "0.886227071",
                "1.00000036",
                "4.17065382",
                "52.3428383"
            ]
        },
        "code": "  recursive function lacz_gamma(a) result(g)\n    real, intent(in) :: a\n    real :: g\n\n    real, parameter :: pi = 3.14159265358979324\n    integer, parameter :: cg = 7\n\n    ! these precomputed values are taken by the sample code in wikipedia,\n    ! and the sample itself takes them from the gnu scientific library\n    real, dimension(0:8), parameter :: p = &\n         (/ 0.99999999999980993, 676.5203681218851, -1259.1392167224028, &\n         771.32342877765313, -176.61502916214059, 12.507343278686905, &\n         -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7 /)\n\n    real :: t, w, x\n    integer :: i\n\n    x = a\n\n    if ( x < 0.5 ) then\n       g = pi / ( sin(pi*x) * lacz_gamma(1.0-x) )\n    else\n       x = x - 1.0\n       t = p(0)\n       do i=1, cg+2\n          t = t + p(i)/(x+real(i))\n       end do\n       w = x + real(cg) + 0.5\n       g = sqrt(2.0*pi) * w**(x+0.5) * exp(-w) * t\n    end if\n  end function lacz_gamma\n"
    },
    {
        "instruction": [
            "Create a Fortran function called strcmp that compares two input strings. The function takes two character strings as input parameters and returns an integer value. The function uses the Fortran intrinsic function lgt to compare the lengths of the two strings. If the length of the first string is greater than the length of the second string, the function returns 1. If the length of the second string is greater than the length of the first string, the function returns -1. If the lengths are equal, the function returns 0.",
            "Give me a Fortran function code named strcmp to compare two strings and determine their relationship. The function takes two input arguments of type character and returns an integer value. The number of input arguments is 2 and the test_data type is [character(*), character(*)]. The number of output arguments is 1 and the test_data type is [integer].",
            "Create a Fortran function called strcmp that compares two strings. The function takes in two input arguments, both of type character and of any length. The function returns an integer value as the result. The purpose of this function is to compare the lengths of the two input strings and return 1 if the first string is longer, -1 if the second string is longer, and 0 if the two strings have the same length."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=100) :: string1, string2\n  \n  !case1\n  string1 = \"hello\"\n  string2 = \"world\"\n  print *, strcmp(string1, string2)\n  \n  !case2\n  string1 = \"apple\"\n  string2 = \"apple\"\n  print *, strcmp(string1, string2)\n  \n  !case3\n  string1 = \"Fortran\"\n  string2 = \"fortran\"\n  print *, strcmp(string1, string2)\n  \n  !case4\n  string1 = \"abc\"\n  string2 = \"def\"\n  print *, strcmp(string1, string2)\n  \n  !case5\n  string1 = \"123\"\n  string2 = \"456\"\n  print *, strcmp(string1, string2)\n  \nend program main",
            "result": [
                "-1",
                "0",
                "-1",
                "-1",
                "-1"
            ]
        },
        "code": "  function strcmp(string1, string2)\n    !\n    ! compares two strings, a-la c\n    !\n    integer :: strcmp\n    character(*) :: string1\n    character(*) :: string2\n\n    if (lgt(trim(string1), trim(string2))) then\n       strcmp = 1\n    else if (lgt(trim(string2), trim(string1))) then\n       strcmp = -1\n    else\n       strcmp = 0\n    end if\n  end function strcmp\n"
    },
    {
        "instruction": [
            "Create a Fortran function named \"character_is_integer\" to determine whether a given character is an integer or not. The function takes in one input argument of type \"character\" and returns one output argument of type \"logical\".",
            "Provide a Fortran function code named character_is_integer, which checks if a given character is an integer digit. The function takes one input argument of type character(len=1) and returns a logical value. The name of the function is character_is_integer.",
            "Create a Fortran function named character_is_integer to determine whether a given character is an integer. The function takes one input parameter of type character and returns a logical value."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=1) :: c\n\n  !case1\n  c = '0'\n  print *, character_is_integer(c)\n\n  !case2\n  c = '5'\n  print *, character_is_integer(c)\n\n  !case3\n  c = '9'\n  print *, character_is_integer(c)\n\n  !case4\n  c = 'A'\n  print *, character_is_integer(c)\n\n  !case5\n  c = ' '\n  print *, character_is_integer(c)\n\nend program main",
            "result": [
                "T",
                "T",
                "T",
                "F",
                "F"
            ]
        },
        "code": "    pure elemental function character_is_integer(c) result(is_integer)\n\n    implicit none\n\n    character(len=1),intent(in) :: c\n    logical                     :: is_integer\n\n    is_integer = c>='0' .and. c<='9'\n\n    end function character_is_integer\n"
    },
    {
        "instruction": [
            "Write a Fortran function named true2 that calculates the value of a mathematical expression based on the input parameters. The function takes in two double precision floating-point numbers (x and y) as input, along with two integers (comp and eigen). The function returns a double precision floating-point number as the output. The expression being evaluated is (1-x)^5 + y^5.",
            "Create a Fortran function named true2 that takes in two double precision floating point numbers (x and y), as well as two integers (comp and eigen) as input parameters. The function calculates the value of (1-x)^5 + y^5 and returns it as a double precision floating point number. The function should be defined with the \"implicit none\" statement to enforce explicit declaration of variables.",
            "Create a Fortran function called true2 that takes in four input arguments: two double precision numbers (x and y), and two integers (comp and eigen). The function computes the value of (1-x)^5 + y^5 and returns it as a double precision number. The function is defined using the \"function\" keyword and the output value is declared using the \"double precision\" type. The input arguments are declared using the \"intent(in)\" attribute and their types are specified as \"double precision\" for x and y, and \"integer\" for comp and eigen."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  double precision :: x, y\n  integer :: comp, eigen\n  \n  !case1\n  x = 0.5\n  y = 1.0\n  comp = 2\n  eigen = 3\n  print *, true2(x, y, comp, eigen)\n\n  !case2\n  x = 0.0\n  y = 0.0\n  comp = 1\n  eigen = 5\n  print *, true2(x, y, comp, eigen)\n\n  !case3\n  x = 2.5\n  y = 3.8\n  comp = 4\n  eigen = 2\n  print *, true2(x, y, comp, eigen)\n\n  !case4\n  x = 0.1\n  y = 0.1\n  comp = 3\n  eigen = 1\n  print *, true2(x, y, comp, eigen)\n\n  !case5\n  x = 1.5\n  y = 2.7\n  comp = 5\n  eigen = 4\n  print *, true2(x, y, comp, eigen)\nend program main\n",
            "result": [
                "1.0312500000000000",
                "1.0000000000000000",
                "784.75788028648503",
                "0.59049999511241902",
                "143.45783267054125"
            ]
        },
        "code": "function true2(x,y,comp,eigen)\nimplicit none\ndouble precision, intent(in) :: x,y\ninteger, intent(in) :: comp,eigen\ndouble precision :: true2\ntrue2 = (1-x)**5 + y**5\nend function true2\n"
    },
    {
        "instruction": [
            "Create a Fortran function called \"wr\" that takes a single input argument of type real(8). The function calculates and returns a value of type real(8). The purpose of this function is to compute the value of \"wr\" based on the input argument. If the input argument is less than or equal to 1.0, the function subtracts the input argument from 1.0 and assigns the result to \"wr\". Otherwise, \"wr\" remains 0.0. The function does not have any output arguments.",
            "Provide a Fortran function named \"wr\" that takes a single input argument of type real(8) and returns a value of the same type. The purpose of this function is to calculate a value based on the input argument. If the input argument is less than or equal to 1.0, the function will compute the difference between 1.0 and the input argument and assign it to the variable \"wr\". The function does not have any output statements, so it is necessary to ensure that the calculated value of \"wr\" is returned by the function.",
            "Create a Fortran function named \"wr\" that takes in a single input argument of type real(8). The function returns a real(8) value. \n\nThe purpose of the \"wr\" function is to compute the value of \"wr\" based on the input argument \"nr\". \n\nIn the function, initialize \"wr\" to 0.0. If \"nr\" is less than or equal to 1.0, set \"wr\" to the difference between 1.0 and \"nr\". \n\nEnsure that the function is a pure function by specifying \"pure\" before the function declaration."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real(8) :: nr\n\n  !case1\n  nr = 0.5\n  print *, wr(nr)\n\n  !case2\n  nr = 1.5\n  print *, wr(nr)\n\n  !case3\n  nr = -0.75\n  print *, wr(nr)\n\n  !case4\n  nr = 2.3\n  print *, wr(nr)\n\n  !case5\n  nr = 1.0\n  print *, wr(nr)\nend program main",
            "result": [
                "0.50000000000000000",
                "0.0000000000000000",
                "1.7500000000000000",
                "0.0000000000000000",
                "0.0000000000000000"
            ]
        },
        "code": "pure function wr(nr)\n    real(8), intent(in) :: nr\n    real(8) :: wr\n    wr = 0.0\n    if (nr <= 1.0) then\n        wr = 1.0 - nr\n    endif\nend function\n"
    },
    {
        "instruction": [
            "Create a Fortran function named freefall that calculates the time it takes for an object to fall from a certain height. The function takes one input argument of type real, which represents the height of the fall. The function returns one output argument of type real, which represents the time it takes for the object to fall. The function utilizes the gravitational constant 'g' and the input height to compute the time using the formula (2 * g * height) ** 0.5.",
            "Create a Fortran function named freefall that calculates the time it takes for an object to fall from a certain height. The function takes one input argument of type real, which represents the height of the object. The function returns a value of type real, which represents the time it takes for the object to fall. Use the formula (2 * g * height) ** 0.5 to calculate the time, where g is a constant equal to 9.80665 m/s^2.",
            "Write a Fortran function named freefall that calculates the time it takes for an object to fall from a given height. The function takes one input parameter of type real named \"high\" which represents the height of the object. The function returns one output parameter of type real named \"freefall\" which represents the time it takes for the object to fall. The function uses the formula (2 * g * high) ** 0.5, where \"g\" is a constant representing the acceleration due to gravity."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real :: high\n  \n  !case1\n  high = 10.0\n  print *, freefall(high)\n\n  !case2\n  high = 100.0\n  print *, freefall(high)\n\n  !case3\n  high = 0.0\n  print *, freefall(high)\n\n  !case4\n  high = 50.5\n  print *, freefall(high)\n\n  !case5\n  high = 75.3\n  print *, freefall(high)\nend program main",
            "result": [
                "14.0047493",
                "44.2869072",
                "0.00000000",
                "31.4717598",
                "38.4302177"
            ]
        },
        "code": "function freefall(high)\r\n\timplicit none\r\n\treal,parameter :: g = 9.80665\r\n    real :: high\r\n\treal :: freefall\r\n\tfreefall = (2 * g * high) ** 0.5\r\n\treturn\r\nend function\r\n"
    },
    {
        "instruction": [
            "Write a Fortran function code named circarea that calculates the area of a circle based on its radius. The function takes one input parameter, radius, which is a real number. The function returns one output parameter, area, which is also a real number.",
            "Write a Fortran function code named circarea that calculates the area of a circle given its radius. The function takes one input argument of type real, representing the radius of the circle. The function returns one output argument of type real, representing the area of the circle. Implement the function using the formula \u03c0 * radius^2.",
            "Create a Fortran function named \"circarea\" that calculates the area of a circle given its radius. The function accepts one input argument of type real, representing the radius of the circle. The output of the function is a real value, representing the area of the circle. To calculate the area, the function multiplies the value of pi with the square of the radius. Make sure to import the necessary pi constant from a library or define it within the function."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real :: radius\n  \n  !case1\n  radius = 2.0\n  print *, circarea(radius)\n\n  !case2\n  radius = 5.5\n  print *, circarea(radius)\n\n  !case3\n  radius = 0.1\n  print *, circarea(radius)\n\n  !case4\n  radius = 3.14\n  print *, circarea(radius)\n\n  !case5\n  radius = 10.0\n  print *, circarea(radius)\n  \nend program main",
            "result": [
                "1.83665387E-40",
                "1.38896564E-39",
                "4.59625896E-43",
                "4.52714692E-40",
                "4.59163468E-39"
            ]
        },
        "code": "  function circarea(radius) result(area)\n    real,intent(in)::radius\n    real::area\n    \n    area = pi * radius * radius\n    return\n  end function circarea\n"
    },
    {
        "instruction": [
            "Write a Fortran function named \"circperi\" to calculate the circumference of a circle given the radius as input. The function takes one input argument of type \"real\" and returns one output argument of type \"real\".",
            "Create a Fortran function named circperi that calculates the circumference of a circle based on the given radius. The function takes one input parameter, radius, which is a real number. The output parameter, circumference, is also a real number.",
            "Provide a Fortran function named circperi that calculates the circumference of a circle based on the given radius. The function takes one input argument of type real, representing the radius of the circle. It returns one output argument of type real, representing the calculated circumference. Use the formula circumference = 2 * pi * radius to calculate the circumference."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real :: radius\n\n  !case 1\n  radius = 3.5\n  print *, circperi(radius)\n\n  !case 2\n  radius = 0.0\n  print *, circperi(radius)\n\n  !case 3\n  radius = 10.0\n  print *, circperi(radius)\n\n  !case 4\n  radius = -2.5\n  print *, circperi(radius)\n\n  !case 5\n  radius = 1.2345\n  print *, circperi(radius)\nend program main",
            "result": [
                "3.21385000E-40",
                "0.00000000",
                "9.18242858E-40",
                "-2.29560714E-40",
                "1.13356638E-40"
            ]
        },
        "code": "  function circperi(radius) result(circumference)\n    real,intent(in)::radius\n    real::circumference\n    \n    circumference = 2 * pi * radius\n    return\n  end function circperi\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named julian to calculate the Julian day corresponding to a given date. The function takes three input arguments of type integer: year, mnth, and mday. It returns a single output argument of type integer, which represents the Julian day.",
            "Give me a Fortran function code named julian to calculate the Julian day corresponding to a given date in year-month-day format. The function takes three input arguments: mday (day of the month), mnth (month of the year), and year (four-digit calendar year), all of integer data type. The output is the Julian day, also of integer data type.",
            "Provide a Fortran function code named julian that calculates the Julian day corresponding to a given date. The function takes three input arguments: year (integer), mnth (integer), and mday (integer). The output is a single integer representing the Julian day."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: year, mnth, mday\n  \n  !case1\n  year = 2020\n  mnth = 1\n  mday = 1\n  print *, julian(year, mnth, mday)\n\n  !case2\n  year = 2020\n  mnth = 2\n  mday = 29\n  print *, julian(year, mnth, mday)\n\n  !case3\n  year = 2021\n  mnth = 12\n  mday = 31\n  print *, julian(year, mnth, mday)\n\n  !case4\n  year = 2000\n  mnth = 2\n  mday = 29\n  print *, julian(year, mnth, mday)\n\n  !case5\n  year = 1999\n  mnth = 6\n  mday = 15\n  print *, julian(year, mnth, mday)\n  \nend program main",
            "result": [
                "1",
                "60",
                "365",
                "60",
                "166"
            ]
        },
        "code": "function julian (year, mnth, mday)\n\n!-------------------------------------------------------------------------------\n! name:     julian day\n! purpose:  returns the julian day (1...365,366) corresponding to the date\n!           mnth-mday-year.  note:  this is not the julian date -- only the\n!           day-number.  to get the julian date:\n!              jdate = 1000 * year  +  julian ( year , mnth , mday )\n! revised:  ?? may 1988  modified for romnet.  (???)\n!           ?? aug 1990  modified for rom 2.2:  improved comments; improved\n!                        algorithm using if-then-else if construction. (???)\n!           10 sep 2001  converted to free-form f90.  (t. otte)\n!           07 sep 2011  updated disclaimer.  (t. otte)\n!-------------------------------------------------------------------------------\n\n  implicit none\n\n  integer                      :: julian   ! julian day from arguments\n  integer                      :: l\n  integer                      :: m\n  integer,       intent(in)    :: mday     ! day of month [1-31]\n  integer,       intent(in)    :: mnth     ! month of year [1-12]\n  integer                      :: n\n  integer,       intent(in)    :: year     ! four-digit calendar year\n\n  m = mod((mnth + 9), 12)\n  n = (m * 153 + 2) / 5 + mday + 58\n\n  if ( mod(year, 4) /= 0 ) then\n    l = 365\n  else if ( mod(year, 100) /= 0 ) then\n    l = 366\n    n = 1 + n\n  else if ( mod(year, 400) /= 0 )  then\n    l = 365\n  else \n    l = 366\n    n = 1 + n\n  end if\n\n  julian = 1 + mod(n, l)\n\nend function julian\n"
    },
    {
        "instruction": [
            "Write a Fortran function named is_leap_year to determine whether a given year is a leap year or not. The function takes an integer input parameter \"year\" and an optional logical output parameter \"has_error\". The function returns a logical value indicating whether the year is a leap year or not. \n\nTo use the optional output parameter \"has_error\", pass it as an argument when calling the function. If the year is less than or equal to 1582, the output parameter \"has_error\" will be set to true, indicating an error. Otherwise, it will be set to false.\n\nTo determine whether a year is a leap year, the function checks if the year is divisible by 4. If it is, it further checks if it is divisible by 100. If it is, it checks if it is divisible by 400. If all these conditions are met, the year is not a leap year and the function returns false. Otherwise, the year is a leap year and the function returns true.",
            "Write a Fortran function named is_leap_year to determine if a given year is a leap year or not. The function takes an input argument of type integer, representing the year to be checked. It also has an optional output argument of type logical, named has_error, which indicates if there was an error in the input (year <= 1582). The function returns a logical value, is_leap, indicating if the input year is a leap year or not.",
            "Write a Fortran function named is_leap_year to determine if a given year is a leap year. The function takes one input argument of type integer, representing the year to be checked. It also has an optional output argument of type logical, indicating whether an error occurred during the calculation. The function returns a logical value indicating whether the year is a leap year or not.\n\nTo use the function, provide the year as the input argument. The function will return a logical value indicating whether the year is a leap year or not. Optionally, you can include the has_error argument to check if an error occurred during the calculation.\n\nThe function first checks if the provided year is less than or equal to 1582 and sets the has_error flag accordingly. Then, it applies the rules for determining leap years: if the year is divisible by 4, it checks if it is also divisible by 100. If it is divisible by 100, it further checks if it is divisible by 400. Based on these conditions, the function sets the is_leap flag to true or false.\n\nTo summarize, the is_leap_year function takes an integer argument representing a year and returns a logical value indicating whether the year is a leap year or not. It also has an optional logical output argument to indicate any error that occurred during the calculation."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: year\n  logical :: is_leap, has_error\n  \n  !case1\n  year = 2000\n  print *, is_leap_year(year)\n  \n  !case2\n  year = 1900\n  print *, is_leap_year(year)\n  \n  !case3\n  year = 2020\n  print *, is_leap_year(year)\n  \n  !case4\n  year = 1581\n  print *, is_leap_year(year, has_error)\n  \n  !case5\n  year = 1700\n  print *, is_leap_year(year)\nend program main",
            "result": [
                "F",
                "T",
                "T",
                "F",
                "T"
            ]
        },
        "code": "    function is_leap_year(year, has_error) result(is_leap)\n        implicit none\n        integer, intent(in) :: year\n        logical, optional, intent(out) :: has_error\n        logical :: is_leap\n\n        if (present(has_error)) then\n            has_error = year <= 1582\n        end if\n        if (mod(year, 4) == 0) then\n            if (mod(year, 100) == 0) then\n                if (mod(year, 400) == 0) then\n                    is_leap = .false.\n                else\n                    is_leap = .true.\n                end if\n            else\n                is_leap = .true.\n            end if\n        else\n            is_leap = .false.\n        end if\n    end function is_leap_year\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named aave that computes the area mean of a field in Cartesian coordinates. The input parameter is a two-dimensional array of real numbers, representing the field. The function returns a single real number as the result.",
            "Write a Fortran function code named aave that calculates the area mean of a field in Cartesian coordinates. The function takes a two-dimensional array of real numbers as input. The number of input arguments is 1 and the data type is [real,dimension(:,:),intent(in)]. The function returns a single real number as output. \n\nTo calculate the area mean, the function iterates over each element of the input array, summing up the values and counting the number of elements. The result is then obtained by dividing the sum by the total number of elements.\n\nWrite the instruction as follows:\n\"Create a Fortran function named aave that calculates the area mean of a field in Cartesian coordinates. The function takes a two-dimensional array of real numbers as input. The function returns a single real number as output. The function calculates the area mean by summing up the values of all elements in the input array and dividing it by the total number of elements. The input array is declared as 'real,dimension(:,:),intent(in)'. The output is declared as 'real'. Use the provided code as a starting point.\"",
            "Provide a Fortran function named aave to calculate the area mean (res) of a field (f) given in Cartesian coordinates. The function takes a 2D array of real numbers (f) as input and returns a single real number (res) as output. The function calculates the sum of all elements in the array and divides it by the total number of elements to obtain the area mean. The input array (f) should be declared as intent(in) and have dimensions (nlon, nlat), where nlon is the number of longitude points and nlat is the number of latitude points. The function uses a nested do-loop structure to iterate over each element in the array and accumulate the sum and the total weight. Finally, the function computes the area mean by dividing the sum by the total weight."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: nlon, nlat\n  real, allocatable :: f(:,:)\n  \n  !case1\n  nlon = 3\n  nlat = 3\n  allocate(f(nlon,nlat))\n  f = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0], [nlon, nlat])\n  print *, aave(f)\n  deallocate(f)\n\n  !case2\n  nlon = 4\n  nlat = 2\n  allocate(f(nlon,nlat))\n  f = reshape([0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0], [nlon, nlat])\n  print *, aave(f)\n  deallocate(f)\n\n  !case3\n  nlon = 2\n  nlat = 5\n  allocate(f(nlon,nlat))\n  f = reshape([10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0, 80.0, 90.0, 100.0], [nlon, nlat])\n  print *, aave(f)\n  deallocate(f)\n\n  !case4\n  nlon = 1\n  nlat = 1\n  allocate(f(nlon,nlat))\n  f = reshape([5.0], [nlon, nlat])\n  print *, aave(f)\n  deallocate(f)\n\n  !case5\n  nlon = 3\n  nlat = 4\n  allocate(f(nlon,nlat))\n  f = reshape([1.0, -2.0, 3.0, -4.0, 5.0, -6.0, 7.0, -8.0, 9.0, -10.0, 11.0, -12.0], [nlon, nlat])\n  print *, aave(f)\n  deallocate(f)\nend program main",
            "result": [
                "5.00000000",
                "3.50000000",
                "55.0000000",
                "5.00000000",
                "-0.500000000"
            ]
        },
        "code": "function aave(f) result(res)\n  !   calculation of area mean (res) of field f in cartesian coordinates.\n  !   simplest possible way.\n  !\n  real,dimension(:,:),intent(in) :: f\n  real :: res,sum,wsum\n  integer :: i,j,nlon,nlat\n  nlon=size(f,1)\n  nlat=size(f,2)\n\n  sum=0\n  wsum=0\n  do j=1,nlat\n     do i=1,nlon\n        sum=sum+f(i,j)\n        wsum=wsum+1.\n     enddo\n  enddo\n  res=sum/wsum\n\nend function aave\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named binomial that calculates the binomial coefficient of two given integers. The function takes two input arguments, both of type integer(kind=16), which represent the values of n and k. The function returns a single output argument of type integer(kind=16), which represents the calculated binomial coefficient. The function uses a loop to iteratively calculate the binomial coefficient using the formula: res = (n - i) / (i + 1), where i ranges from 0 to k-1. If k is equal to 0, the function sets the result to 1.",
            "Write a Fortran function named binomial that calculates the binomial coefficient using the formula \"n choose k\". The function takes two input arguments of type integer(kind=16) representing n and k. The function returns a single output argument of type integer(kind=16) representing the binomial coefficient.",
            "Provide a Fortran function code named binomial to compute the binomial coefficient. The function takes two input arguments, n and k, both of type integer(kind=16). The output is a single integer(kind=16) result. \n\nTo compute the binomial coefficient, the function utilizes a loop to iterate from 0 to k-1 and calculates the result by multiplying (n - i) and dividing it by (i + 1). \n\nPlease note that the code checks if k is equal to 0 and returns 1 in that case."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer(kind=16) :: n, k, res\n  \n  !case1\n  n = 5\n  k = 2\n  res = binomial(n, k)\n  print *, res\n\n  !case2\n  n = 10\n  k = 5\n  res = binomial(n, k)\n  print *, res\n\n  !case3\n  n = 8\n  k = 3\n  res = binomial(n, k)\n  print *, res\n\n  !case4\n  n = 15\n  k = 8\n  res = binomial(n, k)\n  print *, res\n\n  !case5\n  n = 20\n  k = 10\n  res = binomial(n, k)\n  print *, res\nend program main",
            "result": [
                "10",
                "252",
                "56",
                "6435",
                "184756"
            ]
        },
        "code": "  function binomial(n, k) result (res)\n    integer(kind=16), intent(in) :: n, k\n    integer(kind=16) :: res\n    integer(kind=16) :: i\n\n    if (k == 0) then\n      res = 1\n      return\n    end if\n\n    res = 1\n    do i = 0, k - 1\n      res = res*(n - i)/(i + 1)\n    end do\n  end function\n"
    },
    {
        "instruction": [
            "Create a Fortran function named nextdiffid that finds the minimum value in an array called dist, while skipping the elements that have been marked as checked. The function takes in three parameters: the integer n representing the size of the array, the real array dist of size n, and the logical array checksecondary of size n. The function returns an integer value representing the position (id) of the minimum value found.",
            "Create a Fortran function called nextdiffid that takes as input an array of distances, the number of elements in the array, and a logical array indicating which elements have been checked. The function returns the position of the minimum value in the distance array that has not been checked yet.\n\nTo use the function, provide the following input arguments:\n- dist: a 1-dimensional array of real numbers representing the distances\n- n: an integer indicating the number of elements in the dist array\n- checksecondary: a 1-dimensional logical array with the same size as dist, indicating which elements have been checked\n\nThe function will return an integer value representing the position (id) of the minimum value in dist that has not been checked yet.\n\nEnsure that the variables nextdiffid, vmin, i, and dist are defined appropriately before calling the function.",
            "Give me a Fortran function code named nextdiffid that finds the minimum value in an array called dist and returns its position (id). The function takes 3 input parameters: an integer n, a real array dist of size n, and a logical array checksecondary of size n. The function returns an integer value."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n\n  real, allocatable :: dist(:)\n  logical, allocatable :: checksecondary(:)\n  \n  !case1\n  n=5\n  allocate(dist(n))\n  allocate(checksecondary(n))\n  dist = [1.0, 2.0, 3.0, 4.0, 5.0]\n  checksecondary = [.true., .false., .false., .false., .false.]\n  print *, nextdiffid(dist, n, checksecondary)\n  deallocate(dist)\n  deallocate(checksecondary)\n\n  !case2\n  n=4\n  allocate(dist(n))\n  allocate(checksecondary(n))\n  dist = [5.0, 4.0, 3.0, 2.0]\n  checksecondary = [.false., .false., .false., .false.]\n  print *, nextdiffid(dist, n, checksecondary)\n  deallocate(dist)\n  deallocate(checksecondary)\n\n  !case3\n  n=3\n  allocate(dist(n))\n  allocate(checksecondary(n))\n  dist = [10.0, 20.0, 30.0]\n  checksecondary = [.true., .true., .true.]\n  print *, nextdiffid(dist, n, checksecondary)\n  deallocate(dist)\n  deallocate(checksecondary)\n\n  !case4\n  n=5\n  allocate(dist(n))\n  allocate(checksecondary(n))\n  dist = [1.0, 2.0, 3.0, 2.0, 1.0]\n  checksecondary = [.false., .true., .false., .true., .false.]\n  print *, nextdiffid(dist, n, checksecondary)\n  deallocate(dist)\n  deallocate(checksecondary)\n\n  !case5\n  n=6\n  allocate(dist(n))\n  allocate(checksecondary(n))\n  dist = [5.0, 5.0, 5.0, 5.0, 5.0, 5.0]\n  checksecondary = [.false., .false., .false., .false., .false., .false.]\n  print *, nextdiffid(dist, n, checksecondary)\n  deallocate(dist)\n  deallocate(checksecondary)\nend program main",
            "result": [
                "2",
                "4",
                "0",
                "1",
                "1"
            ]
        },
        "code": "function nextdiffid(dist,n,checksecondary)\n! find the minimum value in dist skipping the vertex checked yet and returns\n! its position (id)\n\n  integer :: nextdiffid,n\n  real, dimension(n) :: dist\n  logical, dimension(n) :: checksecondary\n\n  integer :: i\n  real :: vmin\n\n  nextdiffid=0\n  vmin=infinity\n  do i=1,n\n     if (checksecondary(i)) cycle\n     if (dist(i) < vmin) then\n        vmin=dist(i)\n        nextdiffid=i\n     endif\n  enddo\n  return\nend function nextdiffid\n"
    },
    {
        "instruction": [
            "Please provide a Fortran function named \"dplane\" to calculate the position of a point in a plane based on the distances and radii of three points. The function takes in five input parameters: d12, d13, d23, r1, and r2, all of type real. The output of the function is a single real value named \"dplane\".",
            "Give me a Fortran function code named dplane that calculates the distance of a point (v3) from a plane defined by two other points (v1 and v2). The function takes 5 input arguments: d12, d13, d23, r1, and r2, all of type real. The function returns a single output of type real, which represents the distance of v3 from the plane.",
            "Write a Fortran function named dplane that calculates the position of a point in a plane based on the distances between three points and the radii of two circles. The function takes in five input arguments of type real: d12, d13, d23, r1, and r2. It returns a single output argument of type real, which represents the position of the point in the plane.\n\nTo use the function, provide the distances d12, d13, and d23 between the three points and the radii r1 and r2 of the two circles. The function will compute the position of the point in the plane based on these inputs and return the result.\n\nNote: The code includes additional calculations and conditions for repositioning the point based on the radii of the circles."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real :: d12, d13, d23, r1, r2, result\n  \n  ! Case 1\n  d12 = 5.0\n  d13 = 4.0\n  d23 = 3.0\n  r1 = 2.0\n  r2 = 1.0\n  result = dplane(d12, d13, d23, r1, r2)\n  print *, result\n  \n  ! Case 2\n  d12 = 10.0\n  d13 = 7.0\n  d23 = 8.0\n  r1 = 3.0\n  r2 = 2.0\n  result = dplane(d12, d13, d23, r1, r2)\n  print *, result\n  \n  ! Case 3\n  d12 = 15.0\n  d13 = 12.0\n  d23 = 9.0\n  r1 = 5.0\n  r2 = 5.0\n  result = dplane(d12, d13, d23, r1, r2)\n  print *, result\n  \n  ! Case 4\n  d12 = 8.0\n  d13 = 6.0\n  d23 = 4.0\n  r1 = 4.0\n  r2 = 3.0\n  result = dplane(d12, d13, d23, r1, r2)\n  print *, result\n  \n  ! Case 5\n  d12 = 12.0\n  d13 = 9.0\n  d23 = 6.0\n  r1 = 3.0\n  r2 = 2.0\n  result = dplane(d12, d13, d23, r1, r2)\n  print *, result\nend program main",
            "result": [
                "3.71150970",
                "8.10926819",
                "12.1999998",
                "6.22570515",
                "6.68570471"
            ]
        },
        "code": "function dplane(d12,d13,d23,r1,r2)\n\n  real :: dplane,d12,d13,d23,r1,r2\n\n  real :: x,y,xc,yc\n  real :: dr,xn,yn,dn,d13n,d23n\n\n! position of v3\n  x=(d12**2-d23**2+d13**2)/(2*d12)\n  y=sqrt(max(d13**2-x**2,0.))\n! difference of distance at the base\n  dr=abs(r1-r2)\n! computation of the new base length\n  dn=sqrt(d12**2.-dr**2.)\n  if (r1 < r2) then\n! case where v2 remains and v1 is changed\n     xn=(d12**2-dn**2+dr**2)/(2*d12)\n     yn=(sqrt(max(dr**2-xn**2,0.)))\n     d13n=sqrt((x-xn)**2.+(y-yn)**2.)\n! reposition of v3 in the new frame\n     x=(dn**2-d23**2+d13n**2)/(2*dn)\n     if (x > 0 .and. x < dn) then\n        y=sqrt(max(d13n**2-x**2,0.))\n        dplane=r2+y\n     else\n        dplane=infinity\n     endif\n  else\n! case where v1 remains and v2 is changed\n     xn=(d12**2-dr**2+dn**2)/(2*d12)\n     yn=(sqrt(max(dn**2-xn**2,0.)))\n     d23n=sqrt((x-xn)**2.+(y-yn)**2.)\n! reposition of v3 in the new frame\n     x=(dn**2-d23n**2+d13**2)/(2*dn)\n     if (x > 0 .and. x < dn) then\n        y=sqrt(max(d13**2-x**2,0.))\n        dplane=r1+y\n     else\n        dplane=infinity\n     endif\n  endif\nend function dplane\n"
    },
    {
        "instruction": [
            "Write a Fortran function named euler that calculates the numerical approximation of a solution to a differential equation using Euler's method. The function takes in four input parameters: df (a function that represents the derivative of the solution), y0 (the initial value of the solution), t (an array of time points), and n (the number of time points). The function also returns an array, y, which contains the approximated solution at each time point.\n\nTo use the function, you need to provide the derivative function (df) as an interface and ensure that it takes a double precision time (t) and solution (y) as input and returns the derivative value (u) as output.\n\nInside the function, the initial value of the solution (y0) is assigned to the first element of the output array (y). Then, a loop is performed from the second time point to the last time point (n). At each iteration, the time step (dt) is calculated as the difference between the current and previous time points. The solution at the current time point is obtained by adding the product of the derivative at the previous time point and the time step to the solution at the previous time point.\n\nFinally, the approximated solution array (y) is returned as the output of the function.",
            "Write a Fortran function code named \"euler\" that implements the Euler method for numerical integration of a system of ordinary differential equations. The function takes four input parameters: a function \"df\" that defines the derivative of the system, an initial value \"y0\" for the dependent variable, an array \"t\" of time values, and the number of time steps \"n\". The function returns an array \"y\" containing the solution of the system at the specified time points. The input variable \"df\" is a function interface that takes a time value \"t\" and a dependent variable value \"y\" and returns the derivative of the system at that point. The function uses a for loop to iteratively compute the solution by approximating the derivative at each time step using the provided \"df\" function and updating the solution using the Euler method.",
            "Write a Fortran function named \"euler\" that calculates the approximate solution to a differential equation using the Euler method. The function takes four input parameters: a function \"df\" that represents the derivative of the unknown function, a double precision initial value \"y0\", an array \"t\" of double precision values representing the time points at which the solution is evaluated, and an integer \"n\" representing the number of time points. The function returns an array \"y\" of double precision values representing the approximate solution at each time point."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  \n  integer :: n\n  double precision, allocatable :: t(:), y(:)\n  \n  !case1\n  n = 5\n  allocate(t(n), y(n))\n  t = [0.0, 0.2, 0.4, 0.6, 0.8]\n  y(1) = 1.0\n  print *, euler(my_function, y(1), t, n)\n  deallocate(t, y)\n\n  !case2\n  n = 6\n  allocate(t(n), y(n))\n  t = [0.0, 0.1, 0.2, 0.3, 0.4, 0.5]\n  y(1) = 0.0\n  print *, euler(my_function, y(1), t, n)\n  deallocate(t, y)\n\n  !case3\n  n = 3\n  allocate(t(n), y(n))\n  t = [-1.0, 0.0, 1.0]\n  y(1) = 2.0\n  print *, euler(my_function, y(1), t, n)\n  deallocate(t, y)\n\n  !case4\n  n = 4\n  allocate(t(n), y(n))\n  t = [0.0, 1.0, 2.0, 3.0]\n  y(1) = 1.0\n  print *, euler(my_function, y(1), t, n)\n  deallocate(t, y)\n\n  !case5\n  n = 7\n  allocate(t(n), y(n))\n  t = [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6]\n  y(1) = 1.0\n  print *, euler(my_function, y(1), t, n)\n  deallocate(t, y)\n  \ncontains\n  function my_function(t, y) result(u)\n    implicit none\n    double precision :: t, y, u\n    u = -y\n  end function my_function\nend program main",
            "result": [
                "1.0000000000000000       0.79999999701976776       0.63999999523162843       0.51199998474121100       0.40959999389648427",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000",
                "2.0000000000000000        0.0000000000000000        0.0000000000000000",
                "1.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000",
                "1.0000000000000000       0.89999999850988388       0.80999999731779093       0.72899999034404750       0.65609999565482124       0.59048999999999985       0.53144098592162115"
            ]
        },
        "code": "    function euler(df, y0, t, n) result (y)\r\n        implicit none\r\n        integer :: k, n\r\n        double precision, intent(in) :: y0\r\n        double precision :: dt\r\n        double precision, dimension(n), intent(in) :: t\r\n        double precision, dimension(n) :: y\r\n        interface\r\n            function df(t, y) result (u)\r\n                implicit none\r\n                double precision :: t, y, u\r\n            end function\r\n        end interface\r\n\r\n        y(1) = y0\r\n        do k=2, n\r\n            dt = t(k) - t(k - 1)\r\n            y(k) = y(k - 1) + df(t(k - 1), y(k - 1)) * dt\r\n        end do\r\n        return\r\n    end function \r\n"
    },
    {
        "instruction": [
            "Provide a Fortran function named std that calculates the standard deviation of a matrix of floating-point numbers. The function expects two input parameters: a 2D matrix 'x' of real numbers and an integer 'n' representing the number of rows in the matrix. The function returns an array 'std' of real numbers with dimension 'n', containing the standard deviation of each row of the matrix. The function also creates an array 'mean' of real numbers with dimension 'n', storing the mean value of each row. The function uses the 'intent' keyword to specify that the 'x' parameter is an input, and the 'n', 'std', and 'mean' parameters are output. The function calculates the standard deviation by iterating over each row of the matrix, computing the mean and then the standard deviation using the formula sqrt(sum((x(i,:) - mean(i))**2)) / s.",
            "Provide a Fortran function named \"std\" that calculates the standard deviation of a given matrix of floating-point numbers. The function takes two input parameters: \"x\", a 2D array of real numbers, and \"n\", an integer representing the number of rows in the matrix. The function returns an array of real numbers, \"std\", with size \"n\", containing the standard deviation values for each row of the matrix. Additionally, the function creates an array called \"mean\" with size \"n\" to store the mean values for each row. The function uses the sum and sqrt functions from Fortran to perform the necessary calculations.",
            "Provide a Fortran function code named \"std\" that calculates the standard deviation of a dataset. The function takes two input arguments: a 2D array of real numbers \"x\" with an intent of being read, and an integer \"n\" representing the number of elements in each row of \"x\". The function returns a 1D array of real numbers \"std\" as the standard deviation for each row of \"x\". Additionally, it calculates the mean value for each row of \"x\" and stores it in the 1D array \"mean\". The function utilizes the features of Fortran, such as using the \"intent\" attribute to specify the purpose of the input and output arguments, as well as the \"sum\" and \"sqrt\" functions for summation and square root calculations."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n\n  real(8), allocatable :: x(:,:)\n  \n  !case1\n  n = 3\n  allocate(x(n,5))\n  x = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0], [n, 5])\n  print *, std(x, n)\n  deallocate(x)\n\n  !case2\n  n = 2\n  allocate(x(n,3))\n  x = reshape([0.0, -1.0, 2.0, 3.0, -4.0, 5.0], [n, 3])\n  print *, std(x, n)\n  deallocate(x)\n\n  !case3\n  n = 4\n  allocate(x(n,2))\n  x = reshape([10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0, 80.0], [n, 2])\n  print *, std(x, n)\n  deallocate(x)\n\n  !case4\n  n = 3\n  allocate(x(n,4))\n  x = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0], [n, 4])\n  print *, std(x, n)\n  deallocate(x)\n\n  !case5\n  n = 2\n  allocate(x(n,5))\n  x = reshape([0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0], [n, 5])\n  print *, std(x, n)\n  deallocate(x)\n\nend program main",
            "result": [
                "1.8973665961010275        1.8973665961010275        1.8973665961010275",
                "1.4401645996461914        1.4401645996461914",
                "14.142135623730951        14.142135623730951        14.142135623730951        14.142135623730951",
                "1.6770509831248424        1.6770509831248424        1.6770509831248424",
                "0.21908902300206648       0.21908902300206648"
            ]
        },
        "code": "    function std(x, n)\n        real(8), dimension(:,:), intent(in) :: x\n        integer, intent(in) :: n\n        real(8), dimension(n) :: std\n        real(8), dimension(n) :: mean\n        integer :: s, i\n        s = size(x, 2)\n        do i=1,n\n            mean(i) = sum(x(i,:)) / s\n            std(i) = sqrt(sum((x(i,:) - mean(i))**2)) / s\n        end do\n    end function std\n"
    },
    {
        "instruction": [
            "Write a Fortran function called findface that determines the face of a three-dimensional object based on its coordinates. The function takes in three input arguments of type double precision (x, y, and z) and returns an output argument of type integer (face). There are six possible faces (1-6) in total.\n\nIn the function, check the values of x, y, and z, and assign the corresponding face number to the variable face. If x is equal to 0, set face to 1. If x is equal to 1, set face to 2. If y is equal to 0, set face to 3. If y is equal to 1, set face to 4. If z is equal to 0, set face to 5. If z is equal to 1, set face to 6.\n\nPlease note that the variables face, x, y, and z are declared with the appropriate data types as per the Fortran language requirements.",
            "Please provide a Fortran function named findface that determines the face of a three-dimensional object based on its coordinates. The function takes three input arguments, x, y, and z, of type double precision. It returns an output argument, face, of type integer.\n\nTo determine the face, the function compares the input coordinates with specific values. If x is equal to 0, the face is set to 1. If x is equal to 1, the face is set to 2. If y is equal to 0, the face is set to 3. If y is equal to 1, the face is set to 4. If z is equal to 0, the face is set to 5. If z is equal to 1, the face is set to 6.\n\nPlease implement the findface function according to these requirements.",
            "Give me a Fortran function code named findface to determine the face of a 3D object based on its coordinates. The function takes in three double precision input arguments x, y, z. The number of input arguments is 3 and the data type is double precision. The function returns an integer output argument face, which represents the face of the object. The number of output arguments is 1 and the data type is integer.\nTo generate the face value, the function checks the values of the input arguments x, y, and z. If x is equal to 0.0, the face value is set to 1. If x is equal to 1.0, the face value is set to 2. If y is equal to 0.0, the face value is set to 3. If y is equal to 1.0, the face value is set to 4. If z is equal to 0.0, the face value is set to 5. If z is equal to 1.0, the face value is set to 6."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  double precision :: x, y, z\n  integer :: face\n  \n  !case1\n  x = 0.0d0\n  y = 0.0d0\n  z = 0.0d0\n  face = findface(x, y, z)\n  print *, face\n  \n  !case2\n  x = 0.5d0\n  y = 0.5d0\n  z = 0.5d0\n  face = findface(x, y, z)\n  print *, face\n  \n  !case3\n  x = 1.0d0\n  y = 0.0d0\n  z = 0.5d0\n  face = findface(x, y, z)\n  print *, face\n  \n  !case4\n  x = 0.25d0\n  y = 1.0d0\n  z = 0.75d0\n  face = findface(x, y, z)\n  print *, face\n  \n  !case5\n  x = 0.75d0\n  y = 0.5d0\n  z = 1.0d0\n  face = findface(x, y, z)\n  print *, face\nend program main",
            "result": [
                "1",
                "0",
                "2",
                "4",
                "6"
            ]
        },
        "code": "  function findface(x, y, z) result(face)\r\n  implicit none\r\n  doubleprecision,intent(in) :: x, y, z\r\n  integer :: face\r\n  \r\n  face = 0\r\n  if(x .eq. 0.0d0) then\r\n      face = 1\r\n  else if(x .eq. 1.0d0) then\r\n      face = 2\r\n  else if(y .eq. 0.0d0) then\r\n      face = 3\r\n  else if(y .eq. 1.0d0) then\r\n      face =4\r\n  else if(z .eq. 0.0d0) then\r\n      face = 5\r\n  else if(z .eq. 1.0d0) then\r\n      face = 6\r\n  end if\r\n  \r\n  end function findface\r\n"
    },
    {
        "instruction": [
            "Create a Fortran function called removespaces that removes multiple spaces from a given string input. The function takes one input argument of type character and returns one output argument of type character. The input argument is named \"string\" and the output argument is named \"stringout\". The function removes any consecutive spaces in the input string and replaces them with a single space.",
            "Write a Fortran function named removespaces that takes a string as input and removes multiple spaces within the string. The function has one input parameter of type character and one output parameter of the same type. The name of the function is removespaces.",
            "Provide a Fortran function named removespaces that takes a string as input and removes any multiple spaces in the string, replacing them with a single space. The number of input arguments is 1 and the data type is character. The number of output arguments is 1 and the data type is character."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=100) :: string\n  \n  !case1\n  string = \"Hello   World\"\n  print *, removespaces(string)\n\n  !case2\n  string = \"   This is   a   test\"\n  print *, removespaces(string)\n\n  !case3\n  string = \"NoSpacesHere\"\n  print *, removespaces(string)\n\n  !case4\n  string = \" SingleSpace \"\n  print *, removespaces(string)\n\n  !case5\n  string = \"Multiple   Spaces   In   Between\"\n  print *, removespaces(string)\n\nend program main",
            "result": [
                "Hello World",
                "This is a test",
                "NoSpacesHere",
                "SingleSpace",
                "Multiple Spaces In Between"
            ]
        },
        "code": "  function removespaces(string) result(stringout)\n    ! replaces multiple spaces in string by one space\n    character(*), intent(in) :: string\n    character(len(string))   :: stringout\n\n    integer :: i\n\n    stringout = trim(string)\n\n    do\n      i = index(trim(stringout),'  ')\n      if ( i == 0 ) exit\n      stringout = trim(adjustl(stringout(:i-1))) &\n      &           //' '//                        &\n      &           trim(adjustl(stringout(i+1:)))\n    end do\n\n  end function removespaces\n"
    },
    {
        "instruction": [
            "Write a Fortran function named \"area\" that calculates the area of a triangle given the lengths of its three sides. The function takes three real numbers as input parameters, representing the lengths of the sides, and returns a real number as the result. The input parameters should be passed with the \"intent(in)\" attribute. The output parameter should be declared as \"real\" and named \"res\". The function uses the formula for the area of a triangle: 0.5 * side1 * height, where the height is calculated using the Law of Cosines.",
            "Create a Fortran function named \"area\" that calculates the area of a triangle given the lengths of its three sides. The function takes in three input arguments of type \"real\" named x, y, and z, and returns a single output argument of type \"real\" named res. The function uses the input arguments to compute the angle between sides x and y, and then calculates the height of the triangle. Finally, it computes and returns the area of the triangle using the formula: 0.5 * y * height.",
            "Create a Fortran function named \"area\" that calculates the area of a triangle given its side lengths. The function takes three input arguments of type real: x, y, and z, representing the lengths of the sides of the triangle. The function returns a single output argument of type real, res, which represents the calculated area of the triangle. To compute the area, the function first calculates the angle theta using the law of cosines, and then computes the height of the triangle using trigonometry. Finally, the function multiplies half of the base length y by the height to obtain the area."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real :: x, y, z\n  \n  !case1\n  x = 3.0\n  y = 4.0\n  z = 5.0\n  print *, area(x, y, z)\n  \n  !case2\n  x = 5.0\n  y = 7.0\n  z = 8.0\n  print *, area(x, y, z)\n  \n  !case3\n  x = 2.0\n  y = 2.0\n  z = 2.0\n  print *, area(x, y, z)\n  \n  !case4\n  x = 10.0\n  y = 6.0\n  z = 8.0\n  print *, area(x, y, z)\n  \n  !case5\n  x = 6.0\n  y = 5.0\n  z = 3.0\n  print *, area(x, y, z)\nend program main",
            "result": [
                "6.00000000",
                "17.3205090",
                "1.73205090",
                "24.0000000",
                "7.48331451"
            ]
        },
        "code": "function area(x, y, z) result(res)\n    implicit none\n    real :: res\n    real, intent(in) :: x, y, z\n    real :: theta, height\n    theta = acos((x**2 + y**2 - z**2)/(2.0*x*y))\n    height = x*sin(theta)\n    res = 0.5*y*height\nend function area\n"
    },
    {
        "instruction": [
            "Create a Fortran function named \"tolower\" that converts all uppercase characters in a given string to lowercase. The function has one input argument of type character and one output argument of the same type. The input argument is passed by value, and the output argument is returned by value. Use the imperative tone to implement the following steps in the function:\n1. Initialize the output string with the same value as the input string.\n2. Iterate over each character in the input string.\n3. Find the corresponding lowercase character index for the current uppercase character.\n4. If a lowercase character index is found, replace the character in the output string with the lowercase character at the same index.\n5. Return the resulting output string.",
            "Give me a Fortran function code named tolower that converts uppercase characters in a given string to lowercase. The function takes one input argument of type character array and returns a character array.",
            "Provide a Fortran function named \"tolower\" that converts all uppercase characters in a given string to lowercase. The function takes a single input argument of type \"character\" that represents the string to be converted. The function returns a string of the same length as the input string, with all uppercase characters converted to lowercase. The function does not support non-ASCII characters, and it is not an elemental function according to strict Fortran 2018 compliance."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=100) :: str\n\n  !case1\n  str = \"Hello, World!\"\n  print *, tolower(str)\n\n  !case2\n  str = \"FoRtRaN\"\n  print *, tolower(str)\n\n  !case3\n  str = \"12345\"\n  print *, tolower(str)\n\n  !case4\n  str = \"UPPERCASE\"\n  print *, tolower(str)\n\n  !case5\n  str = \"!@#$%^&*()_+\"\n  print *, tolower(str)\n\nend program main",
            "result": [
                "Hello, World!",
                "FoRtRaN",
                "12345",
                "UPPERCASE",
                "!@#$%^&*()_+"
            ]
        },
        "code": "pure function tolower(str)\ncharacter(*), intent(in) :: str\ncharacter(len(str)) :: tolower\n!! convert uppercase characters to lowercase\n!!\n!! can be trivially extended to non-ascii\n!! not elemental to support strict fortran 2018 compliance\n\ncharacter(*), parameter :: lower=\"abcdefghijklmnopqrstuvwxyz\", &\n                           upper=\"abcdefghijklmnopqrstuvwxyz\"\ninteger :: i,j\n\ntolower = str\n\ndo i = 1,len(str)\n  j = index(upper,str(i:i))\n  if (j > 0) tolower(i:i) = lower(j:j)\nend do\n\nend function tolower\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named fypp2 that computes the sum of the elements in an input array of integers. The function takes in an array of integers with a size of 2 as an input parameter. The output of the function is an integer. Make sure to include the \"intent(in)\" keyword to specify that the input parameter is read-only. The function calculates the sum of the elements in the array and assigns it to the variable fypp2.",
            "Provide a Fortran function code named fypp2 that calculates the sum of the elements in an input array. The input argument is an integer array of size 2, specified with the \"intent(in)\" attribute. The output is an integer result.",
            "Create a Fortran function named \"fypp2\" that takes in an array of two integers as input. The function calculates the sum of the elements in the input array and returns the result as an integer. Use the \"intent(in)\" keyword to specify that the input array is read-only."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer, dimension(2) :: data\n\n  !case1\n  data = [1, 2]\n  print *, fypp2(data)\n\n  !case2\n  data = [0, -1]\n  print *, fypp2(data)\n\n  !case3\n  data = [-10, 10]\n  print *, fypp2(data)\n\n  !case4\n  data = [100, 200]\n  print *, fypp2(data)\n\n  !case5\n  data = [-5, -5]\n  print *, fypp2(data)\n\nend program main",
            "result": [
                "3",
                "-1",
                "0",
                "300",
                "-10"
            ]
        },
        "code": "function fypp2(data)\n# 111 \"fypp-dilocation.f\"\n  implicit none\n# 111 \"fypp-dilocation.f\"\n  integer :: fypp2\n# 111 \"fypp-dilocation.f\"\n  integer, dimension(2), intent(in) :: data\n! check: br {{.*}}, !llvm.loop ![[loop:[0-9]+]]\n# 111 \"fypp-dilocation.f\"\n  fypp2 = sum(data)\n# 111 \"fypp-dilocation.f\"\nend function fypp2\n"
    },
    {
        "instruction": [
            "Provide a Fortran function named frind that calculates a specific index value based on three input integers. The number of input arguments is 3 and their data type is integer. The number of output arguments is 1 and its data type is integer. The function calculates the result by performing a mathematical operation involving the input arguments.",
            "Provide a Fortran function named frind that calculates the result based on the given inputs. The function takes three integer input values, namely i, j, and n. It returns an integer value as the result. The purpose of this function is to compute a value using the formula i + (j-1)*(2*n - j)/2.",
            "Create a Fortran function named \"frind\" that takes three integer input parameters: \"i\", \"j\", and \"n\". The function calculates a result based on these inputs and returns an integer value.\n\nTo understand the function's purpose, the code appears to be implementing a formula to compute the index of an element in a lower triangular matrix, given its row (\"i\"), column (\"j\"), and size (\"n\").\n\nWrite the instructions to properly define the function, specifying the number and type of input and output parameters."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: i,j,n,res\n\n  !case1\n  i = 1\n  j = 1\n  n = 1\n  res = frind(j, i, n)\n  print *, res\n\n  !case2\n  i = 3\n  j = 2\n  n = 5\n  res = frind(j, i, n)\n  print *, res\n\n  !case3\n  i = 10\n  j = 4\n  n = 8\n  res = frind(j, i, n)\n  print *, res\n\n  !case4\n  i = 5\n  j = 3\n  n = 7\n  res = frind(j, i, n)\n  print *, res\n\n  !case5\n  i = 8\n  j = 5\n  n = 12\n  res = frind(j, i, n)\n  print *, res\n\nend program main",
            "result": [
                "1",
                "7",
                "28",
                "16",
                "46"
            ]
        },
        "code": "function frind(j,i,n) result(res)\n  implicit none\n\n  integer, intent(in) :: i,j,n\n  integer :: res\n\n  res = i + (j-1)*(2*n - j)/2\n\nend function frind\n"
    },
    {
        "instruction": [
            "Please provide me with a Fortran function code named \"tsum\" which computes the sum of a series of numbers based on the given input arrays. The function takes two input arrays, \"x\" and \"y\", which are of type real and have a dimension specified by the \":\". The function also has one output array, \"tsum\", which is of type real and has the same size as \"x\". The function calculates the difference between consecutive elements in \"x\" and stores it in the array \"xdif\". It also calculates the average of corresponding elements in \"y\" and stores it in the array \"yavg\". The function then performs element-wise multiplication between \"xdif\" and \"yavg\", storing the result in the array \"tsumint\". Finally, the function sums all the elements in \"tsumint\" and returns the result.",
            "Write a Fortran function named tsum that calculates the weighted sum of two arrays. The function takes two input arrays, x and y, of real numbers as arguments. The arrays x and y are of the same size. The function calculates the differences between consecutive elements of array x and averages the corresponding elements of array y. The product of each difference and average is stored in a temporary array, tsumint. The function then calculates the sum of all elements in tsumint and returns the result. The function has one output parameter, tsum, which is a real number.",
            "Write a Fortran function named `tsum` that calculates the weighted sum of two arrays. The function takes two input arrays `x` and `y`, both of type real and of any size. The function returns a single output value of type real. The function performs the following steps:\n1. Calculates the size of the input arrays.\n2. Computes the differences between consecutive elements of array `x` and stores them in array `xdif`.\n3. Calculates the average values between consecutive elements of array `y` and stores them in array `yavg`.\n4. Calculates the element-wise product of arrays `xdif` and `yavg` and stores the result in array `tsumint`.\n5. Computes the sum of all elements in array `tsumint` and returns the result as the output value.\nPlease note that some lines of code are commented out with exclamation marks and are not executed."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n\n  real(kind=8), allocatable :: x(:), y(:)\n  \n  !case1\n  n=5\n  allocate(x(n))\n  allocate(y(n))\n  x = [1.0, 2.0, 3.0, 4.0, 5.0]\n  y = [2.0, 4.0, 6.0, 8.0, 10.0]\n  print *, tsum(x, y)\n  deallocate(x)\n  deallocate(y)\n\n  !case2\n  n=3\n  allocate(x(n))\n  allocate(y(n))\n  x = [1.0, 3.0, 5.0]\n  y = [2.0, 6.0, 10.0]\n  print *, tsum(x, y)\n  deallocate(x)\n  deallocate(y)\n\n  !case3\n  n=4\n  allocate(x(n))\n  allocate(y(n))\n  x = [0.0, 0.5, 1.0, 1.5]\n  y = [2.0, 4.0, 6.0, 8.0]\n  print *, tsum(x, y)\n  deallocate(x)\n  deallocate(y)\n\n  !case4\n  n=2\n  allocate(x(n))\n  allocate(y(n))\n  x = [1.0, 2.0]\n  y = [-1.0, 1.0]\n  print *, tsum(x, y)\n  deallocate(x)\n  deallocate(y)\n\n  !case5\n  n=6\n  allocate(x(n))\n  allocate(y(n))\n  x = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]\n  y = [0.0, 1.0, 0.0, 1.0, 0.0, 1.0]\n  print *, tsum(x, y)\n  deallocate(x)\n  deallocate(y)\nend program main",
            "result": [
                "24.000000000000000        24.000000000000000        24.000000000000000        24.000000000000000        24.000000000000000",
                "24.000000000000000        24.000000000000000        24.000000000000000",
                "7.5000000000000000        7.5000000000000000        7.5000000000000000        7.5000000000000000",
                "0.0000000000000000        0.0000000000000000",
                "2.5000000000000000        2.5000000000000000        2.5000000000000000        2.5000000000000000        2.5000000000000000        2.5000000000000000"
            ]
        },
        "code": "       function tsum(x,y)\n       real(kind=8), intent(in), dimension(:) :: x\n       real(kind=8), intent(in), dimension(:) :: y\n       integer :: n\n       real(kind=8), dimension(size(x)) :: tsum,tsumint\n       real(kind=8), dimension(size(x)-1) :: xdif, yavg\n       n=size(x)\n       xdif=x(2:n)-x(1:n-1)\n       yavg=(y(1:n-1)+y(2:n))/2d0\n       tsumint(1)=0d0\n       tsumint(2:n)=xdif*yavg\n!       write(6,*) 'y: ',y\n!       write(6,*) 'xdif yavg: ',xdif(size(x)-1), yavg(size(x)-1)\n       tsum=sum(tsumint,1)\n       end function tsum\n"
    },
    {
        "instruction": [
            "Write a Fortran function code named cum_sum that computes the cumulative sum of an input array of real numbers. The function takes two input arguments: an array of real numbers, x, and an integer, cumu. The function returns an array of real numbers, cum_sum, with the same size as x.",
            "Write a Fortran function code called cum_sum that calculates the cumulative sum of an input array. The function takes two input parameters: a 1D real array named x and an integer named cumu. The function returns a 1D real array named cum_sum, which will have the same size as the input array x.\n\nTo calculate the cumulative sum, the function iterates over each element of the input array x and computes the sum of all elements from the beginning up to that point. The resulting cumulative sum is stored in the corresponding position of the output array cum_sum.\n\nMake sure to provide the input array x and specify the size of the input and output arrays in the function declaration.",
            "Create a Fortran function named cum_sum that calculates the cumulative sum of an input array and returns the result as an array of the same size. The function takes two input arguments: a real array named \"x\" and an integer named \"cumu\". The size of the array \"x\" can vary. The function also has one output argument, which is a real array named \"cum_sum\" with the same size as \"x\". The function calculates the cumulative sum by iterating over each element of the input array and summing up all the elements from the beginning. The resulting cumulative sums are then stored in the output array \"cum_sum\"."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n\n  real(kind=8), allocatable :: x(:)\n\n  !case1\n  n = 5\n  allocate(x(n))\n  x = [1.0, 2.0, 3.0, 4.0, 5.0]\n  print *, cum_sum(x, n)\n  deallocate(x)\n\n  !case2\n  n = 6\n  allocate(x(n))\n  x = [0.5, -1.0, 1.5, -2.0, 2.5, -3.0]\n  print *, cum_sum(x, n)\n  deallocate(x)\n\n  !case3\n  n = 3\n  allocate(x(n))\n  x = [-1.0, -2.0, -3.0]\n  print *, cum_sum(x, n)\n  deallocate(x)\n\n  !case4\n  n = 4\n  allocate(x(n))\n  x = [100.0, 200.0, 300.0, 400.0]\n  print *, cum_sum(x, n)\n  deallocate(x)\n\n  !case5\n  n = 2\n  allocate(x(n))\n  x = [0.1234, -0.5678]\n  print *, cum_sum(x, n)\n  deallocate(x)\nend program main",
            "result": [
                "1.0000000000000000        3.0000000000000000        6.0000000000000000        10.000000000000000        15.000000000000000",
                "0.50000000000000000      -0.50000000000000000        1.0000000000000000       -1.0000000000000000        1.5000000000000000       -1.5000000000000000",
                "-1.0000000000000000       -3.0000000000000000       -6.0000000000000000",
                "100.00000000000000        300.00000000000000        600.00000000000000        1000.0000000000000",
                "0.12340000271797180      -0.44439998269081116"
            ]
        },
        "code": "       function cum_sum(x,cumu)\n       real(kind=8), intent(in), dimension(:) :: x\n       real(kind=8), dimension(size(x)) :: cum_sum\n       integer :: i\n       integer, intent(in) :: cumu\n       do i=1,size(x)\n         cum_sum(i)=sum(x(1:i))\n       enddo\n       end function cum_sum\n"
    },
    {
        "instruction": [
            "Write a Fortran function named \"std\" that calculates the standard deviation of a given list of real numbers. The function takes two parameters: an integer \"n\" representing the number of elements in the list and a one-dimensional real array \"list\" containing the actual values. The function returns a single real value representing the standard deviation. \n\nTo compute the standard deviation, the function first calculates the mean of the input list using the \"sum\" function. Then, it iterates over each element in the list, subtracts the mean from it, squares the result, and accumulates the squared differences in the \"var\" variable. Finally, the function takes the square root of the variance divided by \"n\" (plus a small value to avoid division by zero) and assigns it to the \"std\" variable, which is then returned as the result.",
            "Give me a Fortran function code named std to calculate the standard deviation of a list of floating-point numbers. The function takes two parameters as input: an integer value indicating the number of elements in the list (n), and an array of real numbers (list). The function returns a single real value representing the standard deviation.",
            "Create a Fortran function named std that calculates the standard deviation of a given list of real numbers. The function takes two parameters: an integer n representing the number of elements in the list, and a real array named list containing the numbers. The function returns a real value representing the standard deviation. \n\nTo compute the standard deviation, the function first calculates the mean of the list by taking the sum of all the elements and dividing it by n. Then, it iterates over each element of the list and calculates the variance by subtracting the mean from each element and squaring the result. Finally, the variance is divided by n and the square root of the result is calculated to obtain the standard deviation. \n\nEnsure that the division by n in the variance calculation is safeguarded by adding a small value (1.0e-20) to the denominator to avoid division by zero errors. \n\nThe function must be defined using the \"function\" keyword and the result is of type real."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n\n  real, allocatable :: list(:)\n  \n  !case1\n  n=5\n  allocate(list(n))\n  list = [1.0, 2.0, 3.0, 4.0, 5.0]\n  print *, std(list, n)\n  deallocate(list)\n\n  !case2\n  n=4\n  allocate(list(n))\n  list = [-1.0, 2.0, -3.0, 4.0]\n  print *, std(list, n)\n  deallocate(list)\n\n  !case3\n  n=6\n  allocate(list(n))\n  list = [10.0, 20.0, 30.0, 40.0, 50.0, 60.0]\n  print *, std(list, n)\n  deallocate(list)\n\n  !case4\n  n=3\n  allocate(list(n))\n  list = [0.0, 0.0, 0.0]\n  print *, std(list, n)\n  deallocate(list)\n\n  !case5\n  n=7\n  allocate(list(n))\n  list = [2.0, -1.0, 2.5, 0.3, -1.2, 4.6, -3.8]\n  print *, std(list, n)\n  deallocate(list)\nend program main",
            "result": [
                "1.41421354",
                "2.69258237",
                "17.0782509",
                "0.00000000",
                "2.58370090"
            ]
        },
        "code": "function std(list,n)\nimplicit none\n!--\ninteger               :: n\nreal,dimension(n)     :: list\n!--\ninteger               :: i\nreal                  :: var,std,mean\n!--\nvar=0.0d0\nmean=sum(list)/(real(n)+1.0e-20)\n!--\ndo i=1, n\n    var=var+(list(i)-mean)**2\nend do\n!--\nstd=sqrt((var)/(real(n)+1.0e-20))\n!--\nreturn\nend function\n"
    },
    {
        "instruction": [
            "Create a Fortran function named \"cov\" that calculates the covariance between two arrays of real numbers. The function has three parameters: \"x\" and \"y\" are input arrays of real numbers with a dimension of \"n\", and \"n\" is an input integer representing the number of elements in the arrays. The function returns a single real number, \"cov\", which represents the computed covariance. The function first calculates the mean values of the input arrays, then iterates through the arrays to calculate the sum of the products of the differences between each element and its corresponding mean. Finally, it divides this sum by (n-1) to obtain the covariance.",
            "Provide a Fortran function code named \"cov\" that calculates the covariance between two arrays of floating-point numbers. The function takes in three parameters: an integer \"n\" representing the size of the arrays, and two arrays \"x\" and \"y\" of type real and dimension n. The function returns a single real value \"cov\" representing the computed covariance. The code calculates the mean of the arrays \"x\" and \"y\", and then iterates through the arrays to compute the covariance using the formula: cov = \u03a3((x(i) - x_mean) * (y(i) - y_mean)) / (n - 1), with a small value added to the denominator to avoid division by zero.",
            "Create a Fortran function named \"cov\" that calculates the covariance between two arrays of real numbers. The function takes three parameters: two arrays of real numbers, \"x\" and \"y\", with the same length \"n\", and an integer \"n\" representing the number of elements in the arrays. The function returns a single real number, \"cov\", representing the computed covariance. \n\nTo compute the covariance, the function first calculates the means of the input arrays, \"x_mean\" and \"y_mean\". Then, it iterates over the arrays using a \"do\" loop and accumulates the covariance value, \"c\", by multiplying the differences between each element of \"x\" and \"x_mean\" with the differences between the corresponding elements of \"y\" and \"y_mean\". Finally, the function divides \"c\" by \"n-1\" to obtain the covariance. \n\nNote: The addition of a small value (1.0e-20) is done to avoid division by zero in case \"n\" is very small."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n\n  real, allocatable :: x(:), y(:)\n  \n  !case1\n  n = 5\n  allocate(x(n), y(n))\n  x = [1.0, 2.0, 3.0, 4.0, 5.0]\n  y = [1.0, 1.5, 2.0, 2.5, 3.0]\n  print *, cov(x, y, n)\n  deallocate(x, y)\n\n  !case2\n  n = 3\n  allocate(x(n), y(n))\n  x = [0.0, 0.0, 0.0]\n  y = [1.0, 2.0, 3.0]\n  print *, cov(x, y, n)\n  deallocate(x, y)\n\n  !case3\n  n = 4\n  allocate(x(n), y(n))\n  x = [2.0, 4.0, 6.0, 8.0]\n  y = [-1.0, -2.0, -3.0, -4.0]\n  print *, cov(x, y, n)\n  deallocate(x, y)\n\n  !case4\n  n = 5\n  allocate(x(n), y(n))\n  x = [1.0, 3.0, 5.0, 7.0, 9.0]\n  y = [0.0, 2.0, 4.0, 6.0, 8.0]\n  print *, cov(x, y, n)\n  deallocate(x, y)\n\n  !case5\n  n = 6\n  allocate(x(n), y(n))\n  x = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]\n  y = [6.0, 5.0, 4.0, 3.0, 2.0, 1.0]\n  print *, cov(x, y, n)\n  deallocate(x, y)\nend program main",
            "result": [
                "1.25000000",
                "0.00000000",
                "-3.33333325",
                "10.0000000",
                "-3.50000000"
            ]
        },
        "code": "function cov(x,y,n)\nimplicit none\n!--\ninteger                :: n\nreal,dimension(n)      :: x,y\nreal                   :: cov\n!--\nreal                   :: x_mean,y_mean\nreal                   :: c\ninteger                :: i\n!--\nx_mean=sum(x)/(real(n)+1.0e-20)\ny_mean=sum(y)/(real(n)+1.0e-20)\n!--\nc=0.0d0\n!--\ndo i=1,n\n    c=c+(x(i)-x_mean)*(y(i)-y_mean)\nend do\ncov=c/((n-1)+1.0e-20)\n!--\nreturn\n!--\nend function cov\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named element_name to retrieve the name of an element based on its atomic number. The function takes an integer input argument representing the atomic number and returns a character string representing the element name. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [character].",
            "Provide a Fortran function named element_name to retrieve the name of an element based on its atomic number. The function accepts one input parameter, an integer named \"z\", which represents the atomic number of the element. The function returns a two-character string, \"element_name\", which represents the name of the element.",
            "Give me a Fortran function code named element_name that maps an atomic number to the corresponding element name. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [character(2)]."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: z\n\n  !case1\n  z = 1\n  print *, element_name(z)\n\n  !case2\n  z = 14\n  print *, element_name(z)\n\n  !case3\n  z = 33\n  print *, element_name(z)\n\n  !case4\n  z = 53\n  print *, element_name(z)\n\n  !case5\n  z = 84\n  print *, element_name(z)\n\nend program main",
            "result": [
                "h",
                "si",
                "as",
                "i",
                "po"
            ]
        },
        "code": "function element_name( z )\n\n  implicit none\n  integer,intent(in) :: z\n  character(2) :: element_name\n  character(2),save :: name(112)\n!  character(2) :: a\n!  integer :: i\n\n  data name/ \"h\" ,\"he\", &\n             \"li\",\"be\",\"b\" ,\"c\" ,\"n\" ,\"o\" ,\"f\" ,\"ne\", &\n             \"na\",\"mg\",\"al\",\"si\",\"p\" ,\"s\" ,\"cl\",\"ar\", &\n             \"k\" ,\"ca\",\"sc\",\"ti\",\"v\" ,\"cr\",\"mn\",\"fe\",\"co\", &\n             \"ni\",\"cu\",\"zn\",\"ga\",\"ge\",\"as\",\"se\",\"br\",\"kr\", &\n             \"rb\",\"sr\",\"y\" ,\"zr\",\"nb\",\"mo\",\"tc\",\"ru\",\"rh\", &\n             \"pd\",\"ag\",\"cd\",\"in\",\"sn\",\"sb\",\"te\",\"i\" ,\"xe\", &\n             \"cs\",\"ba\",\"la\",\"ce\",\"pr\",\"nd\",\"pm\",\"sm\",\"eu\", &\n             \"gd\",\"tb\",\"dy\",\"ho\",\"er\",\"tm\",\"yb\",\"lu\", &\n             \"hf\",\"ta\",\"w\" ,\"re\",\"os\",\"ir\", &\n             \"pt\",\"au\",\"hg\",\"tl\",\"pb\",\"bi\",\"po\",\"at\",\"rn\", &\n             \"fr\",\"ra\",\"ac\",\"th\",\"pa\",\"u\" ,\"np\",\"pu\",\"am\", &\n             \"cm\",\"bk\",\"cf\",\"es\",\"fm\",\"md\",\"no\",\"lr\",\"rf\", &\n             \"db\",\"sg\",\"bh\",\"hs\",\"mt\",\"ds\",\"rg\",\"cn\" /\n\n  element_name = name(z)\n\n!  z=0\n!  do i=1,size(name)\n!     if ( element_name(1:2) == name(i) ) then\n!        z=i\n!        exit\n!     else\n!        a=name(i)\n!        if ( element_name(1:1) == a(1:len_trim(a)) ) z=i\n!     end if\n!  end do\n\nend function element_name\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named findorder that takes an array of integers and its size as input, and returns an array of integers as output. The number of input arguments is 2 and the type of the input parameters is [integer, integer]. The number of output arguments is 1 and the type of the output parameter is [integer]. \n\nThe function finds the order of the elements in the input array by creating a copy of the input array and replacing the minimum value in each iteration with a value greater than the maximum value in the array. The resulting array contains the indices of the elements in the order they appeared in the original array.",
            "Provide a Fortran function code named findorder that takes an integer array and its size as input. The function will return an integer array with the same size. The purpose of this code is to find the order of the elements in the input array. The number of input arguments is 2 and the data type of the first argument is integer array with size n, and the second argument is an integer specifying the size of the array. The number of output arguments is 1 and the data type is integer array with size n.",
            "Write a Fortran function called findorder that takes an array of integers and its length as input parameters and returns an array of integers as the output. The function's purpose is to find the order of the elements in the input array.\n\nTo accomplish this, the function first creates a copy of the input array. Then, it scans the copy to find the maximum value and adds 1 to it, assigning this new value as a placeholder for the largest element. Next, the function iterates through the copy to find the minimum value and its corresponding index. Once the minimum value is found, it replaces it with the previously determined placeholder for the largest element. This process is repeated until all elements in the copy are sorted, and the indices of the original array elements in their sorted order are recorded in the output array.\n\nThe function has 2 input parameters: 'a', an integer array, and 'n', an integer representing the length of the array. It also has 1 output parameter: 'r', an integer array."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n\n  integer, allocatable :: a(:)\n  \n  !case1\n  n=5\n  allocate(a(n))\n  a = [5, 4, 3, 2, 1]\n  print *, findorder(a, n)\n  deallocate(a)\n\n  !case2\n  n=8\n  allocate(a(n))\n  a = [10, 8, 6, 4, 2, 9, 7, 5]\n  print *, findorder(a, n)\n  deallocate(a)\n\n  !case3\n  n=6\n  allocate(a(n))\n  a = [1, 2, 3, 4, 5, 6]\n  print *, findorder(a, n)\n  deallocate(a)\n\n  !case4\n  n=3\n  allocate(a(n))\n  a = [100, 200, 300]\n  print *, findorder(a, n)\n  deallocate(a)\n\n  !case5\n  n=7\n  allocate(a(n))\n  a = [9, 8, 7, 6, 5, 4, 3]\n  print *, findorder(a, n)\n  deallocate(a)\nend program main",
            "result": [
                "5           4           3           2           1",
                "5           4           8           3           7           2           6           1",
                "1           2           3           4           5           6",
                "1           2           3",
                "7           6           5           4           3           2           1"
            ]
        },
        "code": "function findorder(a, n) result (r)\r\ninteger, dimension(n), intent(in) :: a\r\ninteger, intent(in) :: n\r\ninteger, dimension(n) :: b, r\r\ninteger :: i, j, maxvalue, minvalue\r\n\r\n!- we'll be working with the array a but don't want to change it\r\n!- so lets define that the array b is a but we can change b\r\nb = a\r\nr = a\r\n!- find the largest element of the array, \r\n!- then introduce a new element that is greater than the rest\r\nmaxvalue = b(1)\r\ndo i = 1,n\r\n  \tif (maxvalue .lt. b(i)) maxvalue = b(i)\r\nend do\r\nmaxvalue = maxvalue + 1\r\n!- sort through the array b and find the lowest value, and it's index.\r\n!- once the min is found then replace it with our largest value found above.\r\nminvalue = 1\r\ndo i = 1,n\r\n    do j = 1,n\r\n      \tif (b(minvalue) .gt. b(j)) minvalue = j\r\n\tend do\r\n    b(minvalue) = maxvalue\r\n    r(i) = minvalue \r\nend do\r\n\r\nend function findorder\r\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named nwords to count the number of words in a given string. The function takes in a single input argument of type character and returns an output of type integer.",
            "Write a Fortran function named \"nwords\" to count the number of words in a given string. The function takes one input argument of type \"character(len=*)\" (a string) and returns an output argument of type \"integer\" (the number of words).",
            "Create a Fortran function named \"nwords\" that counts the number of words in a given string. The function takes one input argument of type \"character(len=*)\" named \"string\". It returns one output argument of type \"integer\" named \"nwords\". \n\nTo count the words, the function initializes some variables and checks for the presence of null characters, tab characters, spaces, and commas in the string. If any of these characters are found, the function increments the word count. The function continues this process until it reaches the end of the string. Finally, it returns the total number of words counted.\n\nPlease note that the function assumes that words are separated by either spaces or commas."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=100) :: string\n  \n  !case1\n  string = \"Hello, World! This is a test.\"\n  print *, nwords(string)\n\n  !case2\n  string = \"Fortran is a programming language\"\n  print *, nwords(string)\n\n  !case3\n  string = \"The quick brown fox jumps over the lazy dog.\"\n  print *, nwords(string)\n\n  !case4\n  string = \"12345 67890\"\n  print *, nwords(string)\n\n  !case5\n  string = \"One, Two, Three, Four, Five\"\n  print *, nwords(string)\n  \nend program main",
            "result": [
                "6",
                "5",
                "9",
                "2",
                "5"
            ]
        },
        "code": "  function nwords(string)\n    character(len=*), intent(in)  :: string\n    integer :: pos1, pos2, pe\n    integer :: i1,i2,i3,i4 \n    integer :: nwords\n  ! initialize the null and tab characters.\n    pe = len_trim(string) \n    pos1 = 1\n    nwords = 0\n    if (pe == 0) return\n    do \n      i1=index(string(pos1:pe), \",\")\n      i2=index(string(pos1:pe), \" \")\n      i3=index(string(pos1:pe), achar(0))\n      i4=index(string(pos1:pe), achar(9))\n      if (i1 == 0 ) i1 = pe+1\n      if (i2 == 0 ) i2 = pe+1\n      if (i3 == 0 ) i3 = pe+1\n      if (i4 == 0 ) i4 = pe+1\n      if (min(i1,i2,i3,i4) > pe) then\n         nwords = nwords + 1\n         exit\n      end if\n      pos2=min(i1,i2,i3,i4) \n      if (pos2 > 1 ) then\n        nwords = nwords + 1\n      end if\n      pos1 = pos2+pos1\n    end do \n    return\n  end function nwords\n"
    },
    {
        "instruction": [
            "Create a Fortran function named dot that calculates the dot product of two arrays. The function takes in three parameters: an integer value 'n' and two real arrays 'a' and 'b'. The function returns a real value 'dot', which represents the dot product of the two arrays. Make sure to use the 'intent' keyword to specify that 'n', 'a', and 'b' are input parameters. Inside the function, declare a local integer variable 'i' to use in a loop. Initialize 'dot' to zero and then use a loop to iterate over the arrays and calculate the dot product by multiplying corresponding elements of 'a' and 'b' and accumulating the result in 'dot'. Finally, assign the calculated value of 'dot' to the function name to return the result.",
            "Provide a Fortran function code named dot to calculate the dot product of two arrays. The function takes three input parameters: an integer n and two real arrays a and b of length n. The output is a single real value representing the dot product. To use the function, ensure that the input arrays a and b have the same length.",
            "Please write a Fortran function named \"dot\" to compute the dot product of two arrays of floating-point numbers. The function takes three input parameters: an integer \"n\" representing the size of the arrays, and two arrays \"a\" and \"b\" of type real*8 with dimension n. The function returns a single real*8 value representing the dot product."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n\n  real*8, allocatable :: a(:), b(:)\n  \n  !case1\n  n=3\n  allocate(a(n), b(n))\n  a = [1.0, 2.0, 3.0]\n  b = [4.0, 5.0, 6.0]\n  print *, dot(a, b, n)\n  deallocate(a, b)\n\n  !case2\n  n=4\n  allocate(a(n), b(n))\n  a = [-1.0, 2.0, -3.0, 4.0]\n  b = [5.0, -6.0, 7.0, -8.0]\n  print *, dot(a, b, n)\n  deallocate(a, b)\n\n  !case3\n  n=5\n  allocate(a(n), b(n))\n  a = [1.0, 1.0, 1.0, 1.0, 1.0]\n  b = [2.0, 2.0, 2.0, 2.0, 2.0]\n  print *, dot(a, b, n)\n  deallocate(a, b)\n\n  !case4\n  n=2\n  allocate(a(n), b(n))\n  a = [0.0, 0.0]\n  b = [1.0, 1.0]\n  print *, dot(a, b, n)\n  deallocate(a, b)\n\n  !case5\n  n=5\n  allocate(a(n), b(n))\n  a = [-1.0, 2.0, -3.0, 4.0, -5.0]\n  b = [6.0, -7.0, 8.0, -9.0, 10.0]\n  print *, dot(a, b, n)\n  deallocate(a, b)\nend program main",
            "result": [
                "32.000000000000000",
                "-70.000000000000000",
                "10.000000000000000",
                "0.0000000000000000",
                "-130.00000000000000"
            ]
        },
        "code": "function dot(a,b,n)\n  ! compute the dot product of a and b\n    implicit none\n    real*8 :: dot ! return  value\n  !-----------------------------------------------\n\n    integer*4              , intent(in)    :: n\n    real*8   , dimension(n), intent(in)    :: a,b\n  !-----------------------------------------------\n  ! declare local variables\n    integer*4 :: i\n  !-----------------------------------------------'\n    dot = 0.\n    do i=1,n\n        dot = dot + a(i) * b(i)\n    end do\nend function dot\n"
    },
    {
        "instruction": [
            "Write a Fortran function code named \"suspicious\" that determines if a given combination of \"nedge\" and \"ngp\" values is suspicious. The function takes two integer input parameters: \"nedge\" and \"ngp\". It returns a logical output indicating whether the combination is suspicious or not.\n\nTo determine the suspiciousness, the function checks if \"nedge\" is greater than or equal to certain thresholds based on the value of \"ngp\". If \"ngp\" is greater than 8, the function calculates \"n\" as the difference between 16 and \"ngp\". Otherwise, \"n\" is equal to \"ngp\". The function then returns true if any of the following conditions are met:\n1. \"nedge\" is greater than or equal to 42.\n2. \"nedge\" is greater than or equal to 36 and \"n\" is equal to 5 or 4.\n3. \"nedge\" is greater than or equal to 30 and \"n\" is equal to 3.\n4. \"nedge\" is greater than or equal to 24 and \"n\" is equal to 2.\n\nIn the generated instructions, implement a Fortran function code named \"suspicious\" that takes two integer input parameters: \"nedge\" and \"ngp\". The function returns a logical output indicating whether the combination of \"nedge\" and \"ngp\" is suspicious or not.",
            "Create a Fortran function named `suspicious` that determines whether a given combination of `nedge` (integer) and `ngp` (integer) values is suspicious. The function returns a logical value indicating the suspicion level. The number of input arguments is 2, with `nedge` and `ngp` both being integers. The output is a single logical value.",
            "Write a Fortran function code named \"suspicious\" that determines whether a given condition is suspicious or not. The function takes two input arguments, \"nedge\" of type integer and \"ngp\" of type integer. The function returns a logical value indicating whether the condition is suspicious or not."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: nedge, ngp\n\n  !case1\n  nedge = 50\n  ngp = 10\n  print *, suspicious(nedge, ngp)\n\n  !case2\n  nedge = 40\n  ngp = 5\n  print *, suspicious(nedge, ngp)\n\n  !case3\n  nedge = 35\n  ngp = 4\n  print *, suspicious(nedge, ngp)\n\n  !case4\n  nedge = 30\n  ngp = 3\n  print *, suspicious(nedge, ngp)\n\n  !case5\n  nedge = 20\n  ngp = 2\n  print *, suspicious(nedge, ngp)\n  \nend program main",
            "result": [
                "T",
                "T",
                "F",
                "T",
                "F"
            ]
        },
        "code": "   function suspicious(nedge,ngp)\n\n     implicit none\n     logical :: suspicious\n     integer :: nedge, ngp, n\n\n     if (ngp .gt. 8) then \n        n = 16-ngp\n     else\n        n = ngp\n     end if\n\n     suspicious = ((nedge .ge. 42).or.                                   &\n                   ((nedge .ge. 36).and.((n .eq. 5).or.(n .eq. 4))).or.  &\n                   ((nedge .ge. 30).and.(n .eq. 3)).or.                  &\n                   ((nedge .ge. 24).and.(n .eq. 2)))\n\n   end function suspicious\n"
    },
    {
        "instruction": [
            "Write a Fortran function named \"sameedgedifferentpolygon\" that checks if two polygons have the same edges but are different polygons. The function takes in four input arguments: two integers (j and i) and two arrays of real numbers (edge and edge2). The dimensions of the \"edge\" array are (0:3,3,96) and the dimensions of the \"edge2\" array are the same. The function returns a logical value indicating whether the polygons have the same edges but are different.",
            "Write a Fortran function named sameedgedifferentpolygon that checks if two sets of edges are the same or different for a given pair of polygons. The function takes in four input parameters: j and i of type integer, edge and edge2 of type real array with dimensions (0:3, 3, 96). The function returns a logical value (sedp) indicating whether the edges are the same or different.\n\nTo determine if the edges are the same or different, the function checks if all the values in the first two columns (1 and 2) of edge (for polygon j) are equal to the corresponding values in the first two columns of edge2 (for polygon i). If this condition is true, or if the values in the first column of edge (for polygon j) are equal to the values in the second column of edge2 (for polygon i) and the values in the second column of edge (for polygon j) are equal to the values in the first column of edge2 (for polygon i), then the function returns true (sedp = .true.). Otherwise, it returns false (sedp = .false.).\n\nMake sure to provide the appropriate input data in the test_data section, following the specified types and dimensions for the input parameters.",
            "Create a Fortran function named \"sameedgedifferentpolygon\" to determine if two polygons have the same edges. The function takes in four input parameters: two integers \"j\" and \"i\", and two arrays \"edge\" and \"edge2\" of type real. The dimensions of the \"edge\" and \"edge2\" arrays are (0:3, 3, 96). The function returns a logical value \"sedp\". The function checks if all the elements in the first two columns of the \"edge\" array (at index \"j\") are equal to the corresponding elements in the first two columns of the \"edge2\" array (at index \"i\"). If they are equal, or if the first column of the \"edge\" array (at index \"j\") is equal to the second column of the \"edge2\" array (at index \"i\") and the second column of the \"edge\" array (at index \"j\") is equal to the first column of the \"edge2\" array (at index \"i\"), then the function sets \"sedp\" to true, otherwise false."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: j, i\n  logical :: sedp\n  real(kind(0d0)), dimension(0:3,3,96) :: edge, edge2\n  \n  !case1\n  j = 1\n  i = 1\n  edge(:,1:2,j) = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0], shape(edge(:,1:2,j)))\n  edge2(:,1:2,i) = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0], shape(edge2(:,1:2,i)))\n  print *, sameedgedifferentpolygon(j, i, edge, edge2)\n\n  !case2\n  j = 2\n  i = 3\n  edge(:,1:2,j) = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0], shape(edge(:,1:2,j)))\n  edge2(:,1:2,i) = reshape([5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0], shape(edge2(:,1:2,i)))\n  print *, sameedgedifferentpolygon(j, i, edge, edge2)\n\n  !case3\n  j = 3\n  i = 2\n  edge(:,1:2,j) = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0], shape(edge(:,1:2,j)))\n  edge2(:,1:2,i) = reshape([3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0], shape(edge2(:,1:2,i)))\n  print *, sameedgedifferentpolygon(j, i, edge, edge2)\n\n  !case4\n  j = 4\n  i = 4\n  edge(:,1:2,j) = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0], shape(edge(:,1:2,j)))\n  edge2(:,1:2,i) = reshape([5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0], shape(edge2(:,1:2,i)))\n  print *, sameedgedifferentpolygon(j, i, edge, edge2)\n\n  !case5\n  j = 2\n  i = 1\n  edge(:,1:2,j) = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0], shape(edge(:,1:2,j)))\n  edge2(:,1:2,i) = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0], shape(edge2(:,1:2,i)))\n  print *, sameedgedifferentpolygon(j, i, edge, edge2)\nend program main\n    ",
            "result": [
                "T",
                "F",
                "F",
                "F",
                "T"
            ]
        },
        "code": "   function sameedgedifferentpolygon(j,i,edge,edge2) result (sedp)\n\n     implicit none\n     logical :: sedp\n     integer :: j,i\n     real(kind(0d0)),dimension(0:3,3,96) :: edge, edge2\n\n     sedp = all(edge(:,1:2,j).eq.edge2(:,1:2,i)).or.     &\n            (all(edge(:,1,j).eq.edge2(:,2,i)).and.         &\n             all(edge(:,2,j).eq.edge2(:,1,i)))\n\n   end function sameedgedifferentpolygon\n"
    },
    {
        "instruction": [
            "Create a Fortran function named istep to determine the step function value for a given input argument. The function takes a single 8-byte floating-point number as input and returns a 8-byte floating-point number as output. In the function, if the input argument is less than 0, the output value is set to 1. If the input argument is equal to 0, the output value is set to 0.5. Otherwise, the output value is set to 0.",
            "Write a Fortran function code named istep that computes the value of the step function for a given input. The input argument is a 64-bit floating-point number, and the output is also a 64-bit floating-point number. \n\nTo write the code, define a function named \"istep\" with an input argument \"x\" of type real(8). The output is a real(8) as well, named \"out\". \n\nInside the function, use an if-else-if construct to determine the value of \"out\" based on the value of \"x\". If \"x\" is less than zero, set \"out\" to 1.0. If \"x\" is equal to zero, set \"out\" to 0.5. Otherwise, set \"out\" to 0.0.\n\nRemember to use the \"intent(in)\" keyword to specify that \"x\" is an input argument.\n\n",
            "Write a Fortran function named istep that takes in a single 8-byte floating-point number as input and returns a single 8-byte floating-point number as output. The function determines the output value based on the input value using the following logic:\n- If the input value is less than zero, set the output value to 1.0.\n- If the input value is equal to zero, set the output value to 0.5.\n- If the input value is greater than zero, set the output value to 0.0.\nYou must implement this logic using an if-else statement inside the function."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real(8) :: x\n  \n  !case1\n  x = -2.5d0\n  print *, istep(x)\n  \n  !case2\n  x = 0.0d0\n  print *, istep(x)\n  \n  !case3\n  x = 3.14159d0\n  print *, istep(x)\n  \n  !case4\n  x = -100.0d0\n  print *, istep(x)\n  \n  !case5\n  x = 0.5d0\n  print *, istep(x)\nend program main",
            "result": [
                "1.0000000000000000",
                "0.50000000000000000",
                "0.0000000000000000",
                "1.0000000000000000",
                "0.0000000000000000"
            ]
        },
        "code": "  elemental function istep(x) result(out)\n    real(8),intent(in) :: x\n    real(8)            :: out\n    if(x < 0.d0) then\n       out = 1.0d0\n    elseif(x==0.d0)then\n       out = 0.50d0\n    else\n       out = 0.0d0\n    endif\n  end function istep\n"
    },
    {
        "instruction": [
            "Write a Fortran function named \"random_normal\" to generate a random number from a normal distribution. The function takes two input parameters, \"mean\" and \"stdev\", both of which are 8-byte real numbers. The function returns a single output parameter, \"c\", also a 8-byte real number. The function computes the random number using the Box-Muller method.",
            "Provide a Fortran function code named random_normal that generates a random number from a normal distribution with a specified mean and standard deviation. The function takes two input parameters of type real(8) - mean and stdev, and returns a single output parameter of type real(8) - c. The generated instruction should be imperative.\n\nTo calculate the random number, the function first generates two random numbers between 0 and 1 using the random_number subroutine. It then applies the Box-Muller transform to obtain two independent random numbers with a standard normal distribution. The generated random number is calculated as the product of the standard deviation, the square root of the negative logarithm of the first random number, the sine of 2\u03c0 times the second random number, and the mean. The resulting random number is assigned to the output parameter c.",
            "Provide a Fortran function code named random_normal that generates a random number from a normal distribution with given mean and standard deviation. The function takes two input parameters, mean and stdev, both of type real(8). The function returns a single output parameter, c, which is also of type real(8)."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real(8) :: mean, stdev, result\n  \n  !case1\n  mean = 0.0\n  stdev = 1.0\n  result = random_normal(mean, stdev)\n  print *, result\n  \n  !case2\n  mean = 10.0\n  stdev = 2.5\n  result = random_normal(mean, stdev)\n  print *, result\n  \n  !case3\n  mean = -5.0\n  stdev = 0.5\n  result = random_normal(mean, stdev)\n  print *, result\n  \n  !case4\n  mean = 100.0\n  stdev = 10.0\n  result = random_normal(mean, stdev)\n  print *, result\n  \n  !case5\n  mean = -50.0\n  stdev = 20.0\n  result = random_normal(mean, stdev)\n  print *, result\n  \nend program main",
            "result": [
                "-2.8496547281909992E-002",
                "9.3416576453528268",
                "-4.9141270759023259",
                "100.76817977767716",
                "-25.655957860280040"
            ]
        },
        "code": "  function random_normal(mean,stdev) result(c)\n\n    real(8), intent(in) :: mean,stdev\n    real(8)             :: c, r, theta\n    real(8)             :: temp(2)\n    real(8), parameter  :: pi = 4.d0*datan(1.d0)\n\n    call random_number(temp)\n\n    r = (-2.0d0*log(temp(1)))**0.5    \n    theta = 2.0d0*pi*temp(2)\n\n    c = mean+stdev*r*sin(theta)\n\n  end function random_normal\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named minmod to calculate the minimum of three input floating-point numbers. The function takes three input arguments of type real and returns a single output value of type real. \n\nIn the function, if all three input numbers are greater than or equal to zero, the minimum of the three numbers is calculated using the min function and stored in the variable minmod. If all three numbers are less than or equal to zero, the negative of the minimum absolute value of the three numbers is calculated using the min and abs functions and stored in minmod. If none of the conditions are met, the function returns 0.0.",
            "Write a Fortran function called minmod that calculates the minimum of three input floating-point numbers. The function takes three input arguments of type real(kind=8). The function returns the minimum value as a result of type real(kind=8). If all three input numbers are positive, the function returns the minimum of the three numbers. If all three input numbers are negative, the function returns the negative of the minimum absolute value. Otherwise, if the input numbers have mixed signs, the function returns 0.",
            "Provide a Fortran function code named minmod that computes the minimum moduli of three input floating numbers. The function takes three real numbers as input arguments and returns a single real number as the output. The input arguments are passed with the \"intent(in)\" keyword to indicate that they are read-only. The function uses the \"min\" and \"abs\" functions to calculate the minimum moduli. If all three input numbers are positive, the function returns the minimum of the three numbers. If all three numbers are negative, the function returns the negative of the minimum absolute value of the three numbers. Otherwise, if the input numbers have a combination of positive and negative values, the function returns 0.0."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real(kind=8) :: a, b, c, result\n\n  !case1\n  a = 1.0\n  b = 2.0\n  c = 3.0\n  result = minmod(a, b, c)\n  print *, result\n\n  !case2\n  a = -1.0\n  b = -2.0\n  c = -3.0\n  result = minmod(a, b, c)\n  print *, result\n\n  !case3\n  a = 0.0\n  b = 0.0\n  c = 0.0\n  result = minmod(a, b, c)\n  print *, result\n\n  !case4\n  a = 2.5\n  b = -1.5\n  c = 0.0\n  result = minmod(a, b, c)\n  print *, result\n\n  !case5\n  a = -5.0\n  b = 10.0\n  c = -2.0\n  result = minmod(a, b, c)\n  print *, result\nend program main",
            "result": [
                "1.0000000000000000",
                "-1.0000000000000000",
                "0.0000000000000000",
                "0.0000000000000000",
                "0.0000000000000000"
            ]
        },
        "code": "  function minmod(a,b,c)\n\n    implicit none\n\n    real(kind=8), intent(in) :: a, b, c \n \n    real(kind=8) :: minmod\n\n    if ( (a .ge. 0.0) .and. (b .ge. 0.0) .and. (c .ge. 0.0) ) then\n      minmod = min(a,b,c)\n    else if ( (a .le. 0.0) .and. (b .le. 0.0) .and. (c .le. 0.0) ) then\n      minmod = -min(abs(a), abs(b), abs(c))\n    else\n      minmod = 0.0\n    end if\n\n  end function\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named generate_rand_int to generate a random integer between 1 and a given upper limit. The number of input arguments is 1 and the data type is [integer]. The number of output arguments is 1 and the data type is [integer].",
            "Provide a Fortran function code named generate_rand_int that generates a random integer number within a specified range. The function takes one input argument of type integer, indicating the upper bound of the range. The function returns a random integer number within the specified range.",
            "Provide a Fortran function code named generate_rand_int to generate a random integer within a specified range. The function takes in one input argument of type integer, which specifies the upper limit of the range. The function returns an integer as the generated random number."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: out_of\n  \n  !case1\n  out_of = 10\n  print *, generate_rand_int(out_of)\n  \n  !case2\n  out_of = 100\n  print *, generate_rand_int(out_of)\n  \n  !case3\n  out_of = 1000\n  print *, generate_rand_int(out_of)\n  \n  !case4\n  out_of = 50\n  print *, generate_rand_int(out_of)\n  \n  !case5\n  out_of = 10000\n  print *, generate_rand_int(out_of)\n  \nend program main",
            "result": [
                "10",
                "57",
                "966",
                "38",
                "3674"
            ]
        },
        "code": "  function generate_rand_int(out_of)\n\n    implicit none\n    integer, parameter :: dp=selected_real_kind(15,300)\n    real(kind=dp) :: rand\n    integer :: generate_rand_int\n    integer :: out_of\n\n    call random_number(rand)\n    generate_rand_int=ceiling(real(out_of,dp)*rand)\n\n  end function generate_rand_int\n"
    },
    {
        "instruction": [
            "Write a Fortran function named \"map2t\" that takes two input arguments: a real(8) array \"a\" and an integer \"ntens\". The function calculates a 3x3 matrix \"map2t\" based on the values of \"a\" and \"ntens\". The function returns the calculated matrix as the output.",
            "Please create a Fortran function named \"map2t\" that takes in an array \"a\" of real numbers and an integer \"ntens\" as input. The function computes a 3x3 matrix \"map2t\" based on the values in \"a\" and the size of \"ntens\". The number of input arguments is 2, with types [real(8), integer]. The number of output arguments is 1, with type [real(8), dimension(1:3,1:3)].",
            "Please provide a Fortran function code named map2t that transforms a 1D array of real numbers into a 3x3 array. The function takes two input parameters: an integer ntens and a 1D real array a. The function output is a 2D real array map2t. The function initializes a 1D real array b of size 6 with zeros. It then assigns the first ntens elements from array a to the first ntens elements of array b. Finally, the function reshapes the first three elements of array b to form the first row of map2t, the next three elements to form the second row, and the last three elements to form the third row."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: ntens\n  real(8), allocatable :: a(:)\n  \n  !case1\n  ntens = 3\n  allocate(a(ntens))\n  a = [1.0, 2.0, 3.0]\n  print *, map2t(a, ntens)\n  deallocate(a)\n\n  !case2\n  ntens = 2\n  allocate(a(ntens))\n  a = [0.5, -1.5]\n  print *, map2t(a, ntens)\n  deallocate(a)\n\n  !case3\n  ntens = 4\n  allocate(a(ntens))\n  a = [2.0, 4.0, -1.0, 0.0]\n  print *, map2t(a, ntens)\n  deallocate(a)\n\n  !case4\n  ntens = 1\n  allocate(a(ntens))\n  a = [10.5]\n  print *, map2t(a, ntens)\n  deallocate(a)\n\n  !case5\n  ntens = 6\n  allocate(a(ntens))\n  a = [1.2, -0.5, 0.7, 2.3, -1.8, 0.9]\n  print *, map2t(a, ntens)\n  deallocate(a)\nend program main",
            "result": [
                "1.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        2.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        3.0000000000000000",
                "0.50000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000       -1.5000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        3.0000000000000000",
                "2.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        4.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000       -1.0000000000000000",
                "10.500000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        4.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000       -1.0000000000000000",
                "1.2000000476837158        2.2999999523162842       -1.7999999523162842        2.2999999523162842      -0.50000000000000000       0.89999997615814209       -1.7999999523162842       0.89999997615814209       0.69999998807907104"
            ]
        },
        "code": "      function map2t(a,ntens)\n        implicit none\n        real(8),  dimension(1:3,1:3) :: map2t\n        integer, intent(in) :: ntens\n        real(8), intent(in), dimension(:) :: a\n        real(8), dimension(1:6) :: b= 0\n        b(1:ntens) = a(1:ntens)\n        map2t = reshape( [b(1),b(4),b(5), &\n            b(4),b(2),b(6),  b(5),b(6),b(3) ],[3,3] )\n      end function map2t\n"
    },
    {
        "instruction": [
            "Write a Fortran function code named inv33 that calculates the inverse of a 3x3 matrix. The function takes a single input argument of type real(8), dimension(3,3) and returns the inverse matrix of the same type and dimensions. \n\nTo use this function, provide the matrix as the input argument. The function will calculate the determinant of the matrix and store it in the variable 'det'. Then, it will compute the inverse matrix by using the formula: \n\ninv33 = transpose(b)/det\n\nTranspose(b) represents the transpose of the matrix b, which is obtained by rearranging the elements of matrix b. \n\nEnsure that you have an understanding of the code before using it.",
            "Provide a Fortran function code named inv33 to compute the inverse of a 3x3 matrix. The function takes in a single input parameter of type real and dimension (3,3), and returns a 3x3 matrix of type real. The function calculates the determinant of the input matrix and uses it to compute the inverse matrix using the adjugate matrix divided by the determinant. Write the instruction for the inv33 function.",
            "Provide a Fortran function code named \"inv33\" that calculates the inverse of a 3x3 matrix. The function takes a single input argument of type \"real(8), dimension(3,3)\" and returns a 3x3 matrix of the same type as the output. The function first computes the determinant of the input matrix and assigns it to the variable \"det\". It then calculates the cofactor matrix by evaluating a series of mathematical expressions. Finally, it computes the transpose of the cofactor matrix and divides it by the determinant to obtain the inverse matrix."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real(8), dimension(3,3) :: a\n  real(8), dimension(3,3) :: result\n  \n  !case1\n  a = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0], [3,3])\n  result = inv33(a)\n  print *, result\n\n  !case2\n  a = reshape([2.0, 0.0, 1.0, -1.0, 1.0, 3.0, 4.0, 1.0, -2.0], [3,3])\n  result = inv33(a)\n  print *, result\n\n  !case3\n  a = reshape([0.0, 1.0, -1.0, 1.0, 0.0, 1.0, -1.0, 1.0, 0.0], [3,3])\n  result = inv33(a)\n  print *, result\n\n  !case4\n  a = reshape([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0], [3,3])\n  result = inv33(a)\n  print *, result\n\n  !case5\n  a = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 10.0], [3,3])\n  result = inv33(a)\n  print *, result\nend program main",
            "result": [
                "-Infinity                  Infinity                 -Infinity                  Infinity                 -Infinity                  Infinity                 -Infinity                  Infinity                 -Infinity",
                "0.33333333333333331       -6.6666666666666666E-002   6.6666666666666666E-002 -0.66666666666666663       0.53333333333333333       0.46666666666666667       0.33333333333333331       0.13333333333333333      -0.13333333333333333",
                "0.50000000000000000       0.50000000000000000      -0.50000000000000000       0.50000000000000000       0.50000000000000000       0.50000000000000000      -0.50000000000000000       0.50000000000000000       0.50000000000000000",
                "1.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        1.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        1.0000000000000000",
                "-0.66666666666666663       -1.3333333333333333        1.0000000000000000      -0.66666666666666663        3.6666666666666665       -2.0000000000000000        1.0000000000000000       -2.0000000000000000        1.0000000000000000"
            ]
        },
        "code": "      function inv33( a )  !==================contained in get_increment\n      implicit none\n      real(8), dimension(3,3), intent(in) :: a\n      real(8), dimension(3,3) :: b\n      real(8), dimension(3,3) :: inv33\n      real(8) :: det\n      det = - a(1,3)*a(2,2)*a(3,1) + a(1,2)*a(2,3)*a(3,1) + &\n               a(1,3)*a(2,1)*a(3,2) - a(1,1)*a(2,3)*a(3,2) - &\n               a(1,2)*a(2,1)*a(3,3) + a(1,1)*a(2,2)*a(3,3)\n      b= reshape( &\n         [-a(2,3)*a(3,2)+ a(2,2)*a(3,3), a(1,3)*a(3,2)-a(1,2)*a(3,3), &\n        -a(1,3)*a(2,2) + a(1,2)*a(2,3),  a(2,3)*a(3,1)- a(2,1)*a(3,3), &\n        -a(1,3)*a(3,1) + a(1,1)*a(3,3),  a(1,3)*a(2,1)- a(1,1)*a(2,3), &\n        -a(2,2)*a(3,1)  + a(2,1)*a(3,2), a(1,2)*a(3,1)- a(1,1)*a(3,2), &\n       -a(1,2)*a(2,1) + a(1,1)*a(2,2)]    ,[3,3]    )\n      inv33 = transpose(b)/det\n      end function inv33\n"
    },
    {
        "instruction": [
            "Write a Fortran function called \"good_dart_qc\" that determines whether a given Dart QC value is considered good or not. The function takes one input parameter, \"qc_value\", which is an integer representing a Dart QC value (not data QC). The function returns a logical value indicating whether the QC value is good or not.\n\nTo determine if the QC value is good, the function compares the input \"qc_value\" with three predefined Dart QC values: \"dartqc_assim_good_fop\", \"dartqc_eval_good_fop\", and \"dartqc_failed_outlier_test\". If the input \"qc_value\" matches any of the predefined values, the function sets the output \"good_dart_qc\" to true; otherwise, it sets it to false.\n\nThe function utilizes the Fortran features of defining input argument intent with \"integer, intent(in)\" for \"qc_value\" and specifying the output variable type with \"logical\" for \"good_dart_qc\".",
            "Please provide a Fortran function named \"good_dart_qc\" that takes an integer input parameter named \"qc_value\". The function should determine whether the input value is considered a good quality control value or not. The function should return a logical value indicating whether the input value is good or not.\n\nTo determine if the input value is good, check if it is equal to either \"dartqc_assim_good_fop\", \"dartqc_eval_good_fop\", or \"dartqc_failed_outlier_test\". If the input value matches any of these conditions, set the output logical value \"good_dart_qc\" to true. Otherwise, set it to false.\n\nPlease note that the input parameter \"qc_value\" is of type integer, and the output parameter \"good_dart_qc\" is of type logical.",
            "Give me a Fortran function code named good_dart_qc to check if a given Dart QC value is considered good or not. The number of input argument is 1 and its type is integer. The number of output argument is 1 and its type is logical."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: qc_value\n  logical :: is_good_qc\n  \n  !case1: qc_value = 2, expected output = .false.\n  qc_value = 2\n  is_good_qc = good_dart_qc(qc_value)\n  print *, is_good_qc\n  \n  !case2: qc_value = 5, expected output = .true.\n  qc_value = 5\n  is_good_qc = good_dart_qc(qc_value)\n  print *, is_good_qc\n  \n  !case3: qc_value = 1, expected output = .true.\n  qc_value = 1\n  is_good_qc = good_dart_qc(qc_value)\n  print *, is_good_qc\n  \n  !case4: qc_value = 0, expected output = .false.\n  qc_value = 0\n  is_good_qc = good_dart_qc(qc_value)\n  print *, is_good_qc\n  \n  !case5: qc_value = 3, expected output = .true.\n  qc_value = 3\n  is_good_qc = good_dart_qc(qc_value)\n  print *, is_good_qc\nend program main",
            "result": [
                "F",
                "F",
                "F",
                "T",
                "F"
            ]
        },
        "code": "function good_dart_qc(qc_value)\n\ninteger, intent(in) :: qc_value  !! incoming dart qc (not data qc)\nlogical             :: good_dart_qc  !! whether this is a good value or not\n\n\nif ( (qc_value == dartqc_assim_good_fop) .or. &\n     (qc_value == dartqc_eval_good_fop)  .or. &\n     (qc_value == dartqc_failed_outlier_test)) then\n   good_dart_qc = .true.\nelse\n   good_dart_qc = .false.\nendif\n\nend function good_dart_qc\n"
    },
    {
        "instruction": [
            "Write a Fortran function named cross_product that calculates the cross product of two 3-dimensional vectors. The function takes two double precision arrays, 'a' and 'b', as input parameters. The function returns a double precision array, 'cross_product', as the output parameter.",
            "Write a Fortran function code named cross_product that calculates the cross product of two 3-dimensional vectors. The function takes two input arguments, a and b, which are arrays of double precision numbers with a length of 3. The function returns an output array named cross_product, also of double precision type and length 3. The cross product is calculated by taking the determinants of the 2x2 matrices formed by the components of the input arrays.",
            "Write a Fortran function named cross_product that calculates the cross product of two 3D vectors. The function receives two input arguments of type double precision arrays, each with a dimension of 3. The function returns a double precision array with a dimension of 3 as the output. Please ensure that the function is pure, meaning it does not have any side effects and only depends on its input arguments."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  double precision, dimension(3) :: a, b, cp\n\n  !case1\n  a = [1.0, 2.0, 3.0]\n  b = [4.0, 5.0, 6.0]\n  cp = cross_product(a, b)\n  print *, cp\n\n  !case2\n  a = [0.0, 0.0, 0.0]\n  b = [1.0, 2.0, 3.0]\n  cp = cross_product(a, b)\n  print *, cp\n\n  !case3\n  a = [1.0, 0.0, 0.0]\n  b = [0.0, 1.0, 0.0]\n  cp = cross_product(a, b)\n  print *, cp\n\n  !case4\n  a = [-2.0, 5.0, 7.0]\n  b = [1.0, 3.0, -4.0]\n  cp = cross_product(a, b)\n  print *, cp\n\n  !case5\n  a = [0.3434, -0.234, 1.125]\n  b = [0.719, 0.345, -0.892]\n  cp = cross_product(a, b)\n  print *, cp\n\nend program main",
            "result": [
                "-3.0000000000000000        6.0000000000000000       -3.0000000000000000",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000",
                "0.0000000000000000        0.0000000000000000        1.0000000000000000",
                "-41.000000000000000       -1.0000000000000000       -11.000000000000000",
                "-0.17939699642348295        1.1151877876898766       0.28671899399137502"
            ]
        },
        "code": "\tpure function cross_product(a, b)\n\t\n\t\timplicit none\n\t\t\n\t\tdouble precision, dimension (3), intent (in) :: a, b\n\t\tdouble precision, dimension (3) :: cross_product\n\t\t\n\t\tcross_product(1) = a(2) * b(3) - a(3) * b(2)\n\t\tcross_product(2) = a(3) * b(1) - a(1) * b(3)\n\t\tcross_product(3) = a(1) * b(2) - a(2) * b(1)\n\t\t\n\tend function cross_product\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named tensor_product that computes the tensor product of two 3-dimensional vectors. The function takes two input arguments of type real, each with a dimension of 3, and returns a 3x3 matrix of type real as the output. The function uses the double precision data type for increased precision. Inside the function, a nested loop is used to calculate each element of the tensor product matrix by multiplying the corresponding elements of the two input vectors.",
            "Provide a Fortran function code named tensor_product that computes the tensor product of two vectors. The number of input arguments is 2 and the data type of each input argument is a double precision 3-dimensional array. The number of output arguments is 1 and the data type of the output argument is a double precision 3x3 matrix. The function takes two input arrays \"a\" and \"b\" and computes the tensor product by multiplying each element of \"a\" with each element of \"b\" and storing the result in a 3x3 matrix named \"tensor_product\".",
            "Write a Fortran function named \"tensor_product\" that calculates the tensor product of two input arrays. The input arrays are of type double precision, have a dimension of 3, and are passed by reference. The function returns a 2D array of type double precision with a dimension of 3x3, which represents the tensor product of the input arrays. Make sure to use the \"intent(in)\" keyword to indicate that the input arrays are read-only. Use a nested do loop to calculate each element of the resulting tensor product array."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  double precision, dimension(3) :: a, b\n  double precision, dimension(3,3) :: result\n  \n  !case1\n  a = [1.0, 2.0, 3.0]\n  b = [4.0, 5.0, 6.0]\n  result = tensor_product(a, b)\n  print *, result\n\n  !case2\n  a = [-1.0, 0.0, 1.0]\n  b = [1.0, 2.0, 3.0]\n  result = tensor_product(a, b)\n  print *, result\n\n  !case3\n  a = [0.0, 0.0, 0.0]\n  b = [1.0, -1.0, 1.0]\n  result = tensor_product(a, b)\n  print *, result\n\n  !case4\n  a = [2.0, 3.0, 4.0]\n  b = [5.0, 6.0, 7.0]\n  result = tensor_product(a, b)\n  print *, result\n\n  !case5\n  a = [1.0, 2.0, 3.0]\n  b = [0.0, 0.0, 0.0]\n  result = tensor_product(a, b)\n  print *, result\nend program main",
            "result": [
                "4.0000000000000000        8.0000000000000000        12.000000000000000        5.0000000000000000        10.000000000000000        15.000000000000000        6.0000000000000000        12.000000000000000        18.000000000000000",
                "-1.0000000000000000        0.0000000000000000        1.0000000000000000       -2.0000000000000000        0.0000000000000000        2.0000000000000000       -3.0000000000000000        0.0000000000000000        3.0000000000000000",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000       -0.0000000000000000       -0.0000000000000000       -0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000",
                "10.000000000000000        15.000000000000000        20.000000000000000        12.000000000000000        18.000000000000000        24.000000000000000        14.000000000000000        21.000000000000000        28.000000000000000",
                "0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000        0.0000000000000000"
            ]
        },
        "code": "\tpure function tensor_product(a, b)\n\t\n\t\timplicit none\n\t\t\n\t\tdouble precision, dimension (3), intent (in) :: a, b\n\t\tdouble precision, dimension (3, 3) :: tensor_product\n\t\tinteger :: i, j\n\t\t\n\t\tdo i = 1, 3\n\t\t\tdo j = 1, 3\n\t\t\t\ttensor_product (i, j) = a (i) * b (j)\n\t\t\tend do\n\t\tend do\n\t\t\n\tend function tensor_product\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named case2 to generate an array of real numbers with a given size and set the values to 1 if the index falls within a specified range, and 0 otherwise. The number of input arguments is 3 and the test_data type is [integer,integer,integer]. The number of output arguments is 1 and the test_data type is [real, dimension(n)].",
            "Provide a Fortran function code named case2 that generates an array where certain elements are set to 1 based on given criteria. The number of input arguments is 3: n, n_min, and n_max, all of integer type. The array rvcase2 is an output argument of type real and dimension n. \n\nTo use the function, call it with the desired values for n, n_min, and n_max. The function will initialize all elements of rvcase2 to 0, and then set elements within the range [n_min, n_max] to 1.",
            "Provide a Fortran function code named \"case2\" that generates a real array of size n and assigns the value 1 to elements between n_min and n_max (inclusive), and 0 to the rest of the elements. The function takes three input arguments: n (integer), n_min (integer), and n_max (integer). It returns an array of real numbers (rvcase2) of size n."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n, n_min, n_max\n  real, allocatable :: rvcase2(:)\n  \n  !case1\n  n = 5\n  n_min = 2\n  n_max = 4\n  allocate(rvcase2(n))\n  rvcase2 = case2(n, n_min, n_max)\n  print *, rvcase2\n  deallocate(rvcase2)\n\n  !case2\n  n = 8\n  n_min = 1\n  n_max = 6\n  allocate(rvcase2(n))\n  rvcase2 = case2(n, n_min, n_max)\n  print *, rvcase2\n  deallocate(rvcase2)\n\n  !case3\n  n = 10\n  n_min = 3\n  n_max = 8\n  allocate(rvcase2(n))\n  rvcase2 = case2(n, n_min, n_max)\n  print *, rvcase2\n  deallocate(rvcase2)\n\n  !case4\n  n = 6\n  n_min = 4\n  n_max = 6\n  allocate(rvcase2(n))\n  rvcase2 = case2(n, n_min, n_max)\n  print *, rvcase2\n  deallocate(rvcase2)\n\n  !case5\n  n = 7\n  n_min = 1\n  n_max = 3\n  allocate(rvcase2(n))\n  rvcase2 = case2(n, n_min, n_max)\n  print *, rvcase2\n  deallocate(rvcase2)\nend program main",
            "result": [
                "0.00000000       1.00000000       1.00000000       1.00000000       0.00000000",
                "1.00000000       1.00000000       1.00000000       1.00000000       1.00000000       1.00000000       0.00000000       0.00000000",
                "0.00000000       0.00000000       1.00000000       1.00000000       1.00000000       1.00000000       1.00000000       1.00000000       0.00000000       0.00000000",
                "0.00000000       0.00000000       0.00000000       1.00000000       1.00000000       1.00000000",
                "1.00000000       1.00000000       1.00000000       0.00000000       0.00000000       0.00000000       0.00000000"
            ]
        },
        "code": "    function case2(n, n_min, n_max) result(rvcase2)\n    \n        ! routine arguments\n        integer, intent(in)             :: n\n        integer, intent(in)             :: n_min\n        integer, intent(in)             :: n_max\n        real, dimension(n)              :: rvcase2\n        \n        ! locals\n        integer :: i\n        \n        ! generate the information desired\n        rvcase2 = 0.\n        do i = 1, n\n            if(i >= n_min .and. i <= n_max) then\n                rvcase2(i) = 1.\n            end if\n        end do\n        \n    end function case2\n"
    },
    {
        "instruction": [
            "Write a Fortran function named nbody_coeffs that calculates the coefficients of a combinatorial formula. The function takes three integer input parameters (k, m, n) and returns an integer output parameter (a). \n\nTo calculate the coefficients, the function initializes a to 1 and then performs two loops. In the first loop, it iterates from n-m+1 to n-k, multiplying a by each iteration value. In the second loop, it iterates from 1 to m-k, dividing a by each iteration value. \n\nYour task is to provide an instruction for this Fortran function, specifying the number and type of input and output parameters, as well as the name of the function.",
            "Create a Fortran function named nbody_coeffs that calculates a coefficient for an n-body problem. The function takes in three integer input arguments: k, m, and n. The function returns a single integer output argument named a. \n\nThe function uses a loop to calculate the value of a based on the given formula. The initial value of a is set to 1. The first loop iterates from n-m+1 to n-k, multiplying a by the loop index i at each iteration. The second loop iterates from 1 to m-k, dividing a by the loop index i at each iteration. Finally, the function returns the calculated value of a.",
            "Write a Fortran function named nbody_coeffs that calculates a specific coefficient used in n-body simulations. The function takes three input arguments, k, m, and n, which are integers. The function returns an integer.\n\nTo calculate the coefficient, the function performs two iterative loops. The first loop calculates the product of consecutive integers from (n-m+1) to (n-k) and stores the result in the variable 'a'. The second loop divides 'a' by consecutive integers from 1 to (m-k).\n\nYour task is to implement this function by using the given code as a starting point."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: k, m, n, a\n  \n  !case1\n  k = 2\n  m = 5\n  n = 10\n  a = nbody_coeffs(k, m, n)\n  print *, a\n\n  !case2\n  k = 1\n  m = 3\n  n = 6\n  a = nbody_coeffs(k, m, n)\n  print *, a\n\n  !case3\n  k = 0\n  m = 4\n  n = 8\n  a = nbody_coeffs(k, m, n)\n  print *, a\n\n  !case4\n  k = 3\n  m = 7\n  n = 12\n  a = nbody_coeffs(k, m, n)\n  print *, a\n\n  !case5\n  k = 2\n  m = 6\n  n = 9\n  a = nbody_coeffs(k, m, n)\n  print *, a\nend program main",
            "result": [
                "56",
                "10",
                "70",
                "126",
                "35"
            ]
        },
        "code": "function nbody_coeffs(k, m, n) result(a)\n    integer, intent(in) :: k, m, n\n    integer :: a\n\n    integer :: i\n\n    a = 1\n    do i = n-m+1, n-k\n        a = a*i\n    end do\n    do i = 1, m-k\n        a = a/i\n    end do\nend function nbody_coeffs\n"
    },
    {
        "instruction": [
            "Create a Fortran recursive function named \"ph\" that calculates the product of a given integer \"a\" with consecutive integers up to a specified number \"n\". The function takes two input parameters - \"a\" as an integer and \"n\" as an integer. The function returns an integer result named \"res\". Implement the function in such a way that if \"n\" is zero, the result is set to 1. Otherwise, the result is calculated by multiplying \"a\" with the recursive call to \"ph\" with incremented \"a\" and decremented \"n\".",
            "Provide a Fortran function named \"ph\" that uses recursion to compute the product of consecutive integers starting from a and going up to n. The function takes two input arguments, both of type integer, named a and n. The function returns a single output argument of type integer, named res, which stores the computed product.",
            "Provide a Fortran function code named ph that calculates the product of the numbers from 'a' to 'a+n-1' recursively. The function takes two integer input parameters 'a' and 'n' and returns an integer result."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: a, n, res\n  \n  !case1\n  a = 2\n  n = 3\n  res = ph(a, n)\n  print *, res\n\n  !case2\n  a = 1\n  n = 0\n  res = ph(a, n)\n  print *, res\n\n  !case3\n  a = -2\n  n = 4\n  res = ph(a, n)\n  print *, res\n\n  !case4\n  a = 5\n  n = 2\n  res = ph(a, n)\n  print *, res\n\n  !case5\n  a = 0\n  n = 5\n  res = ph(a, n)\n  print *, res\nend program main",
            "result": [
                "24",
                "1",
                "0",
                "30",
                "0"
            ]
        },
        "code": "recursive function ph(a, n) result(res)\n  integer, intent(in) :: a, n\n  integer :: res\n  if (n == 0 ) then\n     res = 1\n  else\n     res = a * ph(a + 1, n - 1)\n  end if\nend function\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named number that takes a single character string as input and calculates the numerical value of the string based on the sum of the ASCII values of its characters. The input parameter is of type character and has the intent of being read-only. The output parameter is an integer that stores the calculated numerical value.",
            "Give me a Fortran function code named number that calculates the numerical value of a given word. The input parameter is a character string named 'word'. The output parameter is an integer named 'number'. The function uses the len_trim() function to determine the length of the word and then iterates through each character of the word, calculating its corresponding numerical value. The function returns the total sum of the numerical values of all characters in the word.",
            "Provide a Fortran function code named \"number\" to convert a word into a corresponding number. The function takes a single input argument of type character and returns an output argument of type integer. The purpose of the function is to compute the sum of the positions of each letter in the alphabet (where 'a' is 1, 'b' is 2, etc.) in the given word. The input argument is specified as intent(in) and the output argument is not explicitly specified."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(10) :: word\n  \n  !case1\n  word = \"hello\"\n  print *, number(word)\n  \n  !case2\n  word = \"fortran\"\n  print *, number(word)\n  \n  !case3\n  word = \"programming\"\n  print *, number(word)\n  \n  !case4\n  word = \"test\"\n  print *, number(word)\n  \n  !case5\n  word = \"abcdefghijklmnopqrstuvwxyz\"\n  print *, number(word)\n  \nend program main",
            "result": [
                "52",
                "92",
                "124",
                "64",
                "55"
            ]
        },
        "code": "  pure function number(word)\n    character(*), intent(in) :: word\n    integer                  :: number,i\n\n    number=0\n    do i=1,len_trim(word)\n       number=number+(ichar(word(i:i+1))-ichar('a')+1)\n    end do\n\n  end function number\n"
    },
    {
        "instruction": [
            "Write a Fortran function named \"bmw_parallel_context_i\" that calculates the context index for a parallel computation. The function takes two input arguments, both of type integer, named \"index\" and \"num_i\". The function returns an integer value.\n\nTo compute the context index, the function subtracts 1 from the \"index\" argument, then takes the modulus of the result with the \"num_i\" argument. Finally, 1 is added to the modulus result and assigned to the function's return value.\n\nYour task is to provide the Fortran function code for \"bmw_parallel_context_i\" that follows the given instructions.",
            "Give me a Fortran function code named bmw_parallel_context_i that calculates the index of a parallel context based on the given index and the total number of contexts. The function takes in two arguments, both integers, where 'index' represents the current index and 'num_i' represents the total number of contexts. The function returns an integer which represents the calculated index of the parallel context.",
            "Write a Fortran function code named \"bmw_parallel_context_i\" that takes in two integer input parameters: \"index\" and \"num_i\". This function calculates the parallel context index for a given index and number of parallel elements. The function returns an integer value.\n\nTo use this function, pass the value of \"index\" and \"num_i\" as input arguments. The function will compute the parallel context index using the formula \"mod(index - 1, num_i) + 1\". Finally, the computed parallel context index will be returned as the output."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: index, num_i\n\n  !case1\n  index = 1\n  num_i = 5\n  print *, bmw_parallel_context_i(index, num_i)\n\n  !case2\n  index = 3\n  num_i = 2\n  print *, bmw_parallel_context_i(index, num_i)\n\n  !case3\n  index = 7\n  num_i = 4\n  print *, bmw_parallel_context_i(index, num_i)\n\n  !case4\n  index = 10\n  num_i = 3\n  print *, bmw_parallel_context_i(index, num_i)\n\n  !case5\n  index = 15\n  num_i = 6\n  print *, bmw_parallel_context_i(index, num_i)\n\nend program main",
            "result": [
                "1",
                "1",
                "3",
                "1",
                "3"
            ]
        },
        "code": "      pure function bmw_parallel_context_i(index, num_i)\n\n      implicit none\n\n!  declare arguments\n      integer :: bmw_parallel_context_i\n      integer, intent(in) :: index\n      integer, intent(in) :: num_i\n\n!  start of executable code\n      bmw_parallel_context_i = mod(index - 1, num_i) + 1\n\n      end function\n"
    },
    {
        "instruction": [
            "Write a Fortran function named \"bmw_parallel_context_j\" which takes three input parameters: an integer \"index\", an integer \"num_i\", and an integer \"num_j\". The function should return an integer value. \n\nThe function calculates the parallel context index for a given \"index\" value, based on the number of rows \"num_i\" and the number of columns \"num_j\". The computation is performed using the formula: \n\nparallel_context_index = ((index - 1) / num_i) modulo num_j + 1\n\nMake sure to define the function as \"pure\", indicating that it has no side effects and its output is solely determined by its input parameters.",
            "Create a Fortran function named \"bmw_parallel_context_j\" that takes in three input arguments, all of which are integers. The function calculates the value of \"bmw_parallel_context_j\" based on the formula: `(index - 1) / num_i modulo num_j + 1`. The function should return an integer value.",
            "Create a Fortran function named \"bmw_parallel_context_j\" that takes three integer inputs: \"index\", \"num_i\", and \"num_j\". The function is designed to calculate the value of \"bmw_parallel_context_j\" based on the given formula. The function should return an integer value."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: index\n  integer :: num_i\n  integer :: num_j\n  \n  !case1\n  index = 1\n  num_i = 5\n  num_j = 3\n  print *, bmw_parallel_context_j(index, num_i, num_j)\n\n  !case2\n  index = 7\n  num_i = 10\n  num_j = 4\n  print *, bmw_parallel_context_j(index, num_i, num_j)\n\n  !case3\n  index = 15\n  num_i = 6\n  num_j = 2\n  print *, bmw_parallel_context_j(index, num_i, num_j)\n\n  !case4\n  index = 20\n  num_i = 4\n  num_j = 5\n  print *, bmw_parallel_context_j(index, num_i, num_j)\n\n  !case5\n  index = 9\n  num_i = 3\n  num_j = 3\n  print *, bmw_parallel_context_j(index, num_i, num_j)\nend program main",
            "result": [
                "1",
                "1",
                "1",
                "5",
                "3"
            ]
        },
        "code": "      pure function bmw_parallel_context_j(index, num_i, num_j)\n\n      implicit none\n\n!  declare arguments\n      integer :: bmw_parallel_context_j\n      integer, intent(in) :: index\n      integer, intent(in) :: num_i\n      integer, intent(in) :: num_j\n\n!  start of executable code\n      bmw_parallel_context_j = mod((index - 1)/num_i, num_j) + 1\n\n      end function\n"
    },
    {
        "instruction": [
            "Write a Fortran function named scramble that takes an integer input argument, number_of_values, and returns an integer array. The function's purpose is to scramble the elements of the array. The number_of_values specifies the size of the array. The function uses random_number to generate a random number, u, between 0 and 1. The function then swaps the elements of the array randomly by iterating over the array twice and swapping elements at randomly generated indices. The function does this by initializing the array with values from 1 to number_of_values, and then shuffles the order of the elements. The function does not have any explicit output, but it modifies the input array in place.",
            "Write a Fortran function named scramble that takes an integer as input and returns an integer array as output. The function generates an array of consecutive integers from 1 to the input value. The function then performs a scrambling algorithm on the array, randomly rearranging its elements. The number of input arguments is 1 and the data type is integer. The number of output arguments is 1 and the data type is integer array.",
            "Provide a Fortran function named \"scramble\" that takes an integer input argument \"number_of_values\". It dynamically allocates an integer array \"array\" of size \"number_of_values\". The function uses a random number generator to scramble the elements of the array. The scrambled array is then returned as the output result of the function. The number of input arguments is 1 and the test_data type is [integer]. The number of output arguments is 1 and the test_data type is [integer, dimension(:), allocatable]."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: number_of_values\n  integer, allocatable :: array(:)\n\n  !case1\n  number_of_values = 5\n  allocate(array(number_of_values))\n  array = scramble(number_of_values)\n  print *, array\n  deallocate(array)\n\n  !case2\n  number_of_values = 10\n  allocate(array(number_of_values))\n  array = scramble(number_of_values)\n  print *, array\n  deallocate(array)\n\n  !case3\n  number_of_values = 3\n  allocate(array(number_of_values))\n  array = scramble(number_of_values)\n  print *, array\n  deallocate(array)\n\n  !case4\n  number_of_values = 8\n  allocate(array(number_of_values))\n  array = scramble(number_of_values)\n  print *, array\n  deallocate(array)\n\n  !case5\n  number_of_values = 6\n  allocate(array(number_of_values))\n  array = scramble(number_of_values)\n  print *, array\n  deallocate(array)\n\nend program main",
            "result": [
                "5           3           2           1           4",
                "8           6          10           3           2           9           7           1           5           4",
                "2           1           3",
                "6           4           3           7           8           1           2           5",
                "2           1           6           5           3           4"
            ]
        },
        "code": "    function scramble( number_of_values ) result(array)\n        integer, intent(in) :: number_of_values\n        integer, dimension(:), allocatable   :: array\n        integer :: i, j, k, m, n\n        integer :: temp\n        real :: u\n\n        array=[(i,i=1,number_of_values)]\n\n        n=1\n        m=number_of_values\n        do k=1,2\n            do i=1,m\n                call random_number(u)\n                j = n + floor((m+1-n)*u)\n                temp=array(j)\n                array(j)=array(i)\n                array(i)=temp\n            end do\n        end do\n\n    end function scramble\n"
    },
    {
        "instruction": [
            "Write a Fortran function code named find_next_unit that searches for the next available I/O unit number within a specified range. The function takes two optional integer arguments, istart and istop, to specify the range of unit numbers to search. The function returns an integer value, find_next_unit, which is the next available unit number found within the specified range.\n\nTo use the function, provide the optional arguments istart and istop if you want to limit the search range. Otherwise, the default range is from unit 20 to unit 1000. The function will return the first available unit number found within the specified range. If no available units are found, the function will return -1.\n\nUse this function to efficiently find an available I/O unit number for your Fortran program.",
            "Write a Fortran function named find_next_unit that finds the next available unit number for file I/O operations. The function takes two optional integer input arguments, istart and istop. The function returns an integer value as the output. \n\nTo find the next available unit number, the function starts checking from unit number 20 (or the value of istart if provided) and continues up to unit number 1000 (or the value of istop if provided). It checks if each unit is opened or not using the inquire function. If an available unit is found, the function returns the unit number. If no available unit is found, the function returns -1.",
            "Create a Fortran function named \"find_next_unit\" that finds the next available unit number for input/output operations. The function takes two optional input arguments, \"istart\" and \"istop\", both of type integer. The function returns a single integer value. If \"istart\" is provided, it sets the starting unit number to \"istart\", otherwise, it defaults to 20. If \"istop\" is provided, it sets the stopping unit number to \"istop\", otherwise, it defaults to 1000. The function iterates through the unit numbers from the starting unit to the stopping unit and checks if each unit is opened. If an unopened unit is found, the function returns that unit number. If all units are opened, the function returns -1."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: istart, istop, next_unit\n\n  !case1\n  istart = 1\n  istop = 5\n  next_unit = find_next_unit(istart, istop)\n  print *, next_unit\n\n  !case2\n  istart = 10\n  istop = 15\n  next_unit = find_next_unit(istart, istop)\n  print *, next_unit\n\n  !case3\n  istart = -100\n  istop = -90\n  next_unit = find_next_unit(istart, istop)\n  print *, next_unit\n\n  !case4\n  istart = 100\n  istop = 200\n  next_unit = find_next_unit(istart, istop)\n  print *, next_unit\n\n  !case5\n  istart = 0\n  istop = 0\n  next_unit = find_next_unit(istart, istop)\n  print *, next_unit\n\nend program main",
            "result": [
                "1",
                "10",
                "-100",
                "100",
                "-1"
            ]
        },
        "code": "  function find_next_unit(istart,istop)\n\n    implicit none\n\n    integer, intent(in), optional :: istart, istop\n    integer                       :: find_next_unit\n\n    logical :: opened\n    integer :: i, ifirst, ilast\n\n    ifirst = 20\n    if (present(istart)) ifirst = istart\n    ilast = 1000\n    if (present(istop)) ilast = istop\n    \n    opened         = .true.\n    find_next_unit = -1\n    do i=ifirst, ilast\n       inquire(unit=i, opened=opened)\n       if (.not. opened) then\n          find_next_unit = i\n          exit\n       end if\n    end do\n\n  end function find_next_unit\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named checkargs to validate the input arguments for sand, clay, and ompc. The function takes 3 input arguments of type real: sand, clay, and ompc. The function returns a logical value indicating whether the input arguments are valid or not. The number of input arguments is 3 and the test_data type is [real, real, real]. The number of output arguments is 1 and the test_data type is [logical].",
            "Provide a Fortran function code named checkargs that checks the validity of three input arguments: sand, clay, and ompc. The function returns a logical value indicating whether the arguments pass the validation checks or not. The function takes three input arguments of type real and returns one output argument of type logical. In the function, if any of the input arguments are outside the allowable range, or if the sum of sand and clay exceeds 1.0, the function sets the output argument to false. Otherwise, the output argument is set to true.",
            "Write a Fortran function named \"checkargs\" to validate three input parameters: sand, clay, and ompc. The function returns a logical value indicating whether the input parameters meet certain conditions. \n\nThe function takes three input arguments, all of them are real numbers: sand, clay, and ompc. It has one output argument, a logical value called \"ok\".\n\nIn the function, set the initial value of \"ok\" to true. Then, check if sand, clay, and ompc are within certain ranges. If any of these parameters are outside the specified range, set \"ok\" to false. Additionally, if the sum of sand and clay is greater than 1.0, set \"ok\" to false.\n\nUse this \"checkargs\" function to verify if the input parameters meet the specified criteria."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real :: sand, clay, ompc\n  logical :: ok\n  \n  !case1\n  sand = 0.5\n  clay = 0.3\n  ompc = 50.0\n  print *, checkargs(sand, clay, ompc)\n  \n  !case2\n  sand = 0.8\n  clay = 0.2\n  ompc = 60.0\n  print *, checkargs(sand, clay, ompc)\n  \n  !case3\n  sand = 0.2\n  clay = 0.9\n  ompc = 30.0\n  print *, checkargs(sand, clay, ompc)\n  \n  !case4\n  sand = 1.2\n  clay = 0.6\n  ompc = 40.0\n  print *, checkargs(sand, clay, ompc)\n  \n  !case5\n  sand = -0.1\n  clay = 0.5\n  ompc = 20.0\n  print *, checkargs(sand, clay, ompc)\n  \nend program main",
            "result": [
                "T",
                "T",
                "F",
                "F",
                "F"
            ]
        },
        "code": "\tfunction checkargs ( sand, clay, ompc ) result ( ok )\n\n\t    real, intent (in) :: sand, clay, ompc\n\t    logical :: ok\n\n\t    ok = .true.\n\t    if ( sand < 0.0 .or. sand > 1.0 ) then\n\t\tok = .false.\n\t    end if\n\t    if ( clay < 0.0 .or. clay > 1.0 ) then\n\t\tok = .false.\n\t    end if\n\t    if ( ompc < 0.0 .or. ompc > 70.0 ) then\n\t\tok = .false.\n\t    end if\n\t    if ( sand + clay > 1.0 ) then\n\t\tok = .false.\n\t    end if\n\n\tend function checkargs\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named ve_x_m to calculate the matrix-vector product. The function takes two input arguments, b and a, where b is a one-dimensional array of double precision floating-point numbers and a is a two-dimensional array of double precision floating-point numbers. The function returns a one-dimensional array of double precision floating-point numbers as the output.",
            "Write a Fortran function named \"ve_x_m\" to perform vector-matrix multiplication. The function takes two input parameters: a vector \"b\" of double precision values and a matrix \"a\" of double precision values. The size of the vector \"b\" and the number of rows in the matrix \"a\" should be the same. The function returns a vector \"c\" of double precision values with the same size as \"b\". The function uses a nested loop to compute the element-wise product of each row of the matrix \"a\" with the corresponding element of the vector \"b\", and then sums up these products to calculate the elements of the resulting vector \"c\".",
            "Give me a Fortran function code named ve_x_m to perform matrix-vector multiplication. The function takes two input arguments: a one-dimensional array of double precision numbers (b) and a two-dimensional array of double precision numbers (a). The function returns a one-dimensional array of double precision numbers (c). The number of elements in b determines the size of the resulting array c. The function calculates the dot product of each row of the matrix a with the vector b and stores the results in the array c. Write the instructions for this code."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n\n  double precision, allocatable :: b(:)\n  double precision, allocatable :: a(:,:)\n  \n  !case1\n  n = 2\n  allocate(b(n))\n  allocate(a(n,n))\n  b = [1.0, 2.0]\n  a = reshape([1.0, 2.0, 3.0, 4.0], [2, 2])\n  print *, ve_x_m(b, a)\n  deallocate(b)\n  deallocate(a)\n\n  !case2\n  n = 3\n  allocate(b(n))\n  allocate(a(n,n))\n  b = [0.5, 1.0, 1.5]\n  a = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0], [3, 3])\n  print *, ve_x_m(b, a)\n  deallocate(b)\n  deallocate(a)\n\n  !case3\n  n = 4\n  allocate(b(n))\n  allocate(a(n,n))\n  b = [1.0, 2.0, 3.0, 4.0]\n  a = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0], [4, 3])\n  print *, ve_x_m(b, a)\n  deallocate(b)\n  deallocate(a)\n\n  !case4\n  n = 2\n  allocate(b(n))\n  allocate(a(n,n))\n  b = [0.0, 0.0]\n  a = reshape([1.0, 2.0, 3.0, 4.0], [2, 2])\n  print *, ve_x_m(b, a)\n  deallocate(b)\n  deallocate(a)\n\n  !case5\n  n = 3\n  allocate(b(n))\n  allocate(a(n,n))\n  b = [0.5, 1.0, -1.5]\n  a = reshape([1.0, 2.0, 3.0, -1.0, -2.0, -3.0, 0.5, 1.5, 2.0], [3, 3])\n  print *, ve_x_m(b, a)\n  deallocate(b)\n  deallocate(a)\nend program main",
            "result": [
                "5.0000000000000000        11.000000000000000",
                "7.0000000000000000        16.000000000000000        25.000000000000000",
                "30.000000000000000        70.000000000000000        110.00000000000000        2.9361541623076294E+224",
                "0.0000000000000000        0.0000000000000000",
                "-2.0000000000000000        2.0000000000000000       -1.2500000000000000"
            ]
        },
        "code": "function ve_x_m(b,a) result (c)\nimplicit none\n\n    double precision, dimension(:), intent (in) :: b\n    double precision, dimension(:,:), intent (in) :: a\n    double precision, dimension(size(b)) :: c\n    integer i,j\n    \n    do i=1,size(b)\n       c(i)=0.d0\n       do j=1,size(b)\n          c(i)=c(i)+a(j,i)*b(j)\n       enddo\n    enddo\n\nend function\n"
    },
    {
        "instruction": [
            "Please create a Fortran function named \"isinmset\" that determines whether a complex number is in the Mandelbrot set. The function takes two input parameters: a complex number \"c\" and an integer \"maxiter\". The function returns a logical value indicating whether the given complex number is in the Mandelbrot set. The function uses an iterative process to calculate whether the complex number diverges or remains within a certain range. The number of input arguments is 2 and the data types are complex and integer. The number of output arguments is 1 and the data type is logical.",
            "Write a Fortran function named \"isinmset\" that checks if a complex number is within the Mandelbrot set. The function takes two input parameters: a complex number \"c\" and an integer \"maxiter\". The return value is a logical variable indicating whether the complex number is within the Mandelbrot set.\n\nInside the function, the complex number \"z\" is initialized to (0,0) and the integer \"n\" is set to 0. The function then checks if the absolute value of the difference between \"c\" and (-1,0) is less than 0.25, or if the absolute value of the difference between 1.0 and the square root of (1 - 4*c) is less than 1.0. If either of these conditions is true, the function sets the logical variable \"isinmset\" to .true. \n\nA loop is then executed while the absolute value of \"z\" is less than 4 and \"n\" is less than \"maxiter\". In each iteration, \"z\" is updated by squaring it and adding \"c\", and \"n\" is incremented by 1. \n\nFinally, the function checks if \"n\" is greater than or equal to \"maxiter\". If true, \"isinmset\" is set to .true., indicating that the complex number is within the Mandelbrot set. Otherwise, \"isinmset\" is set to .false., indicating that the complex number is not within the Mandelbrot set.",
            "Provide a Fortran function code named isinmset to check if a given complex number is in the Mandelbrot set. The function takes two input arguments, a complex number (c) and an integer (maxiter) representing the maximum number of iterations. The function returns a logical value (isinmset) indicating whether the complex number is in the set or not."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: maxiter\n  complex :: c\n  \n  !case1\n  maxiter = 100\n  c = cmplx(0.5, 0.5)\n  print *, isinmset(c, maxiter)\n\n  !case2\n  maxiter = 500\n  c = cmplx(1.5, -2.0)\n  print *, isinmset(c, maxiter)\n\n  !case3\n  maxiter = 200\n  c = cmplx(-0.75, 0.1)\n  print *, isinmset(c, maxiter)\n\n  !case4\n  maxiter = 1000\n  c = cmplx(0.0, 0.0)\n  print *, isinmset(c, maxiter)\n\n  !case5\n  maxiter = 50\n  c = cmplx(0.1, 0.3)\n  print *, isinmset(c, maxiter)\nend program main",
            "result": [
                "F",
                "F",
                "F",
                "T",
                "T"
            ]
        },
        "code": "pure function isinmset(c, maxiter)\n\n    complex, intent(in) :: c\n    integer, intent(in) :: maxiter\n    integer :: n\n    complex :: z\n    logical :: isinmset\n    \n    z = cmplx(0,0)\n    n = 0\n    if(((abs(c - cmplx(-1,0))) < 0.25) .or. ((abs(1.0 - sqrt(1-(4*c)))) < 1.0)) then\n        isinmset = .true.\n    end if\n\n    do while(abs(z) < 4 .and. (n < maxiter))\n        z = z*z+c\n        n = n+1\n    end do\n\n    if(n >= maxiter) then\n        isinmset = .true.\n    else\n        isinmset = .false.\n    end if    \n\nend function isinmset\n"
    },
    {
        "instruction": [
            "Write a Fortran function named \"colon\" that takes two integer parameters, \"a\" and \"b\". The function will return an array of integers that represents the range from \"a\" to \"b\" (inclusive). The number of input arguments is 2 and the data type is [integer, integer]. The number of output arguments is 1 and the data type is [integer array].",
            "Write a Fortran function called colon that takes in two integer arguments and returns an array of integers. The number of input arguments is 2 and their type is integer. The number of output arguments is 1 and its type is an integer array. The function's purpose is to generate an array of integers starting from the first input argument and ending at the second input argument. The function should be used with the format: result = colon(a, b), where 'a' is the starting value and 'b' is the ending value.",
            "Write a Fortran function named colon that generates an array of integers between two given values. The number of input arguments is 2 integers, and the number of output arguments is an array of integers."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: a, b\n  integer, allocatable :: result(:)\n  \n  !case1\n  a = 1\n  b = 5\n  result = colon(a, b)\n  print *, result\n  deallocate(result)\n\n  !case2\n  a = -3\n  b = 3\n  result = colon(a, b)\n  print *, result\n  deallocate(result)\n\n  !case3\n  a = 0\n  b = 0\n  result = colon(a, b)\n  print *, result\n  deallocate(result)\n\n  !case4\n  a = 100\n  b = 105\n  result = colon(a, b)\n  print *, result\n  deallocate(result)\n\n  !case5\n  a = -10\n  b = -5\n  result = colon(a, b)\n  print *, result\n  deallocate(result)\n  \nend program main",
            "result": [
                "1           2           3           4           5",
                "-3          -2          -1           0           1           2           3",
                "0",
                "100         101         102         103         104         105",
                "-10          -9          -8          -7          -6          -5"
            ]
        },
        "code": "\tpure function colon(a,b)\r\n\t\timplicit none\r\n\t\tinteger, intent(in) :: a,b\r\n\t\tinteger, dimension(1:b-a+1) :: colon\r\n\t\tinteger :: i\r\n\t\tdo i = a,b\r\n\t\t\tcolon(i-a+1) = i\r\n\t\tend do\r\n\tend function colon\r\n"
    },
    {
        "instruction": [
            "Provide a Fortran function named calc_ep that calculates an error probability (ep) based on given input parameters. The function takes three input arguments: fx0, ep0, and fx, all of type real*8. The output of the function is a real*8 value representing the calculated error probability.\n\nTo compute the error probability, the function uses a set of calculations involving the input values and intermediate variables. These calculations involve the quadratic equation where coefficients are computed based on the input values and intermediate variables. The function then solves the equation to find the roots (r1 and r2) using the quadratic formula.\n\nThe function checks if r1 or r2 is greater than 0. If r1 is greater than 0, the error probability (ep) is set to 1 minus r1. If r2 is greater than 0, the error probability (ep) is set to 1 minus r2. If both r1 and r2 are less than or equal to 0, an error message is printed and the error probability (ep) is set to the initial input value (ep0).\n\nThe function returns the calculated error probability (ep) as the output.",
            "Write a Fortran function named calc_ep that calculates the value of the variable \"ep\" based on the input parameters \"fx0\", \"ep0\", and \"fx\". The function takes three input arguments of type real*8: \"fx0\", \"ep0\", and \"fx\". It returns a single output argument \"ep\" of type real*8.\n\nThe function computes the value of \"ep\" using a mathematical formula. It first calculates the values of \"r1\" and \"r2\" using the quadratic formula. Then, it checks the values of \"r1\" and \"r2\" to determine the value of \"ep\". If \"r1\" is greater than 0, \"ep\" is set to (1 - r1). If \"r2\" is greater than 0, \"ep\" is set to (1 - r2). If neither \"r1\" nor \"r2\" is greater than 0, an error message is printed and \"ep\" is set to the initial value \"ep0\".\n\nTo use this function, provide the values of \"fx0\", \"ep0\", and \"fx\" as input arguments and receive the calculated value of \"ep\" as the output.",
            "Provide a Fortran function named calc_ep that calculates the value of the variable \"ep\". The function takes in three input parameters: fx0 of type real*8, ep0 of type real*8, and fx of type real*8. The function also has one output parameter: ep of type real*8. \nThe purpose of the function is to calculate the value of \"ep\" using the given input parameters and a set of mathematical operations. The function first computes the values of \"a\", \"b\", \"c\", and \"d\" based on the input parameters. Then, it calculates the values of \"r1\" and \"r2\" using a quadratic formula. Finally, it determines the value of \"ep\" based on the conditions: if \"r1\" is greater than 0, \"ep\" is set to (1-r1); if \"r2\" is greater than 0, \"ep\" is set to (1-r2); otherwise, an error message is displayed and \"ep\" is set to the initial value of ep0."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real*8 :: fx0, ep0, fx, ep\n  \n  !case1\n  fx0 = 0.5\n  ep0 = 0.2\n  fx = 0.3\n  ep = calc_ep(fx0, ep0, fx)\n  print *, ep\n  \n  !case2\n  fx0 = 0.1\n  ep0 = 0.5\n  fx = 0.9\n  ep = calc_ep(fx0, ep0, fx)\n  print *, ep\n  \n  !case3\n  fx0 = 0.8\n  ep0 = 0.3\n  fx = 0.6\n  ep = calc_ep(fx0, ep0, fx)\n  print *, ep\n  \n  !case4\n  fx0 = 0.2\n  ep0 = 0.1\n  fx = 0.4\n  ep = calc_ep(fx0, ep0, fx)\n  print *, ep\n  \n  !case5\n  fx0 = 0.9\n  ep0 = 0.6\n  fx = 0.7\n  ep = calc_ep(fx0, ep0, fx)\n  print *, ep\nend program main",
            "result": [
                "0.27737399713183053",
                "-0.19536364823344643",
                "0.26144652230708187",
                "-4.7213596990073992E-002",
                "0.26175241953049988"
            ]
        },
        "code": "function calc_ep(fx0,ep0,fx) result(ep)\n\n      real*8,intent(in) :: fx0,ep0,fx\n      real*8 :: ep\n      real*8 :: a,b,c,d\n      real*8 :: r1,r2,dratio,k\n\n      !ep = 1.d0-(1.d0-fx0)*(1.d0-ep0)/(1.d0-fx)\n      !ep = fx0*(1-ep0)+ep0-fx\n\n      dratio=2.0\n\n      k = (fx0/(1-fx0) + dratio)/(1-ep0)\n\n      a = k;\n      b = -(dratio+k*fx);\n      c = dratio*fx - fx;\n\n      d = b*b - 4.d0*a*c\n\n      r1 = 0.5*(-b + sqrt(d))/a\n      r2 = 0.5*(-b - sqrt(d))/a\n\n      !print *,\"r1,r2:\",r1,r2\n\n      if(r1 > 0) then\n\t      ep=(1-r1)\n      else if(r2 > 0) then\n\t      ep=(1-r2)\n      else\n\t      print *,\"error, r1 and r2:\",r1,r2\n\t      ep=ep0\n      endif\n\n\nend function calc_ep\n"
    },
    {
        "instruction": [
            "Provide a Fortran recursive function code named \"basename\" that takes a character string as input and returns the basename of a file path. The function determines the position of the last '/' character in the input string and extracts the substring after it. If no '/' is found, the input string itself is returned. The function uses the Fortran keywords \"recursive\" and \"function\". The input parameter is a character string of any length, and the output parameter is a character string of the same length.",
            "Write a recursive Fortran function named \"basename\" that extracts the base name of a file path. The function takes in one input argument of type character array, representing the file path. The output of the function is a character array, containing the base name of the file path.\n\nTo use the function, provide the file path as the input argument to the function. The function will recursively search for the last occurrence of the delimiter character (\"/\") in the file path, and return the substring after the delimiter as the base name of the file path.\n\nIf the input file path consists only of the delimiter (\"/\"), the function returns the delimiter itself (\"/\").\n\nIf no delimiter is found in the file path, the function returns the entire file path.\n\nThe function is recursive, meaning it calls itself to handle cases where the file path ends with multiple delimiters. In such cases, the function discards the last delimiter and recursively calls itself with the remaining substring of the file path.\n\nEnsure that the length of the input character array matches the length of the file path, and assign the returned base name to a character array.",
            "Create a recursive Fortran function called \"basename\" that extracts the base name from a given file path. The function takes one input argument, a character string representing the file path, and returns one output argument, a character string representing the base name of the file. The input argument is of type \"character(len=*)\" and is passed by value. The output argument is of type \"character(len=len(fname))\" and is the result of the function. The function uses the forward slash ('/') as the delimiter to identify the base name in the file path. If the input string is just a delimiter ('/'), the function returns the delimiter itself. If no delimiter is found in the input string, the function returns without any changes. If the delimiter is found before the end of the input string, the function extracts the base name by removing the path and returns it. If the last character of the input string is a delimiter ('/'), the function makes a recursive call to extract the base name without the trailing delimiter."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=100) :: fname\n  character(len=100) :: retchar\n\n  !case1\n  fname = '/path/to/file.txt'\n  retchar = basename(fname)\n  print *, trim(retchar)\n\n  !case2\n  fname = '/usr/local/bin'\n  retchar = basename(fname)\n  print *, trim(retchar)\n\n  !case3\n  fname = 'filename.ext'\n  retchar = basename(fname)\n  print *, trim(retchar)\n\n  !case4\n  fname = '/var/www/html/'\n  retchar = basename(fname)\n  print *, trim(retchar)\n\n  !case5\n  fname = '/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w/x/y/z'\n  retchar = basename(fname)\n  print *, trim(retchar)\n\nend program main",
            "result": [
                "file.txt",
                "bin",
                "filename.ext",
                "html",
                "z"
            ]
        },
        "code": "  recursive function basename(fname) result(retchar)\n    character(len=1), parameter :: delimeter = '/'\n    character(len=*), intent(in) :: fname\n    character(len=len(fname)) :: retchar\n\n    integer :: pos\n\n    retchar = fname\n    if (trim(retchar) == delimeter) return  ! basename('/') ! => '/'\n\n    pos = scan(trim(retchar), delimeter, back=.true.)\n    if (pos .le. 0) return  ! no delimiter is found.\n    if (pos < len_trim(retchar)) then\n      retchar = fname(pos+1:len_trim(retchar))\n      return\n    end if\n\n    ! now, the last character of fname is delimiter='/'.\n    ! then, for example, if fname=='abc//', this returns 'abc' (by recursive calls).\n    retchar = basename(fname(1:pos-1))\n  end function basename\n"
    },
    {
        "instruction": [
            "Create a Fortran function named \"dump_int1_binary\" that takes an integer of kind 1 as input. The function will convert the input integer into a binary representation and return it as a character string of length 8. The number of input arguments is 1 and the data type is integer(kind=1). The number of output arguments is 1 and the data type is character(len=8).",
            "Give me a Fortran function code named dump_int1_binary to convert a 1-byte integer into an 8-bit binary representation. The code takes an input argument of type integer(kind=1). The number of input arguments is 1 and the data type is integer(kind=1). The number of output arguments is 1 and the data type is character(len=8).",
            "Provide a Fortran function named \"dump_int1_binary\" that converts a 1-byte integer into its binary representation. The function takes one input argument of type integer(kind=1). The output is a character string of length 8 representing the binary representation of the input integer."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer(kind=1) :: i1\n  character(len=8) :: binary\n\n  !case1\n  i1 = 1\n  binary = dump_int1_binary(i1)\n  print *, binary\n\n  !case2\n  i1 = -1\n  binary = dump_int1_binary(i1)\n  print *, binary\n\n  !case3\n  i1 = 127\n  binary = dump_int1_binary(i1)\n  print *, binary\n\n  !case4\n  i1 = -64\n  binary = dump_int1_binary(i1)\n  print *, binary\n\n  !case5\n  i1 = 0\n  binary = dump_int1_binary(i1)\n  print *, binary\n\nend program main",
            "result": [
                "00000001",
                "11111111",
                "01111111",
                "11000000",
                "00000000"
            ]
        },
        "code": "  function dump_int1_binary(i1) result(retc)\n    integer(kind=1), intent(in) :: i1\n    character(len=8) :: retc\n    integer :: j, k\n\n    retc(:) = '00000000'\n    do j=0, 7\n      k = 8-j\n      if (btest(i1, j)) retc(k:k) = '1'\n    end do\n  end function dump_int1_binary\n"
    },
    {
        "instruction": [
            "Write a Fortran function named dump_int2_binary that converts a 2-byte integer into its binary representation. The function takes one input argument of type integer(kind=2) and returns a character string representing the binary value. The name of the function is \"dump_int2_binary\".",
            "Create a Fortran function named `dump_int2_binary` that converts a 2-byte integer into a binary string representation. The function takes an input parameter of type `integer(kind=2)` and returns a result of type `character(len=ikind*8+ikind-1)`. The function uses the `btest` function to check the individual bits of the input integer and builds a binary string representation by assigning '1' or '0' to each bit position. The resulting binary string is then concatenated with underscores (_) to separate each byte of the integer.",
            "Provide a Fortran function code named dump_int2_binary that converts a 2-byte integer into its binary representation. The function takes in one input argument of type integer(kind=2) and returns a string containing the binary representation. The name of the function is dump_int2_binary."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer(kind=2) :: i2\n  \n  !case1\n  i2 = 0\n  print *, dump_int2_binary(i2)\n  \n  !case2\n  i2 = 32767\n  print *, dump_int2_binary(i2)\n  \n  !case3\n  i2 = -32768\n  print *, dump_int2_binary(i2)\n  \n  !case4\n  i2 = 1234\n  print *, dump_int2_binary(i2)\n  \n  !case5\n  i2 = -5678\n  print *, dump_int2_binary(i2)\n  \nend program main",
            "result": [
                "00000000_00000000",
                "01111111_11111111",
                "10000000_00000000",
                "00000100_11010010",
                "11101001_11010010"
            ]
        },
        "code": "  function dump_int2_binary(i2) result(retc)\n    integer, parameter :: ikind = 2\n    integer(kind=2), intent(in) :: i2\n    character(len=8), dimension(ikind) :: tmpc\n    character(len=ikind*8+ikind-1) :: retc\n    integer :: ir, j, k\n\n    tmpc(:) = '00000000'\n    do ir=1, ikind\n      do j=0, 7\n        k = 8-j\n        if (btest(i2, j+(ir-1)*8)) tmpc(ir)(k:k) = '1'\n      end do\n    end do\n\n    retc = tmpc(ikind)\n    do j = ikind-1, 1, -1\n      retc = trim(retc)//'_'//tmpc(j)\n    end do\n  end function dump_int2_binary\n"
    },
    {
        "instruction": [
            "Create a Fortran function called \"norma\" that computes the norm of the difference between two vectors. The function takes two input arguments, \"vec1\" and \"vec2\", which are double precision arrays. The function returns a single double precision value, \"y\", which represents the maximum absolute difference between corresponding elements of \"vec1\" and \"vec2\".",
            "Please provide a Fortran function named \"norma\" that computes the maximum absolute difference between two double precision vectors. The function should have two input arguments of type double precision, named \"vec1\" and \"vec2\", both being allocatable arrays. The function should return a single output of type double precision, named \"y\".",
            "Write a Fortran function code named norma that calculates the maximum absolute difference between two arrays. The function takes two input arguments, both of which are dynamically allocated arrays of double precision numbers. The function returns a single output argument of type double precision."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n\n  double precision, allocatable :: vec1(:), vec2(:)\n  \n  !case1\n  n=3\n  allocate(vec1(n))\n  allocate(vec2(n))\n  vec1 = [1.0, 2.0, 3.0]\n  vec2 = [4.0, 5.0, 6.0]\n  print *, norma(vec1, vec2)\n  deallocate(vec1, vec2)\n\n  !case2\n  n=4\n  allocate(vec1(n))\n  allocate(vec2(n))\n  vec1 = [0.0, 0.0, 0.0, 0.0]\n  vec2 = [1.0, 1.0, 1.0, 1.0]\n  print *, norma(vec1, vec2)\n  deallocate(vec1, vec2)\n\n  !case3\n  n=2\n  allocate(vec1(n))\n  allocate(vec2(n))\n  vec1 = [1.5, 2.5]\n  vec2 = [3.5, 4.5]\n  print *, norma(vec1, vec2)\n  deallocate(vec1, vec2)\n\n  !case4\n  n=5\n  allocate(vec1(n))\n  allocate(vec2(n))\n  vec1 = [1.0, 2.0, 3.0, 4.0, 5.0]\n  vec2 = [5.0, 4.0, 3.0, 2.0, 1.0]\n  print *, norma(vec1, vec2)\n  deallocate(vec1, vec2)\n\n  !case5\n  n=6\n  allocate(vec1(n))\n  allocate(vec2(n))\n  vec1 = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]\n  vec2 = [2.0, 4.0, 6.0, 8.0, 10.0, 12.0]\n  print *, norma(vec1, vec2)\n  deallocate(vec1, vec2)\nend program main\n",
            "result": [
                "3.0000000000000000",
                "1.0000000000000000",
                "2.0000000000000000",
                "4.0000000000000000",
                "6.0000000000000000"
            ]
        },
        "code": "    function norma(vec1,vec2) result(y)\n\n        implicit none\n\n        \n        double precision, dimension(:), allocatable :: vec1, vec2\n        double precision :: y\n\n        \n        y = maxval(abs(vec1 - vec2))\n\n    end function norma \n"
    },
    {
        "instruction": [
            "Write a Fortran function named \"test_replace_text\" that replaces occurrences of a specific text (the \"needle\") with another text (the \"replacement\") within a given text (the \"haystack\"). The function takes 3 input parameters: \"haystack\" (a character string), \"needle\" (a character string representing the text to be replaced), and \"replacement\" (a character string representing the text to replace the \"needle\" with). The function returns the modified \"haystack\" as the output.",
            "Please write a Fortran function named \"test_replace_text\" that replaces occurrences of a given substring, \"needle\", with another substring, \"replacement\", within a given string, \"haystack\". The function should return the modified string as the output. The input parameters for the function are three character strings: \"haystack\" which represents the original string, \"needle\" which represents the substring to be replaced, and \"replacement\" which represents the substring to replace \"needle\" with. The output parameter is a character string named \"output\" that contains the modified string after all replacements have been made.",
            "Write a Fortran function named test_replace_text to replace occurrences of a specified substring with a replacement substring within a given string. The function takes three input arguments and returns one output argument. The input arguments are of type character and represent the original string (haystack), the substring to be replaced (needle), and the replacement substring (replacement). The output argument is also of type character and represents the modified string with the replacements made (output)."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(100) :: haystack, needle, replacement\n  character(len(haystack)+100) :: output\n  \n  !case1\n  haystack = \"Hello World\"\n  needle = \"World\"\n  replacement = \"Universe\"\n  output = test_replace_text(haystack, needle, replacement)\n  print *, output\n\n  !case2\n  haystack = \"This is a test\"\n  needle = \"is\"\n  replacement = \"was\"\n  output = test_replace_text(haystack, needle, replacement)\n  print *, output\n\n  !case3\n  haystack = \"123456789\"\n  needle = \"4\"\n  replacement = \"X\"\n  output = test_replace_text(haystack, needle, replacement)\n  print *, output\n\n  !case4\n  haystack = \"AAAAA\"\n  needle = \"A\"\n  replacement = \"B\"\n  output = test_replace_text(haystack, needle, replacement)\n  print *, output\n\n  !case5\n  haystack = \"aaaaa\"\n  needle = \"b\"\n  replacement = \"B\"\n  output = test_replace_text(haystack, needle, replacement)\n  print *, output\nend program main",
            "result": [
                "Hello Universe",
                "Thwas was a test",
                "123X56789",
                "BBBBB",
                "aaaaa"
            ]
        },
        "code": "    function test_replace_text(haystack, needle, replacement) result(output)\n        character(*) :: haystack, needle, replacement\n        character(len(haystack)+100) :: output\n        integer :: i, in, ir\n\n        output = haystack\n        in = len_trim(needle)\n        ir = len_trim(replacement)\n        do\n           i = index(output, needle(:in))\n           if (i == 0) exit\n           output = output(:i-1) // replacement(:ir) // output(i+in:)\n        end do\n\n    end function\n"
    },
    {
        "instruction": [
            "Write a Fortran function named \"random_integer\" that generates a random integer within a specified range. The function takes two input arguments of type integer, vmin and vmax. The function returns a single output value of type integer, val.",
            "Please provide a Fortran function named \"random_integer\" to generate a random integer within a specified range. The function should have two input parameters of type integer: vmin and vmax. The function should return an output integer value.",
            "Provide a Fortran function code named random_integer that generates a random integer within a given range. The function takes two input arguments, vmin and vmax, both of type integer. The function returns a single output argument, val, also of type integer. To use this function, vmin and vmax must be provided as inputs. The function generates a random real number using the random_number subroutine and then scales and shifts it to the desired range using floor and arithmetic operations. The resulting integer value is stored in val."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: vmin, vmax, val\n\n  !case1\n  vmin = 1\n  vmax = 10\n  val = random_integer(vmin, vmax)\n  print *, val\n\n  !case2\n  vmin = -100\n  vmax = 100\n  val = random_integer(vmin, vmax)\n  print *, val\n\n  !case3\n  vmin = 0\n  vmax = 1\n  val = random_integer(vmin, vmax)\n  print *, val\n\n  !case4\n  vmin = -1000\n  vmax = -500\n  val = random_integer(vmin, vmax)\n  print *, val\n\n  !case5\n  vmin = 100\n  vmax = 200\n  val = random_integer(vmin, vmax)\n  print *, val\nend program main",
            "result": [
                "10",
                "13",
                "1",
                "-626",
                "137"
            ]
        },
        "code": "        function random_integer(vmin, vmax) result(val)\n                integer, intent(in)  :: vmin, vmax\n                integer              :: val\n\n                call random_number(random_real)\n                val = vmin + floor( (vmax+1-vmin)*random_real )\n\n        end function random_integer\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named check_uuid that checks whether a given string is a valid UUID according to the RFC format. The function takes in one input argument of type character(len=*) and returns a logical value. The input argument represents the string to be checked. The function uses the features of Fortran to perform various verifications on the input string, including checking its length and verifying specific characters at certain positions. The function returns true if the string is a valid UUID and false otherwise.",
            "Write a Fortran function named check_uuid that checks whether a given string follows the format of a UUID (Universally Unique Identifier) as specified in the RFC. The function takes a single input parameter of type character(len=*), representing the string to be checked. The function returns a logical value indicating whether the string is a valid UUID or not.\n\nTo check the validity of the string, the function verifies the following conditions:\n- The length of the string must be 36 characters.\n- The characters at specific positions in the string must match certain patterns: 8 characters matching hexadecimal digits, followed by a hyphen, followed by 4 characters matching hexadecimal digits, followed by a hyphen, followed by 4 characters matching hexadecimal digits, followed by a hyphen, followed by 4 characters matching hexadecimal digits, followed by a hyphen, and finally, 12 characters matching hexadecimal digits.\n\nThe function performs the verification using the verify intrinsic function, which returns zero if the specified condition is met. If any of the conditions are not satisfied, the function returns false; otherwise, it returns true.\n\nPlease note that the function does not validate the uniqueness of the UUID, but only checks its format.",
            "Provide a Fortran function named check_uuid to validate a given string as a UUID (Universally Unique Identifier) based on the format specified in the RFC (Request for Comments). The function takes a single input argument of type character(len=*), representing the string to be checked. The function returns a logical value indicating whether the string is a valid UUID.\n\nTo check the validity of the UUID, the function verifies the following conditions:\n1. The length of the string must be 36 characters.\n2. The first 8 characters must be hexadecimal digits.\n3. The 9th character must be a hyphen ('-').\n4. The characters from 10th to 13th must be hexadecimal digits.\n5. The 14th character must be a hyphen ('-').\n6. The characters from 15th to 18th must be hexadecimal digits.\n7. The 19th character must be a hyphen ('-').\n8. The characters from 20th to 23rd must be hexadecimal digits.\n9. The 24th character must be a hyphen ('-').\n10. The characters from 25th to 36th must be hexadecimal digits.\n\nThe function returns a logical value, where 'True' indicates that the string is a valid UUID and 'False' indicates that it is not.\n\nPlease note that this function follows the guidelines specified in the RFC for validating UUIDs."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=36) :: chars\n  \n  !case1\n  chars = '123e4567-e89b-12d3-a456-426655440000'\n  print *, check_uuid(chars)\n\n  !case2\n  chars = '123e4567-e89b-12d3-a456-4266554400g'\n  print *, check_uuid(chars)\n\n  !case3\n  chars = '123e4567e89b12d3a4564266554400'\n  print *, check_uuid(chars)\n\n  !case4\n  chars = '123e4567-e89b-12d3a4564266554400'\n  print *, check_uuid(chars)\n\n  !case5\n  chars = '123e4567-e89b-12d3-a456-4266554400000'\n  print *, check_uuid(chars)\nend program main",
            "result": [
                "T",
                "F",
                "F",
                "F",
                "T"
            ]
        },
        "code": "function check_uuid(chars) result(lout)\n\n! return true if the string is permitted by the uuid bfn in rfc\n\ncharacter(len=*) :: chars\ncharacter(len=22), parameter :: hex = '0123456789abcdefabcdef'\nlogical :: lout\n\n   lout = (len_trim(chars) == 36)\n   if (lout) then\n       lout = lout.and.(verify(chars(1:8), hex) == 0)\n       lout = lout.and.(verify(chars(9:9), '-') == 0)\n       lout = lout.and.(verify(chars(10:13), hex) == 0)\n       lout = lout.and.(verify(chars(14:14), '-') == 0)\n       lout = lout.and.(verify(chars(15:18), hex) == 0)\n       lout = lout.and.(verify(chars(19:19), '-') == 0)\n       lout = lout.and.(verify(chars(20:23), hex) == 0)\n       lout = lout.and.(verify(chars(24:24), '-') == 0)\n       lout = lout.and.(verify(chars(25:36), hex) == 0)\n   endif\n\nend function check_uuid\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named rational_to_pow that calculates the power of each element in a rational number array. The function expects two input arguments, r1 which is an integer array of size 2, and ex which is an integer. The function returns an integer array of size 2. To calculate the power, each element in r1 is raised to the power of ex and stored in the corresponding index of the output array rational_to_pow.",
            "Create a Fortran function named \"rational_to_pow\" that takes two input arguments, \"r1\" (an array of integers) and \"ex\" (an integer). The function calculates the power of each element in the \"r1\" array to the exponent \"ex\" and stores the results in another array called \"rational_to_pow\". The \"rational_to_pow\" array has a dimension of 2, representing the numerator and denominator of a rational number. The function does not have any output parameters specified explicitly.",
            "Give me a Fortran function code named rational_to_pow that raises each element of a rational number to an exponent.The number of input arguments is 2, where the first argument is an array of integers with a dimension of 2, and the second argument is a single integer. The output is an array of integers with a dimension of 2."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer, dimension(2) :: r1, result\n  integer :: ex\n  \n  !case1\n  r1 = [2, 5]\n  ex = 3\n  result = rational_to_pow(r1, ex)\n  print *, result(1), result(2)\n  \n  !case2\n  r1 = [1, 10]\n  ex = 2\n  result = rational_to_pow(r1, ex)\n  print *, result(1), result(2)\n  \n  !case3\n  r1 = [3, 4]\n  ex = 0\n  result = rational_to_pow(r1, ex)\n  print *, result(1), result(2)\n  \n  !case4\n  r1 = [2, 3]\n  ex = 5\n  result = rational_to_pow(r1, ex)\n  print *, result(1), result(2)\n  \n  !case5\n  r1 = [0, 1]\n  ex = 10\n  result = rational_to_pow(r1, ex)\n  print *, result(1), result(2)\n  \nend program main",
            "result": [
                "8         125",
                "1         100",
                "1           1",
                "32         243",
                "0           1"
            ]
        },
        "code": "  function rational_to_pow(r1, ex)\n    integer,dimension(2) :: rational_to_pow, r1\n    integer :: ex\n    !(a1 * b2 + a2 * b1) / (b1 * b2)\n    rational_to_pow(1) = r1(1)**ex\n    rational_to_pow(2) = r1(2)**ex\n  end function\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named gcd to calculate the greatest common divisor (GCD) of two integers. The function takes two integer arguments, m and n, specified with the intent(in) attribute. The function returns a single integer value, gcd, which represents the greatest common divisor. \n\nTo compute the GCD, the function first assigns the absolute value of m to the variable ifirst and the absolute value of n to the variable gcd. Then, it checks if gcd is equal to zero. If so, it assigns the value of ifirst to gcd. Otherwise, the function enters a loop where it calculates the remainder (irest) of ifirst divided by gcd using the mod function. If irest is equal to zero, the loop is terminated using the exit statement. Otherwise, the values of gcd and ifirst are updated, and the loop continues. Finally, the function assigns the absolute value of gcd to gcd before returning the result.\n\nPlease note that the function does not include any input or output statements to read or print values. It solely focuses on the computation of the greatest common divisor.",
            "Provide a Fortran function named gcd to calculate the greatest common divisor (GCD) of two integers. The function requires two input parameters of type integer, namely m and n. The output parameter, gcd, is also of type integer. \n\nTo use the function, pass the values of m and n as input arguments. The function will then calculate the GCD using the Euclidean algorithm. The resulting GCD will be returned as the output of the function.\n\nPlease note that the function uses the \"intent(in)\" keyword to indicate that the input parameters m and n should not be modified within the function.",
            "Create a Fortran function named gcd that calculates the greatest common divisor (gcd) of two input integers. The function takes two integer arguments, m and n. The function returns a single integer, gcd."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: m, n\n  \n  !case1\n  m=10\n  n=15\n  print *, gcd(m, n)\n\n  !case2\n  m=25\n  n=35\n  print *, gcd(m, n)\n\n  !case3\n  m=24\n  n=36\n  print *, gcd(m, n)\n\n  !case4\n  m=99\n  n=121\n  print *, gcd(m, n)\n\n  !case5\n  m=56\n  n=84\n  print *, gcd(m, n)\n\nend program main",
            "result": [
                "5",
                "5",
                "12",
                "11",
                "28"
            ]
        },
        "code": "  function gcd(m,n)\n    integer,intent(in)  :: m, n\n    integer :: gcd,irest,ifirst\n    ifirst=abs(m)\n    gcd=abs(n)\n    if(gcd==0)then\n      gcd=ifirst\n    else\n      do\n        irest = mod(ifirst,gcd)\n        if(irest == 0)  exit\n        ifirst = gcd\n        gcd = irest\n      enddo\n      gcd= abs(gcd)\n    endif\n  end function\n"
    },
    {
        "instruction": [
            "Create a Fortran function called next_ccw that calculates the index of the next element in a circular sequence in a counter-clockwise direction. The function takes two input arguments, both of which are integers. The first argument, \"i,\" represents the current index, and the second argument, \"n,\" represents the total number of elements in the sequence. The function returns a single output value, \"next,\" which represents the index of the next element.",
            "Create a Fortran function called next_ccw that returns the index of the next element in a circular list, moving counterclockwise. \nThe function takes 2 integer input arguments: i (the current index) and n (the total number of elements in the list). \nThe function returns a single integer output argument, which is the index of the next element.",
            "Provide a function named next_ccw in Fortran that calculates the next counter-clockwise index in a circular sequence. The function takes two integer input arguments, i and n, representing the current index and the total number of elements in the sequence, respectively. It returns the next counter-clockwise index as an integer output argument named next."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: i, n, next\n  \n  !case1\n  i = 1\n  n = 3\n  print *, next_ccw(i, n)\n  \n  !case2\n  i = 2\n  n = 4\n  print *, next_ccw(i, n)\n\n  !case3\n  i = 5\n  n = 5\n  print *, next_ccw(i, n)\n  \n  !case4\n  i = 10\n  n = 7\n  print *, next_ccw(i, n)\n  \n  !case5\n  i = -3\n  n = 6\n  print *, next_ccw(i, n)\n  \nend program main",
            "result": [
                "2",
                "3",
                "1",
                "4",
                "4"
            ]
        },
        "code": "function next_ccw( i, n ) result(next)\ninteger :: i,n,next\nnext=mod(i,n)+1\nif( next.le.0 )then\n  next=next+n\nend if\nend function next_ccw\n"
    },
    {
        "instruction": [
            "Write a Fortran function code called \"tolower\" that takes a string as input and returns the string converted to lowercase. The function has one input parameter of type character and one output parameter of type character.",
            "Write a Fortran function called \"tolower\" to convert all uppercase characters in a given string to lowercase. The function takes in one input argument of type character and returns a result of type character. The function iterates over each character in the input string and checks if it falls within the ASCII range of uppercase letters (65-90). If it does, the function converts it to lowercase by adding 32 to its ASCII value. Otherwise, the character remains the same.",
            "Give me a Fortran function code named tolower to convert a given string to lowercase characters. The function takes a single input argument of type character (len=*), which represents the string to be converted. The output of the function is a character string of the same length as the input string. The function uses the Fortran features such as character manipulation and case selection to convert each character in the input string to lowercase if it is an uppercase letter."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=20) :: string\n  \n  !case1\n  string = \"Hello World\"\n  print *, tolower(string)\n  \n  !case2\n  string = \"FORTRAN\"\n  print *, tolower(string)\n  \n  !case3\n  string = \"12345\"\n  print *, tolower(string)\n  \n  !case4\n  string = \"abcXYZ\"\n  print *, tolower(string)\n  \n  !case5\n  string = \"Testing 123\"\n  print *, tolower(string)\n  \nend program main",
            "result": [
                "hello world",
                "fortran",
                "12345",
                "abcxyz",
                "testing 123"
            ]
        },
        "code": "function tolower(string) result (tolower_result)\n\n  implicit none\n  character (len=*), intent(in) :: string\n  character (len=len(string)) :: tolower_result\n  integer         :: i,ii\n\n  do i=1,len(string)\n    ii=iachar(string(i:i))\n    select case (ii)\n      case (65:90)\n        tolower_result(i:i)=achar(ii+32)\n      case default\n        tolower_result(i:i)=string(i:i)\n    end select\n  enddo\n\nend function tolower\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named toupper that converts a given string to uppercase characters. The function takes one input argument of type character and returns the modified string as the output argument. The input argument is specified with the keyword \"intent(in)\" and has the test data type of [character (len=*)]. The output argument is of type character and has the test data type of [character (len=len(string))]. The function uses a loop to iterate through each character of the input string and checks if the character is a lowercase letter. If it is, the character is converted to uppercase by subtracting 32 from its ASCII value. The modified string is then returned as the result of the function.",
            "Provide a Fortran function code named \"toupper\" that converts all lowercase characters in a given string to uppercase characters. The function takes one input parameter of type character (len=*) and returns the converted string as the output parameter, also of type character (len=*) .",
            "Create a Fortran function named \"toupper\" that takes a string as input and returns a new string with all characters converted to uppercase. The input parameter is a single string and the output parameter is also a string."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=100) :: string\n  \n  !case1\n  string = \"Hello World\"\n  print *, toupper(string)\n  \n  !case2\n  string = \"FoRtRaN iS aMaZiNg\"\n  print *, toupper(string)\n  \n  !case3\n  string = \"12345\"\n  print *, toupper(string)\n  \n  !case4\n  string = \"Testing 1 2 3\"\n  print *, toupper(string)\n  \n  !case5\n  string = \"abcdefghijklmnopqrstuvwxyz\"\n  print *, toupper(string)\n  \nend program main",
            "result": [
                "HELLO WORLD",
                "FORTRAN IS AMAZING",
                "12345",
                "TESTING 1 2 3",
                "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
            ]
        },
        "code": "function toupper(string) result (toupper_result)\n\n  implicit none\n  character (len=*), intent(in) :: string\n  character (len=len(string)) :: toupper_result\n  integer         :: i,ii\n\n  do i=1,len(string)\n    ii=iachar(string(i:i))\n    select case (ii)\n      case (97:122)\n        toupper_result(i:i)=achar(ii-32)\n      case default\n        toupper_result(i:i)=string(i:i)\n    end select\n  enddo\n\nend function toupper\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named fibonacci to calculate the Fibonacci number for a given input integer value. The number of input arguments is 1 and the data type is integer. The number of output arguments is 1 and the data type is also integer.",
            "Provide a Fortran function code named fibonacci that calculates the Fibonacci number for a given input integer. The function takes an integer input parameter named \"n\" and returns an integer output parameter named \"fib\". If the input value \"n\" is less than 2, the function returns the same value as \"n\". Otherwise, the function recursively calculates the Fibonacci number by adding the result of the function called with \"n-1\" and \"n-2\".",
            "Create a recursive Fortran function named fibonacci to calculate the Fibonacci number of a given integer. The function takes one input parameter of type integer (n) and returns one output parameter of type integer (fib). If n is less than 2, the function assigns n to fib. Otherwise, the function recursively calculates the Fibonacci number by adding the results of calling itself with n-1 and n-2 as arguments."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n\n\n  !case1\n  n = 0\n  print *, fibonacci(n)\n\n  !case2\n  n = 1\n  print *, fibonacci(n)\n\n  !case3\n  n = 3\n  print *, fibonacci(n)\n\n  !case4\n  n = 5\n  print *, fibonacci(n)\n\n  !case5\n  n = 10\n  print *, fibonacci(n)\nend program main",
            "result": [
                "0",
                "1",
                "2",
                "5",
                "55"
            ]
        },
        "code": "  recursive function fibonacci(n) result (fib)\n    integer, intent(in) :: n   !< if n <= 0 then 0 is assumed.\n    integer             :: fib !< fibonacci number\n    if (n < 2) then\n      fib = n\n    else\n      fib = fibonacci(n - 1) + fibonacci(n - 2)\n    endif\n  end function fibonacci\n"
    },
    {
        "instruction": [
            "Write a Fortran function named vtk_areatri that calculates the area of a triangle. The function takes in six input parameters of type real(8): ax, ay, bx, by, cx, cy. The function returns a single output parameter of type real(8) which represents the calculated area of the triangle.",
            "Provide a Fortran function code named vtk_areatri that calculates the area of a triangle given the coordinates of its vertices. The function takes in 6 inputs of type real(8) representing the x and y coordinates of three points (ax, ay, bx, by, cx, cy). The function returns a single output of type real(8) representing the area of the triangle.",
            "Write a Fortran function code named vtk_areatri that calculates the area of a triangle given the coordinates of its three vertices. The function takes in six floating-point arguments: ax, ay, bx, by, cx, cy (representing the x and y coordinates of the three vertices). The function returns a single floating-point value representing the area of the triangle."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real(8) :: ax, ay, bx, by, cx, cy\n  \n  !case1: Triangle with positive area\n  ax = 0.0d0\n  ay = 0.0d0\n  bx = 2.0d0\n  by = 0.0d0\n  cx = 0.0d0\n  cy = 2.0d0\n  print *, vtk_areatri(ax, ay, bx, by, cx, cy)\n\n  !case2: Triangle with negative area\n  ax = 0.0d0\n  ay = 0.0d0\n  bx = 2.0d0\n  by = 0.0d0\n  cx = 0.0d0\n  cy = -2.0d0\n  print *, vtk_areatri(ax, ay, bx, by, cx, cy)\n\n  !case3: Degenerate Triangle with zero area\n  ax = 0.0d0\n  ay = 0.0d0\n  bx = 0.0d0\n  by = 0.0d0\n  cx = 0.0d0\n  cy = 0.0d0\n  print *, vtk_areatri(ax, ay, bx, by, cx, cy)\n\n  !case4: Triangle with floating-point coordinates\n  ax = 1.1111d0\n  ay = 2.2222d0\n  bx = -3.3333d0\n  by = 4.4444d0\n  cx = -5.5555d0\n  cy = -6.6666d0\n  print *, vtk_areatri(ax, ay, bx, by, cx, cy)\n\n  !case5: Triangle with large coordinates\n  ax = 1.0d12\n  ay = 2.0d12\n  bx = 3.0d12\n  by = 4.0d12\n  cx = 5.0d12\n  cy = 6.0d12\n  print *, vtk_areatri(ax, ay, bx, by, cx, cy)\n  \nend program main",
            "result": [
                "2.0000000000000000",
                "2.0000000000000000",
                "0.0000000000000000",
                "27.159950619999996",
                "1073741824.0000000"
            ]
        },
        "code": "      function vtk_areatri(ax,ay,bx,by,cx,cy)\n      implicit none\n      real(8) :: vtk_areatri\n      real(8) :: ax,ay,bx,by,cx,cy\n      real(8) :: tmp\n\n      tmp=ax*(by-cy) + bx*(cy-ay) + cx*(ay-by)\n      vtk_areatri=abs(tmp)*0.5d0\n\n      return\n      end function vtk_areatri\n"
    },
    {
        "instruction": [
            "Write a Fortran function called \"gaussian_kernel\" that calculates the Gaussian kernel value between two arrays of double precision floating-point numbers. The function takes two input arrays, \"a\" and \"b\", both of which have an unspecified size. The function returns a single double precision value as the output. \n\nInside the function, the kernel value is initially set to 0.0. The variable \"sigma\" is assigned a value of 724.0. Then, a loop iterates over the elements of the input arrays, subtracting the corresponding values from each array and squaring the result. These squared differences are accumulated in the kernel value. Finally, the kernel value is computed as the exponential of -0.5 multiplied by the square root of the accumulated kernel value divided by the square of sigma.\n\nTo summarize, the \"gaussian_kernel\" function in Fortran takes two input arrays of double precision numbers and returns a single double precision value as the output. It calculates the Gaussian kernel value between the two input arrays using a loop and exponentiation.",
            "Write a Fortran function named \"gaussian_kernel\" that calculates the Gaussian kernel value between two arrays. The function takes two input arrays of double precision numbers and returns a single double precision value as the kernel result. The input arrays, \"a\" and \"b\", should have the same size. The function initializes the kernel value to zero and sets the value of sigma to 724.0. It then iterates over each element of the input arrays, subtracting the corresponding elements of \"a\" and \"b\" to calculate the temporary value. The kernel is updated by adding the square of the temporary value in each iteration. Finally, the function computes the exponent of the negative of half the square root of the kernel divided by sigma squared.",
            "Create a Fortran function named gaussian_kernel that calculates the Gaussian kernel between two arrays of double precision floating-point numbers. The function takes two arrays, a and b, as input parameters, both of which are of type double precision and have an arbitrary size. The function returns a single double precision value as the output parameter, which represents the calculated Gaussian kernel.\n\nInside the function, a loop is used to iterate over the elements of the input arrays. The difference between the corresponding elements of a and b is computed and stored in a temporary variable called temp. The kernel value is then updated by adding the square of temp to it.\n\nThe sigma value is set to 724.0d0, representing the standard deviation of the Gaussian distribution.\n\nFinally, the kernel value is calculated using the formula exp(-0.5d0 * sqrt(kernel) / (sigma*sigma)), where exp is the exponential function.\n\nNote: The intent(in) keyword indicates that the input arrays a and b are not modified within the function."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  double precision, allocatable :: a(:)\n  double precision, allocatable :: b(:)\n  \n  !case1\n  allocate(a(3))\n  allocate(b(3))\n  a = [1.0, 2.0, 3.0]\n  b = [4.0, 5.0, 6.0]\n  print *, gaussian_kernel(a, b)\n  deallocate(a)\n  deallocate(b)\n\n  !case2\n  allocate(a(4))\n  allocate(b(4))\n  a = [0.0, 0.0, 0.0, 0.0]\n  b = [1.0, 1.0, 1.0, 1.0]\n  print *, gaussian_kernel(a, b)\n  deallocate(a)\n  deallocate(b)\n\n  !case3\n  allocate(a(2))\n  allocate(b(2))\n  a = [0.5, 0.5]\n  b = [0.8, 0.8]\n  print *, gaussian_kernel(a, b)\n  deallocate(a)\n  deallocate(b)\n\n  !case4\n  allocate(a(5))\n  allocate(b(5))\n  a = [1.2, -2.3, 3.4, -4.5, 5.6]\n  b = [-1.2, 2.3, -3.4, 4.5, -5.6]\n  print *, gaussian_kernel(a, b)\n  deallocate(a)\n  deallocate(b)\n\n  !case5\n  allocate(a(2))\n  allocate(b(2))\n  a = [-0.5, 0.5]\n  b = [0.8, -0.8]\n  print *, gaussian_kernel(a, b)\n  deallocate(a)\n  deallocate(b)\nend program main",
            "result": [
                "0.99999504351635193",
                "0.99999809224564629",
                "0.99999959530386762",
                "0.99998405009905200",
                "0.99999824631799639"
            ]
        },
        "code": "function gaussian_kernel(a, b) result(kernel)\n\n    double precision, dimension(:), intent(in) :: a\n    double precision, dimension(:), intent(in) :: b\n\n    double precision :: kernel\n    integer :: i\n    double precision :: temp\n    double precision :: sigma\n   \n    kernel = 0.0d0 \n    sigma = 724.0d0\n\n    do i = 1, size(a)\n        temp = a(i) - b(i)\n        kernel = kernel + temp * temp\n    enddo\n\n    kernel = exp(-0.5d0 * sqrt(kernel) / (sigma*sigma))\n\nend function gaussian_kernel\n"
    },
    {
        "instruction": [
            "Write a Fortran function named laplace_kernel that calculates the kernel value based on the absolute difference between two arrays. The function takes two input arrays of double precision values and returns a single double precision value as the kernel. The input arrays are passed as arguments with the intent(in) attribute. The function uses the sum and exp functions available in Fortran to perform the calculations. The kernel value is computed by summing the absolute difference between corresponding elements of the input arrays, and then exponentiating the result using a constant value.",
            "Write a Fortran function named laplace_kernel that calculates the Laplace kernel value. The function takes two arrays of double precision floating-point numbers as input. The dimensions of the input arrays are not specified. The function returns a single double precision floating-point value as the result. The Laplace kernel value is computed by taking the absolute difference between corresponding elements of the input arrays, summing those differences, multiplying the sum by a constant (-0.00025118864315095795), and taking the exponential of the result.",
            "Give me a Fortran function code named laplace_kernel to compute the Laplace kernel between two arrays. The function takes two input arguments, both being arrays of double precision numbers. The size of the arrays can be of any length. The function returns a single double precision number as the result. The purpose of the code is to calculate the Laplace kernel, which involves subtracting corresponding elements of the two input arrays, taking the absolute value of the differences, summing them up, multiplying the sum by a constant (-0.00025118864315095795), and finally taking the exponential of the result."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n\n  real(kind=8), allocatable :: a(:), b(:)\n  \n  !case1\n  n = 3\n  allocate(a(n))\n  allocate(b(n))\n  a = [1.0, 2.0, 3.0]\n  b = [4.0, 5.0, 6.0]\n  print *, laplace_kernel(a, b)\n  deallocate(a, b)\n\n  !case2\n  n = 4\n  allocate(a(n))\n  allocate(b(n))\n  a = [1.0, -2.0, 3.0, -4.0]\n  b = [-4.0, 3.0, -2.0, 1.0]\n  print *, laplace_kernel(a, b)\n  deallocate(a, b)\n\n  !case3\n  n = 5\n  allocate(a(n))\n  allocate(b(n))\n  a = [0.0, 0.0, 0.0, 0.0, 0.0]\n  b = [1.0, 1.0, 1.0, 1.0, 1.0]\n  print *, laplace_kernel(a, b)\n  deallocate(a, b)\n\n  !case4\n  n = 2\n  allocate(a(n))\n  allocate(b(n))\n  a = [-1.0, -1.0]\n  b = [1.0, 1.0]\n  print *, laplace_kernel(a, b)\n  deallocate(a, b)\n\n  !case5\n  n = 3\n  allocate(a(n))\n  allocate(b(n))\n  a = [0.5, 1.5, 2.5]\n  b = [1.5, 0.5, 2.5]\n  print *, laplace_kernel(a, b)\n  deallocate(a, b)\nend program main\n    ",
            "result": [
                "0.99774185566432916",
                "0.99498882517847509",
                "0.99874484515084339",
                "0.99899575002425889",
                "0.99949774888403775"
            ]
        },
        "code": "function laplace_kernel(a, b) result(kernel)\n\n    double precision, dimension(:), intent(in) :: a\n    double precision, dimension(:), intent(in) :: b\n\n    double precision :: kernel\n\n    kernel = sum(abs(a(:) - b(:)))\n    kernel = exp(-0.00025118864315095795d0 * kernel)\n\nend function laplace_kernel\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named convert_lower_case that converts a single character to lowercase. The function takes one input argument of type character (len=1) and returns one output argument of the same type.",
            "Write a Fortran function code named convert_lower_case that converts a single character input_string to lower case. The function takes one input argument of type character (len=1) and returns one output argument of the same type.",
            "Give me a Fortran function code named convert_lower_case that converts a single character to lowercase. The code takes in a single input parameter of type character and returns an output parameter of type character. The number of input arguments is 1 and the test_data type is [character]. The number of output arguments is 1 and the test_data type is [character]."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=1) :: input_string, output_string\n  \n  !case1\n  input_string = 'A'\n  output_string = convert_lower_case(input_string)\n  print *, output_string\n\n  !case2\n  input_string = 'B'\n  output_string = convert_lower_case(input_string)\n  print *, output_string\n\n  !case3\n  input_string = 'Z'\n  output_string = convert_lower_case(input_string)\n  print *, output_string\n\n  !case4\n  input_string = 'a'\n  output_string = convert_lower_case(input_string)\n  print *, output_string\n\n  !case5\n  input_string = 'z'\n  output_string = convert_lower_case(input_string)\n  print *, output_string\nend program main",
            "result": [
                "A",
                "B",
                "Z",
                "a",
                "z"
            ]
        },
        "code": "          function convert_lower_case (input_string) result (output_string)\n!\n          character (len=1) :: input_string, output_string\n          integer :: collating_difference\n!\n          if (ichar(input_string) >= ichar('a') .and. ichar(input_string) <= ichar('z')) then\n              collating_difference = ichar(input_string) - ichar('a')\n              output_string = char(ichar('a') + collating_difference)\n          else\n              output_string = input_string\n          end if\n!\n          end function convert_lower_case\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named strcomp that compares two input strings and returns a logical result. The number of input arguments is 2 and their test_data type is [character(len=*), character(len=*)]. The number of output arguments is 1 and the test_data type is [logical]. The function iterates through the characters of the shorter string and checks if they are equal. If any character is not equal, the function returns false. Otherwise, it returns true.",
            "Provide a Fortran function named strcomp to compare two strings character by character. The function takes two input arguments of type character with variable length. The output of the function is a logical value indicating whether the strings are equal or not. The function uses a do loop to iterate through each character in the strings and checks if they are equal. If a mismatch is found, the function exits the loop and returns false. If the loop completes without finding any mismatches, the function returns true.",
            "Provide a Fortran function code named strcomp that compares two strings character by character. The function takes two input arguments, sa and sb, which are both of type character and have variable length. The function returns a logical value indicating whether the strings are equal or not. The output argument, r, is of type logical. Use a do loop to iterate through the characters of the shorter string, comparing each character. If a mismatch is found, set r to false and exit the loop."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=10) :: sa, sb\n  \n  !case1\n  sa = \"hello\"\n  sb = \"hello\"\n  print *, strcomp(sa, sb)\n\n  !case2\n  sa = \"abcdef\"\n  sb = \"abcdef\"\n  print *, strcomp(sa, sb)\n\n  !case3\n  sa = \"abcde\"\n  sb = \"abcd\"\n  print *, strcomp(sa, sb)\n\n  !case4\n  sa = \"123456\"\n  sb = \"654321\"\n  print *, strcomp(sa, sb)\n\n  !case5\n  sa = \"abcABC123\"\n  sb = \"abcABC123\"\n  print *, strcomp(sa, sb)\n\nend program main",
            "result": [
                "T",
                "T",
                "F",
                "F",
                "T"
            ]
        },
        "code": "function strcomp(sa, sb) result(r)\n\n    character(len=*), intent(in) :: sa\n    character(len=*), intent(in) :: sb\n\n    logical :: r\n    integer :: i\n\n    r = .true.\n    do i = 1,merge(len(sa),len(sb),len(sa) < len(sb))     \n        if (sa(i:i) /= sb(i:i)) then\n            r = .false.\n            exit\n        end if\n    end do\n\nend function\n"
    },
    {
        "instruction": [
            "Write a Fortran function named factorial that calculates the factorial of a given integer number. The function takes one input argument, which is an integer number. The output of the function is also an integer, representing the factorial of the input number.",
            "Provide a Fortran function code named factorial to calculate the factorial of a given number. The function takes in a single input argument of type integer to calculate the factorial of. The output is a single integer value representing the factorial.",
            "Please provide a Fortran function named factorial that calculates the factorial of an input integer number. The function takes one input argument of type integer and returns the factorial as an output argument of type integer."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: number\n  \n  !case1\n  number = 5\n  print *, factorial(number)\n  \n  !case2\n  number = 10\n  print *, factorial(number)\n  \n  !case3\n  number = 0\n  print *, factorial(number)\n  \n  !case4\n  number = 3\n  print *, factorial(number)\n  \n  !case5\n  number = 7\n  print *, factorial(number)\n  \nend program main",
            "result": [
                "120",
                "3628800",
                "1",
                "6",
                "5040"
            ]
        },
        "code": "  function factorial(number) result(fact)\n\n    !> number to calculate the factorial of\n    integer, intent(in) :: number\n\n    !> factorial\n    integer :: fact\n\n    integer :: ii\n\n    fact = 1\n    do ii = 2, number\n      fact = fact * ii\n    end do\n\n  end function factorial\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named normainf to calculate the infinity norm of a given vector. The function takes in one input argument of type real array and returns one output argument of type real.",
            "Write a Fortran function named \"normainf\" that calculates the infinity norm of a given vector. The function takes in one input argument of type \"real, dimension(:), allocatable\" and returns one output argument of type \"real\".",
            "Write a Fortran function named \"normainf\" that calculates the infinity norm of a given vector. The function takes in a one-dimensional, allocatable array of real numbers as input and returns a single real number as the result. The input array is denoted as \"vec\", and the output value is denoted as \"y\". The infinity norm of a vector is the maximum absolute value of its elements."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real, allocatable :: vec(:)\n  \n  !case1\n  allocate(vec(5))\n  vec = [1.0, -2.0, 3.0, -4.0, 5.0]\n  print *, normainf(vec)\n  deallocate(vec)\n\n  !case2\n  allocate(vec(4))\n  vec = [0.0, 0.0, 0.0, 0.0]\n  print *, normainf(vec)\n  deallocate(vec)\n\n  !case3\n  allocate(vec(3))\n  vec = [-1.5, 2.5, -0.5]\n  print *, normainf(vec)\n  deallocate(vec)\n\n  !case4\n  allocate(vec(6))\n  vec = [10.0, -20.0, 30.0, -40.0, 50.0, -60.0]\n  print *, normainf(vec)\n  deallocate(vec)\n\n  !case5\n  allocate(vec(7))\n  vec = [-1.0, -2.0, -3.0, -4.0, -5.0, -6.0, -7.0]\n  print *, normainf(vec)\n  deallocate(vec)\n\nend program main",
            "result": [
                "5.00000000",
                "0.00000000",
                "2.50000000",
                "60.0000000",
                "7.00000000"
            ]
        },
        "code": "        function normainf(vec) result(y)\n    \n            implicit none\n    \n            \n            real, dimension(:), allocatable :: vec\n            real :: y\n           \n            \n            y = maxval(abs(vec))\n    \n        end function normainf \n"
    },
    {
        "instruction": [
            "Write a Fortran function named \"f\" that calculates the value of a mathematical function. This function takes one input argument of type \"real\" and returns one output argument of type \"real\". The function calculates the exponential of the negative square of the input argument.",
            "Write a Fortran function named f that calculates the value of the exponential function e^(-x^2). The function takes in one input argument of type real named x. The result of the computation is stored in a variable of type real named f.",
            "Create a Fortran function named \"f\" to calculate the exponential function of negative x squared. The function should take one input argument of type real named \"x\" and return one output argument of type real named \"f\"."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real :: x\n  \n  !case1\n  x = 0.0\n  print *, f(x)\n\n  !case2\n  x = 1.0\n  print *, f(x)\n\n  !case3\n  x = -1.0\n  print *, f(x)\n\n  !case4\n  x = 2.5\n  print *, f(x)\n\n  !case5\n  x = -3.2\n  print *, f(x)\n  \nend program main",
            "result": [
                "1.00000000",
                "0.367879450",
                "0.367879450",
                "1.93045416E-03",
                "3.57128229E-05"
            ]
        },
        "code": "function f(x)\n  implicit none\n  real::x, f\n  f=exp(-x**2)\nend function f\n"
    },
    {
        "instruction": [
            "Please provide a Fortran function named random_integer that generates a random integer within a specified range. The function takes two input arguments, nmin and nmax, representing the minimum and maximum values of the range. The function returns a single output value of type integer.",
            "Write a Fortran function named random_integer that generates a random integer within a given range. The function takes two input arguments of integer type, nmin and nmax, which represent the minimum and maximum values of the range. The function returns a single integer as the output.",
            "Provide a Fortran function named random_integer that generates a random integer within a specified range. The number of input parameters is 2, both of which are integers representing the minimum and maximum values of the range. The number of output parameters is 1, which is an integer representing the randomly generated integer."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: nmin, nmax\n\n  !case1\n  nmin = 1\n  nmax = 10\n  print *, random_integer(nmin, nmax)\n\n  !case2\n  nmin = -5\n  nmax = 5\n  print *, random_integer(nmin, nmax)\n\n  !case3\n  nmin = 100\n  nmax = 1000\n  print *, random_integer(nmin, nmax)\n\n  !case4\n  nmin = -100\n  nmax = -50\n  print *, random_integer(nmin, nmax)\n\n  !case5\n  nmin = 0\n  nmax = 1\n  print *, random_integer(nmin, nmax)\nend program main",
            "result": [
                "10",
                "1",
                "970",
                "-62",
                "0"
            ]
        },
        "code": "function random_integer(nmin,nmax)\n!==============================================================================!\n!randomly generate an integer in the range nmin-nmax\n!==============================================================================!\n!nmin           ==>minimum index value\n!nmax           ==>maximum index value\n!a              ==>uniform pseudo-random number\n!==============================================================================!\nimplicit none\ninteger::nmin,nmax,random_integer\ndouble precision::a\n!==============================================================================!\ncall random_number(a)\nrandom_integer=floor(a*(nmax-nmin+1))+nmin\nend function random_integer\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named elapsed_time to calculate the elapsed time in seconds. The function takes one input argument of type integer (t0) to represent the starting time. The output of the function is a real number (elapsed_time) representing the time difference in seconds. \n\nTo use the function, call it with the starting time (t0) as an argument. The function uses the system clock function to obtain the current time (t), the clock count rate (count_rate), and the maximum clock count (count_max). \n\nIf the current time is greater than or equal to the starting time, the function computes the elapsed time as the difference between the current time and the starting time divided by the clock count rate. \n\nIf the current time is less than the starting time, the function handles the rollover of the clock count by subtracting the starting time from the maximum count and adding the result to the current time. This difference is then divided by the clock count rate to obtain the elapsed time.",
            "Provide a Fortran function code named elapsed_time that calculates the time elapsed since a given starting point. The function takes an integer input parameter named t0 and returns a real output parameter named elapsed_time. The elapsed time is calculated using the system_clock function, which provides the current time in clock ticks. The function also uses the count_rate and count_max variables to determine the maximum number of clock ticks. The function checks if the current time is greater than or equal to the starting time and calculates the elapsed time accordingly. If the current time is less than the starting time, the function accounts for the wrapping of clock ticks.",
            "Provide a Fortran function named elapsed_time to calculate the elapsed time in seconds. The function takes one input argument of type integer named t0. The function returns a value of type real representing the elapsed time."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: t0\n  \n  !case1\n  t0 = 100\n  print *, elapsed_time(t0)\n  \n  !case2\n  t0 = 500\n  print *, elapsed_time(t0)\n  \n  !case3\n  t0 = 1000\n  print *, elapsed_time(t0)\n  \n  !case4\n  t0 = 2000\n  print *, elapsed_time(t0)\n  \n  !case5\n  t0 = 3000\n  print *, elapsed_time(t0)\n  \nend program main",
            "result": [
                "1811571.12",
                "1811570.75",
                "1811570.12",
                "1811569.12",
                "1811568.25"
            ]
        },
        "code": "function elapsed_time(t0)\n!\nimplicit none\n!\nreal                                    :: elapsed_time\ninteger, intent(in)                     :: t0\ninteger                                 :: t, count_rate, count_max\n!\ncall system_clock(t, count_rate, count_max)\nif (t>=t0) elapsed_time=real(t-t0)/real(count_rate)\nif (t<t0) elapsed_time=(real(count_max)-real(t0-t))/real(count_rate)\nend function elapsed_time\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named integer_to_string that converts an integer number to a string. The function takes an integer input argument and returns a string output. The input argument is specified with the \"intent(in)\" attribute and has the data type \"integer\". The output argument is a character string with variable length, allocated using the \"allocatable\" attribute, and has the data type \"character(len=:)\". The function uses the \"write\" statement to convert the integer number to a string and assigns it to the \"temp\" variable. Then, the function trims the string and assigns it to the \"string\" variable.",
            "Write a Fortran function code named integer_to_string that converts an integer into a string. The function takes one input argument, which is an integer, and returns one output argument, which is a string.",
            "Give me a Fortran function code named integer_to_string that converts an integer into a string representation. The function takes 1 input argument of type integer and returns a string representation of the input number."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: number\n  character(len=:), allocatable :: string\n  \n  !case1\n  number = 0\n  string = integer_to_string(number)\n  print *, string\n\n  !case2\n  number = 12345\n  string = integer_to_string(number)\n  print *, string\n\n  !case3\n  number = -987654321\n  string = integer_to_string(number)\n  print *, string\n\n  !case4\n  number = 999999999\n  string = integer_to_string(number)\n  print *, string\n\n  !case5\n  number = -1234567890\n  string = integer_to_string(number)\n  print *, string\nend program main",
            "result": [
                "0",
                "12345",
                "-987654321",
                "999999999",
                "-1234567890"
            ]
        },
        "code": "    pure function integer_to_string(number) result(string)\n        integer, intent(in) :: number\n        character(len=:), allocatable :: string\n\n        character(len=11) :: temp\n\n        write(temp, '(i0)') number\n        string = trim(temp)\n    end function\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named contract_i_i that calculates the contraction of two first-rank tensors. The function takes two input parameters, both of type real and dimension(3), and returns a single output parameter of type real. The input tensors are named 'a' and 'b', respectively. To calculate the contraction, the function uses the dot product of the two tensors, which sums the products of corresponding elements.",
            "Write a Fortran function code called contract_i_i that calculates the contraction of two first-rank tensors. The function takes two input arguments, both of type real and with a dimension of 3, and returns a single output argument of type real. The function computes the contraction by summing the products of corresponding elements of the two input tensors.",
            "Create a Fortran function named contract_i_i that computes the contraction of two first-rank tensors. The function takes two input parameters, both arrays of real numbers with a dimension of 3. The output parameter is a single real number. Use the dot_product function to sum the product of corresponding elements in the input arrays."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real :: c\n  real, dimension(3) :: a, b\n  \n  !case1\n  a = [1.0, 2.0, 3.0]\n  b = [4.0, 5.0, 6.0]\n  c = contract_i_i(a, b)\n  print *, c\n\n  !case2\n  a = [-1.0, 0.0, 1.0]\n  b = [1.0, 2.0, 3.0]\n  c = contract_i_i(a, b)\n  print *, c\n\n  !case3\n  a = [0.5, -0.5, 0.5]\n  b = [0.2, 0.3, -0.4]\n  c = contract_i_i(a, b)\n  print *, c\n\n  !case4\n  a = [0.0, 0.0, 0.0]\n  b = [1.0, 2.0, 3.0]\n  c = contract_i_i(a, b)\n  print *, c\n\n  !case5\n  a = [1.0, 2.0, 3.0]\n  b = [-1.0, -2.0, -3.0]\n  c = contract_i_i(a, b)\n  print *, c\nend program main",
            "result": [
                "32.0000000",
                "2.00000000",
                "-0.250000000",
                "0.00000000",
                "-14.0000000"
            ]
        },
        "code": "  function contract_i_i ( a, b ) result (c)\n    implicit none\n    real                           :: c ! returns a zero-rank contraction\n    real, dimension(3), intent(in) :: a ! of a first-rank tensor\n    real, dimension(3), intent(in) :: b ! with a first-rank tensor\n\n    ! sum over index i, equivalent to built-in dot_product\n    c = dot_product ( a, b )\n\n  end function contract_i_i\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named contract_ij_ij that computes the contraction of two second-rank tensors. The function takes two input arguments, both of type real and with dimensions 3x3. The output argument, also of type real, represents the result of the contraction. \n\nTo compute the contraction, the function sums the element-wise product of the two input tensors. The resulting contraction value is stored in the output argument \"c\".",
            "Provide a Fortran function named contract_ij_ij that calculates the contraction of two second-rank tensors. The function takes two input arguments, both of type real and dimension (3,3), representing the two tensors to be contracted. It returns a single output argument, c, of type real, representing the result of the contraction. Inside the function, the sum of the element-wise multiplication of the two tensors is calculated and stored in c.",
            "Write a Fortran function code named contract_ij_ij that calculates the contraction of two second-rank tensors. The function takes two input arguments, both of type real and with dimensions (3,3), and returns a single output argument of type real. The function performs a sum over the indices i and j to compute the contraction and stores the result in the variable c."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real :: c\n  real, dimension(3,3) :: a, b\n  \n  !case1\n  a = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0], [3,3])\n  b = reshape([9.0, 8.0, 7.0, 6.0, 5.0, 4.0, 3.0, 2.0, 1.0], [3,3])\n  c = contract_ij_ij(a, b)\n  print *, c\n\n  !case2\n  a = reshape([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0], [3,3])\n  b = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0], [3,3])\n  c = contract_ij_ij(a, b)\n  print *, c\n\n  !case3\n  a = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0], [3,3])\n  b = reshape([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [3,3])\n  c = contract_ij_ij(a, b)\n  print *, c\n\n  !case4\n  a = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0], [3,3])\n  b = reshape([9.0, 8.0, 7.0, 6.0, 5.0, 4.0, 3.0, 2.0, 10.0], [3,3])\n  c = contract_ij_ij(a, b)\n  print *, c\n\n  !case5\n  a = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0], [3,3])\n  b = reshape([2.0, 0.0, 0.0, 0.0, 2.0, 0.0, 0.0, 0.0, 2.0], [3,3])\n  c = contract_ij_ij(a, b)\n  print *, c\nend program main",
            "result": [
                "165.000000",
                "15.0000000",
                "0.00000000",
                "246.000000",
                "30.0000000"
            ]
        },
        "code": "  function contract_ij_ij ( a, b ) result ( c )\n    implicit none\n    real                              :: c ! returns a zero-rank contraction\n    real, dimension(3,3), intent(in)  :: a ! of a second-rank tensor\n    real, dimension(3,3), intent(in)  :: b ! with another second-rank tensor\n\n    ! sum over indices i, j\n    c = sum ( a * b )\n\n  end function contract_ij_ij\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named contract_ik_jk that calculates the contraction of two second-rank tensors. The function takes two input parameters, both of type real and dimension 3x3, representing the two tensors to be contracted. The function returns a single output parameter, also of type real and dimension 3x3, which represents the contracted tensor. \n\nTo perform the contraction, the function iterates over the indices i and j, and computes the sum of the products of corresponding elements from the two input tensors. The result is stored in the corresponding element of the output tensor.\n\nInstructions:\n1. Define a function with the name \"contract_ik_jk\".\n2. Specify that it takes two input parameters, \"a\" and \"b\", both of type real and dimension 3x3.\n3. Specify that it returns a single output parameter \"c\", of type real and dimension 3x3.\n4. Inside the function, declare the variables i and j.\n5. Use nested do-loops to iterate over the indices i and j from 1 to 3.\n6. Inside the nested loops, compute the sum of the products of the corresponding elements from the input tensors \"a\" and \"b\" for each i and j.\n7. Assign the result to the corresponding element of the output tensor \"c\".\n8. End the function.",
            "Provide a Fortran function code named contract_ik_jk that calculates the contraction of two second-rank tensors. The function takes two 3x3 real arrays, a and b, as input parameters. The function returns a 3x3 real array, c, as the output parameter. The function loops over the indices i and j and computes the contraction of a(i,:) with b(j,:) by summing the element-wise multiplication.",
            "Give me a Fortran function code named contract_ik_jk to compute the contraction of two second-rank tensors. The function takes two input arguments, both of type real and dimension 3x3, representing the two tensors to be contracted. The function returns a 3x3 matrix, also of type real, which represents the result of the contraction."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real, dimension(3,3) :: a, b, c\n\n  !case1\n  a = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0], [3,3])\n  b = reshape([9.0, 8.0, 7.0, 6.0, 5.0, 4.0, 3.0, 2.0, 1.0], [3,3])\n  c = contract_ik_jk(a, b)\n  print *, c\n\n  !case2\n  a = reshape([0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [3,3])\n  b = reshape([1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [3,3])\n  c = contract_ik_jk(a, b)\n  print *, c\n\n  !case3\n  a = reshape([-1.0, 2.0, -3.0, 4.0, -5.0, 6.0, -7.0, 8.0, -9.0], [3,3])\n  b = reshape([9.0, -8.0, 7.0, -6.0, 5.0, -4.0, 3.0, -2.0, 1.0], [3,3])\n  c = contract_ik_jk(a, b)\n  print *, c\n\n  !case4\n  a = reshape([1.0, 0.0, 0.0, 0.0, 2.0, 0.0, 0.0, 0.0, 3.0], [3,3])\n  b = reshape([2.0, 0.0, 0.0, 0.0, 3.0, 0.0, 0.0, 0.0, 4.0], [3,3])\n  c = contract_ik_jk(a, b)\n  print *, c\n\n  !case5\n  a = reshape([1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0], [3,3])\n  b = reshape([0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0], [3,3])\n  c = contract_ik_jk(a, b)\n  print *, c\nend program main",
            "result": [
                "54.0000000       72.0000000       90.0000000       42.0000000       57.0000000       72.0000000       30.0000000       42.0000000       54.0000000",
                "0.500000000       0.00000000       0.00000000       0.00000000       0.00000000       0.00000000       0.00000000       0.00000000       0.00000000",
                "-54.0000000       72.0000000      -90.0000000       42.0000000      -57.0000000       72.0000000      -30.0000000       42.0000000      -54.0000000",
                "2.00000000       0.00000000       0.00000000       0.00000000       6.00000000       0.00000000       0.00000000       0.00000000       12.0000000",
                "0.00000000       0.00000000       1.00000000       1.00000000       0.00000000       1.00000000       2.00000000       1.00000000       0.00000000"
            ]
        },
        "code": "  function contract_ik_jk ( a, b ) result ( c )\n    implicit none\n    real, dimension(3,3)             :: c ! returns a second-rank contraction\n    real, dimension(3,3), intent(in) :: a ! of a second-rank tensor\n    real, dimension(3,3), intent(in) :: b ! with another second-rank tensor\n    integer :: i, j\n\n    ! free indices i, j, sum over index k (if b symmetric, would be equivalent to built-in matmal)\n    do i = 1, 3\n       do j = 1, 3\n          c(i,j) = sum ( a(i,:) * b(j,:) )\n       end do\n    end do\n\n  end function contract_ik_jk\n"
    },
    {
        "instruction": [
            "Create a Fortran function called contract_ijk_k that performs a contraction operation on a third-rank tensor and a first-rank tensor. The function takes two input arguments: a 3-dimensional array of real numbers (a) and a 1-dimensional array of real numbers (b). The function returns a 2-dimensional array of real numbers (c). The purpose of the function is to compute the contraction of indices i, j, and k by summing the product of the elements in the i-th and j-th rows of a with the elements in the k-th column of b. The resulting values are stored in the corresponding positions of the output array c.",
            "Write a Fortran function named \"contract_ijk_k\" that calculates the contraction of a third-rank tensor and a first-rank tensor to produce a second-rank tensor. The function takes two input arguments: a three-dimensional array \"a\" of real numbers representing the third-rank tensor and a one-dimensional array \"b\" of real numbers representing the first-rank tensor. The function returns a two-dimensional array \"c\" of real numbers representing the second-rank tensor. The function performs a contraction by summing over the index \"k\" while iterating over the indices \"i\" and \"j\" of the arrays \"a\" and \"b\" respectively. The resulting contraction values are stored in the array \"c\".",
            "Create a Fortran function named \"contract_ijk_k\" that performs a second-rank contraction of a third-rank tensor and a first-rank tensor. The function takes two input arguments: a three-dimensional array of real numbers \"a\" and a one-dimensional array of real numbers \"b\". The output is a two-dimensional array of real numbers \"c\". The function calculates the contraction by summing the product of the elements of \"a\" with the corresponding elements of \"b\" along the third index. The indices \"i\" and \"j\" are looped over to perform the contraction."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real, dimension(3,3) :: a\n  real, dimension(3) :: b\n  real, dimension(3,3) :: c\n\n  !case1\n  a = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0], [3,3])\n  b = [1.0, 2.0, 3.0]\n  c = contract_ijk_k(a, b)\n  print *, c\n\n  !case2\n  a = reshape([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [3,3])\n  b = [1.0, 2.0, 3.0]\n  c = contract_ijk_k(a, b)\n  print *, c\n\n  !case3\n  a = reshape([-1.0, -2.0, -3.0, 4.0, 5.0, 6.0, -7.0, -8.0, -9.0], [3,3])\n  b = [-2.0, 2.0, -2.0]\n  c = contract_ijk_k(a, b)\n  print *, c\n\n  !case4\n  a = reshape([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0], [3,3])\n  b = [1.0, 1.0, 1.0]\n  c = contract_ijk_k(a, b)\n  print *, c\n\n  !case5\n  a = reshape([4.5, 2.3, 1.2, -3.6, 5.4, -2.1, 0.9, -1.8, 3.3], [3,3])\n  b = [0.5, -0.2, 0.8]\n  c = contract_ijk_k(a, b)\n  print *, c\nend program main",
            "result": [
                "1.00000000       2.00000000       3.00000000       4.00000000       5.00000000       6.00000000       7.00000000       8.00000000       9.00000000",
                "9.18298910E-41   4.20389539E-45   0.00000000       2.77699549E-24   2.50833116E-29   1.18131815E-38   2.52233724E-44   2.77704124E-24   4.16556187E-24",
                "2.00000000       4.00000000       6.00000000      -8.00000000      -10.0000000      -12.0000000       14.0000000       16.0000000       18.0000000",
                "1.00000000       1.40129846E-45   0.00000000       1.38849775E-24   1.00000000       5.89884576E-39   8.40779079E-45   1.38852062E-24   1.00000000",
                "2.25000000       1.14999998      0.600000024      -1.79999995       2.70000005      -1.04999995      0.449999988     -0.899999976       1.64999998"
            ]
        },
        "code": "  function contract_ijk_k ( a, b ) result ( c )\n    implicit none\n    real, dimension(3,3)                :: c ! returns a second-rank contraction of \n    real, dimension(3,3,3), intent(in)  :: a ! a third-rank tensor\n    real, dimension(3),     intent(in)  :: b ! and a first-rank tensor\n\n    integer :: i, j\n\n    ! free indices i, j, sum over index k.\n    do i = 1, 3\n       do j = 1, 3\n          c(i,j) = sum ( a(i,j,:) * b(:) )\n       end do\n    end do\n\n  end function contract_ijk_k\n"
    },
    {
        "instruction": [
            "Please provide a Fortran function code named \"skew\" that calculates the skew-symmetric tensor resulting from the cross product of a second-rank tensor. The function takes a 3x3 matrix of real numbers as an input and returns a 1D array of real numbers as an output.",
            "Provide a Fortran function code named skew that calculates the skew-symmetric tensor from a given second-rank tensor. The function takes a 3x3 array of real numbers as input and returns a 1D array of real numbers as output. The number of input arguments is 1 with the type [real, dimension(3,3)], and the number of output arguments is 1 with the type [real, dimension(3)].",
            "Give me a Fortran function code named skew that computes the skew-symmetric tensor from a given second-rank tensor. The function takes a single input argument of type real, 2-dimensional array with dimensions (3,3) and returns a first-rank tensor as the output. The output tensor is represented by a real, 1-dimensional array with dimension 3."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real, dimension(3,3) :: a\n  real, dimension(3) :: b\n  \n  !case1\n  a = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0], [3,3])\n  b = skew(a)\n  print *, b\n\n  !case2\n  a = reshape([-1.0, 2.0, -3.0, 4.0, -5.0, 6.0, -7.0, 8.0, -9.0], [3,3])\n  b = skew(a)\n  print *, b\n\n  !case3\n  a = reshape([0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0], [3,3])\n  b = skew(a)\n  print *, b\n\n  !case4\n  a = reshape([1.0, 0.0, 0.0, 0.0, 2.0, 0.0, 0.0, 0.0, 3.0], [3,3])\n  b = skew(a)\n  print *, b\n\n  !case5\n  a = reshape([-1.0, -2.0, -3.0, -4.0, -5.0, -6.0, -7.0, -8.0, -9.0], [3,3])\n  b = skew(a)\n  print *, b\nend program main",
            "result": [
                "2.00000000      -4.00000000       2.00000000",
                "2.00000000       4.00000000       2.00000000",
                "1.00000000      -2.00000000       1.00000000",
                "0.00000000       0.00000000       0.00000000",
                "-2.00000000       4.00000000      -2.00000000"
            ]
        },
        "code": "  function skew ( a ) result ( b )\n\n    implicit none\n    real, dimension(3)   :: b ! returns a first-rank tensor by contracting the levi-civita symbol with\n    real, dimension(3,3) :: a ! a second-rank tensor\n\n    b(1) = a(2,3) - a(3,2)\n    b(2) = a(3,1) - a(1,3)\n    b(3) = a(1,2) - a(2,1)\n\n  end function skew\n"
    },
    {
        "instruction": [
            "Write a Fortran function code named \"strfromlogical\" to convert a logical value into a corresponding string value. The function takes one input argument of type \"logical\" and returns one output argument of type \"character(len=5)\".",
            "Write a Fortran function code called \"strfromlogical\" that converts a logical value into a string representation. The function takes one input argument of type logical and returns a string of length 5. The name of the input argument is \"l\" and it is passed by value. The name of the output argument is \"str\" and it is of type character. \n\nTo implement the code, use an if-else statement to check the value of \"l\". If \"l\" is true, assign the string \"true\" to \"str\". If \"l\" is false, assign the string \"false\" to \"str\". Return the resulting string \"str\" as the output of the function.",
            "Provide a Fortran function code named `strfromlogical` that converts a logical value to a corresponding string value. The function takes one input argument of type `logical` and returns a string value of length 5. The name of the function is `strfromlogical`."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  logical :: l\n  \n  !case1\n  l = .true.\n  print *, strfromlogical(l)\n\n  !case2\n  l = .false.\n  print *, strfromlogical(l)\n\n  !case3\n  l = .not. .true.\n  print *, strfromlogical(l)\n\n  !case4\n  l = .not. .false.\n  print *, strfromlogical(l)\n\n  !case5\n  l = 3.0 < 5.0\n  print *, strfromlogical(l)\nend program main",
            "result": [
                "true",
                "false",
                "false",
                "true",
                "true"
            ]
        },
        "code": "    function strfromlogical(l) result(str)\n        logical, intent(in) :: l            !! the logical to convert to a string\n        character(len=5) :: str             !! the string to return\n        if (l) then\n            str = \"true\"\n        else\n            str = \"false\"\n        end if\n    end function\n"
    },
    {
        "instruction": [
            "Create a Fortran function named dist that calculates the Euclidean distance between two points in a two-dimensional space. The function takes two input arguments, pt1 and pt2, both of which are arrays of two real numbers. The function returns a single real number, dist, which represents the computed distance.",
            "Write a Fortran function named \"dist\" that calculates the Euclidean distance between two points in a two-dimensional space. The function takes two input arguments, pt1 and pt2, both of type real and dimension 2. The function returns the distance as a real value.",
            "Write a Fortran function named \"dist\" that calculates the Euclidean distance between two points in a 2D space. The function takes two input arguments of type \"real\" and dimension 2, representing the coordinates of the two points. The function returns a single output argument of type \"real\", representing the calculated distance."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real, dimension(2) :: pt1, pt2\n  \n  !case1\n  pt1 = [0.0, 0.0]\n  pt2 = [3.0, 4.0]\n  print *, dist(pt1, pt2)\n\n  !case2\n  pt1 = [-2.5, 1.5]\n  pt2 = [4.5, -3.5]\n  print *, dist(pt1, pt2)\n\n  !case3\n  pt1 = [2.0, -1.0]\n  pt2 = [-2.0, 1.0]\n  print *, dist(pt1, pt2)\n\n  !case4\n  pt1 = [0.0, 0.0]\n  pt2 = [0.0, 0.0]\n  print *, dist(pt1, pt2)\n\n  !case5\n  pt1 = [10.0, 10.0]\n  pt2 = [20.0, 20.0]\n  print *, dist(pt1, pt2)\nend program main\n    ",
            "result": [
                "5.00000000",
                "8.60232544",
                "4.47213602",
                "0.00000000",
                "14.1421356"
            ]
        },
        "code": "function dist(pt1,pt2)\n    implicit none\n    real::dist\n    real, dimension(2) :: pt1,pt2\n    dist = sqrt((pt1(1)-pt2(1))**2+(pt1(2)-pt2(2))**2)\nend function dist\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named icsrcaseb that calculates a value based on the input arguments ssh and xk2. The function takes two double precision input parameters and returns a double precision result. The function computes the value of icsrcaseb using a mathematical formula involving calculations with ssh and xk2. The computed value is then returned as the result of the function.",
            "Provide a Fortran function named icsrcaseb that calculates a value based on the input parameters ssh and xk2. The function takes in two double precision floating-point numbers and returns a double precision result. \n\nTo compute the result, the function performs a series of mathematical operations involving the input parameters. It calculates the value of aa as the square root of (64.0 + 144.0 * ssh^2) and uuh as ((aa + 12 * ssh)^(1/3) - (aa - 12 * ssh)^(1/3)). Finally, it computes the output value of icsrcaseb as xk2 multiplied by (-4 * uuh * (uuh^2 + 8) / ((uuh^2 + 4.0) * (uuh^2 + 12.0))).\n\nThis function can be used to calculate a specific value based on the input parameters ssh and xk2.",
            "Provide a Fortran function named icsrcaseb that calculates a value based on two input arguments. The input arguments are of type double precision and named ssh and xk2. The function returns a value of type double precision.\nThe function computes the value of icsrcaseb using the following formula:\n- Calculate the value of aa by taking the square root of (64.0 + 144.0 * ssh^2).\n- Calculate the value of uuh using the formula (aa + 12 * ssh)^(1/3) - (aa - 12 * ssh)^(1/3).\n- Compute the final value of icsrcaseb using the formula xk2 * (-4 * uuh * (uuh^2 + 8) / ((uuh^2 + 4.0) * (uuh^2 + 12.0))).\nMake sure to declare all variables and specify their data types at the beginning of the function using the \"double precision\" keyword."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  double precision :: ssh, xk2\n  \n  !case1\n  ssh = 2.0\n  xk2 = 0.5\n  print *, icsrcaseb(ssh, xk2)\n\n  !case2\n  ssh = -1.5\n  xk2 = 1.0\n  print *, icsrcaseb(ssh, xk2)\n\n  !case3\n  ssh = 0.0\n  xk2 = 2.5\n  print *, icsrcaseb(ssh, xk2)\n\n  !case4\n  ssh = 3.7\n  xk2 = -0.8\n  print *, icsrcaseb(ssh, xk2)\n\n  !case5\n  ssh = -2.2\n  xk2 = 3.1\n  print *, icsrcaseb(ssh, xk2)\n  \nend program main",
            "result": [
                "-0.38043158117586828",
                "0.75774259393720167",
                "-0.0000000000000000",
                "0.57147901461371176",
                "2.3487639571262555"
            ]
        },
        "code": "           function icsrcaseb(ssh,xk2)\n           implicit none\n           double precision:: ssh,xk2,icsrcaseb\n           double precision:: aa,uuh\n           aa = sqrt(64.0+144.0d0*ssh**2)\n           uuh = (aa+12*ssh)**(1.0d0/3.0d0)-(aa-12*ssh)**(1.0d0/3.0d0)\n           icsrcaseb = xk2*(-4*uuh*(uuh**2+8)/ &\n                    ((uuh**2+4.0d0)*(uuh**2+12.0d0)))\n           end function icsrcaseb\n"
    },
    {
        "instruction": [
            "Create a Fortran function named \"icsrcasec\" that calculates the value of the inverse cosecant function for a given set of input parameters: phimh (double precision), xxbarh (double precision), ssh (double precision), and xk2 (double precision). The function returns a double precision value.\n\nTo compute the result, the function performs the following calculations:\n1. Compute the values of bb and cc using the input parameters.\n2. Calculate yh by solving a quadratic equation using bb and cc.\n3. Compute the values of phpxya and phpxyb using the input parameters and yh.\n4. Calculate the final result of icsrcasec using xk2, phpxya, phpxyb, and ssh.\n\nThe function serves to provide the inverse cosecant value based on the input parameters, following the specified mathematical calculations.",
            "Give me a Fortran function code named icsrcasec to calculate the value of a variable called icsrcasec. The function takes four input arguments, all of type double precision: phimh, xxbarh, ssh, and xk2. The function returns a single value of type double precision, which is the computed icsrcasec value.\n\nTo calculate the icsrcasec value, the function performs various calculations using the input arguments and intermediate variables. These calculations involve mathematical operations such as addition, subtraction, multiplication, exponentiation, and square root. The final result is assigned to the output variable icsrcasec.\n\nPlease note that the code assumes the availability of the sqrt function to compute the square root.",
            "Create a Fortran function named icsrcasec that calculates the value of the inverse of the arcsecant function. The function takes in four double precision input parameters: `phimh`, `xxbarh`, `ssh`, and `xk2`. The function returns a double precision value `icsrcasec`. Inside the function, the parameters `bb`, `cc`, `yh`, `phpxya`, and `phpxyb` are declared as double precision.\nThe function performs calculations using the input parameters and intermediate variables `bb`, `cc`, `yh`, `phpxya`, and `phpxyb`. The final result is assigned to the variable `icsrcasec` and is returned by the function."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  double precision :: phimh, xxbarh, ssh, xk2\n  \n  !case1\n  phimh = 1.0\n  xxbarh = 2.0\n  ssh = 3.0\n  xk2 = 4.0\n  print *, icsrcasec(phimh, xxbarh, ssh, xk2)\n  \n  !case2\n  phimh = -2.5\n  xxbarh = 1.8\n  ssh = 0.5\n  xk2 = 3.2\n  print *, icsrcasec(phimh, xxbarh, ssh, xk2)\n  \n  !case3\n  phimh = 0.0\n  xxbarh = 0.0\n  ssh = 1.0\n  xk2 = 2.0\n  print *, icsrcasec(phimh, xxbarh, ssh, xk2)\n  \n  !case4\n  phimh = 5.7\n  xxbarh = -3.2\n  ssh = 2.5\n  xk2 = 1.0\n  print *, icsrcasec(phimh, xxbarh, ssh, xk2)\n  \n  !case5\n  phimh = 2.0\n  xxbarh = 4.0\n  ssh = 3.5\n  xk2 = 2.8\n  print *, icsrcasec(phimh, xxbarh, ssh, xk2)\n  \nend program main",
            "result": [
                "-0.61073279823176785",
                "-5.6403585194383696",
                "0.0000000000000000",
                "0.36794888913197465",
                "-0.28402586170811805"
            ]
        },
        "code": "           function icsrcasec(phimh,xxbarh,ssh,xk2)\n           implicit none\n           double precision:: phimh,xxbarh,ssh,xk2,icsrcasec\n           double precision:: bb,cc,yh,phpxya,phpxyb\n           bb = 2*(phimh+xxbarh)-2*ssh+phimh**3/3+phimh**2*xxbarh\n           cc = (phimh+xxbarh)**2+phimh**2*(phimh**2+4*phimh*xxbarh)/12-&\n                      2*ssh*(phimh+xxbarh)\n           yh = (-bb+sqrt(bb*bb-4*cc))/2\n           phpxya = (phimh+xxbarh+yh)\n           phpxyb = phimh*xxbarh+phimh*phimh/2.d0\n           icsrcasec = xk2*(-2.d0*(phpxya+phimh*phpxyb)/ &\n                          (phpxya**2+phpxyb**2)+1.0d0/ssh)\n           end function icsrcasec\n"
    },
    {
        "instruction": [
            "Write a Fortran function named atomic_read that reads the value of an integer input parameter atomically. The function takes 1 input parameter of type integer and returns an integer value.",
            "Create a Fortran function named atomic_read that reads the value of an integer variable atomically. The function takes one input parameter of type integer, named \"p\". The function is responsible for guaranteeing that the entire value of \"p\" is read atomically, meaning that no part of \"p\" can change during the read operation. The function returns an integer value, which is the value read from \"p\".",
            "Write a Fortran function named atomic_read that reads the value of an integer argument atomically. The function takes one input argument, p, of type integer. The function will ensure that the entire value of p is read atomically, meaning that no part of p can change during the read operation. The function will return an integer value, atomic_read, which represents the value of p at the time of the atomic read operation."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: p\n\n  !case1\n  p = 10\n  print *, atomic_read(p)\n\n  !case2\n  p = -5\n  print *, atomic_read(p)\n\n  !case3\n  p = 0\n  print *, atomic_read(p)\n\n  !case4\n  p = 100\n  print *, atomic_read(p)\n\n  !case5\n  p = -12345\n  print *, atomic_read(p)\n\nend program main",
            "result": [
                "10",
                "-5",
                "0",
                "100",
                "-12345"
            ]
        },
        "code": "       function atomic_read(p)\n       integer :: atomic_read\n       integer, intent(in) :: p\n! guarantee that the entire value of p is read atomically. no part of\n! p can change during the read operation.\n\n!$omp atomic read\n       atomic_read = p\n       return\n       end function atomic_read\n"
    },
    {
        "instruction": [
            "Provide a Fortran function named replace_text that replaces occurrences of a given text with a replacement text in a given string. The function takes three input arguments of type character: the original string (s), the text to be replaced (text), and the replacement text (rep). It returns an output argument (outs) of type character, which is the modified string with the replacements made.\n\nTo implement the function, initialize the output string (outs) with the original string (s) and determine the lengths of the text to be replaced (nt) and the replacement text (nr). Then, use a do loop to search for occurrences of the text in the output string. If a match is found (i.e., the index is not zero), replace the text with the replacement text using string concatenation. Continue the loop until all occurrences of the text have been replaced.\n\nEnsure that the output string (outs) has enough length to accommodate the replacements by providing an extra 100 characters in its declared length.\n\nRemember to include the necessary declarations for the function and its input/output parameters.",
            "Write a Fortran function called replace_text that replaces occurrences of a specified text with a replacement text in a given string. The function takes three input arguments: a character string 's', a character string 'text' to be replaced, and a character string 'rep' that will replace 'text'. The function returns a character string 'outs' which is the modified string with the replacements made. The types of the input arguments are 'character(*)' and the type of the output argument is 'character(len(s) + 100)'.",
            "Create a Fortran function called replace_text that replaces occurrences of a specified text with a replacement text within a given string. The function takes three input arguments of type character: the original string 's', the text to be replaced 'text', and the replacement text 'rep'. The function returns a new string 'outs' with the replacements made. The function uses the Fortran features of character manipulation and looping to find and replace the specified text."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(100) :: s, text, rep, outs\n\n  !case1\n  s = \"Hello World\"\n  text = \"World\"\n  rep = \"Universe\"\n  outs = replace_text(s, text, rep)\n  print *, outs\n\n  !case2\n  s = \"This is a test\"\n  text = \"is\"\n  rep = \"was\"\n  outs = replace_text(s, text, rep)\n  print *, outs\n\n  !case3\n  s = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\"\n  text = \"ipsum\"\n  rep = \"Lorem\"\n  outs = replace_text(s, text, rep)\n  print *, outs\n\n  !case4\n  s = \"123456789\"\n  text = \"5\"\n  rep = \"X\"\n  outs = replace_text(s, text, rep)\n  print *, outs\n\n  !case5\n  s = \"abcabcabc\"\n  text = \"abc\"\n  rep = \"xyz\"\n  outs = replace_text(s, text, rep)\n  print *, outs\nend program main",
            "result": [
                "Hello Universe",
                "Thwas was a test",
                "Lorem Lorem dolor sit amet, consectetur adipiscing elit.",
                "1234X6789",
                "xyzxyzxyz"
            ]
        },
        "code": "   function replace_text(s, text, rep) result(outs)\n      character(*)           :: s, text, rep\n      character(len(s) + 100) :: outs     ! provide outs with extra 100 char len\n      integer                 :: i, nt, nr\n\n      outs = s; nt = len_trim(text); nr = len_trim(rep)\n      do\n         i = index(outs, text(:nt)); if (i == 0) exit\n         outs = outs(:i - 1)//rep(:nr)//outs(i + nt:)\n      end do\n   end function replace_text\n"
    },
    {
        "instruction": [
            "Create a Fortran function named modifiedagsupplyreq that takes in two double precision floating point numbers as input arguments: ragshortprevious and ragsupreq. The function computes a modified value of ragsupreq based on the following conditions:\n- If ragshortprevious is less than or equal to 0.0, the modified value is equal to ragsupreq.\n- If ragshortprevious is greater than 0.0 and ragsupreq is greater than ragshortprevious, the modified value is equal to ragsupreq minus ragshortprevious.\n- If ragshortprevious is greater than 0.0 and ragsupreq is less than or equal to ragshortprevious, the modified value is equal to ragsupreq.\nThe function returns the modified value of ragsupreq as a double precision floating point number.",
            "Give me a Fortran function code named modifiedagsupplyreq that calculates the modified agricultural supply requirement. The function takes two input arguments of type real(8) - ragshortprevious and ragsupreq. The function returns one output argument of type real(8) - ragsupreqmod. \n\nTo summarize, the function calculates the modified agricultural supply requirement based on the values of ragshortprevious and ragsupreq. If ragshortprevious is less than or equal to 0, ragsupreqmod is equal to ragsupreq. Otherwise, if ragsupreq is greater than ragshortprevious, ragsupreqmod is equal to ragsupreq minus ragshortprevious. If none of these conditions are met, ragsupreqmod is equal to ragsupreq.\n\nPlease note that the \"real(8)\" type specifier indicates a double precision real number in Fortran.",
            "Create a Fortran function named modifiedagsupplyreq that takes in two 8-byte real numbers as input arguments (ragshortprevious and ragsupreq) and returns a modified value of ragsupreq as output. The function calculates the modified value based on the following conditions:\n- If ragshortprevious is less than or equal to 0.0, the modified value is equal to ragsupreq.\n- If ragshortprevious is greater than 0.0 and ragsupreq is greater than ragshortprevious, the modified value is calculated as the difference between ragsupreq and ragshortprevious.\n- If ragshortprevious is greater than 0.0 and ragsupreq is less than or equal to ragshortprevious, the modified value is equal to ragsupreq.\n\nThe number of input arguments is 2, both of type real(8), and the number of output arguments is 1, also of type real(8)."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real(8) :: ragshortprevious, ragsupreq, ragsupreqmod\n  \n  ! case 1\n  ragshortprevious = 0.0\n  ragsupreq = 100.0\n  ragsupreqmod = modifiedagsupplyreq(ragshortprevious, ragsupreq)\n  print *, ragsupreqmod\n  \n  ! case 2\n  ragshortprevious = 50.0\n  ragsupreq = 100.0\n  ragsupreqmod = modifiedagsupplyreq(ragshortprevious, ragsupreq)\n  print *, ragsupreqmod\n  \n  ! case 3\n  ragshortprevious = -20.0\n  ragsupreq = 50.0\n  ragsupreqmod = modifiedagsupplyreq(ragshortprevious, ragsupreq)\n  print *, ragsupreqmod\n  \n  ! case 4\n  ragshortprevious = 0.0\n  ragsupreq = 0.0\n  ragsupreqmod = modifiedagsupplyreq(ragshortprevious, ragsupreq)\n  print *, ragsupreqmod\n  \n  ! case 5\n  ragshortprevious = 30.0\n  ragsupreq = 20.0\n  ragsupreqmod = modifiedagsupplyreq(ragshortprevious, ragsupreq)\n  print *, ragsupreqmod\nend program main",
            "result": [
                "100.00000000000000",
                "50.000000000000000",
                "50.000000000000000",
                "0.0000000000000000",
                "20.000000000000000"
            ]
        },
        "code": "  function modifiedagsupplyreq(ragshortprevious,ragsupreq) result(ragsupreqmod)\n    real(8),intent(in) :: ragshortprevious,ragsupreq\n    real(8)            :: ragsupreqmod\n    \n    if (ragshortprevious .le. 0.0) then\n        ragsupreqmod = ragsupreq\n    else\n        if (ragsupreq .gt. ragshortprevious) then\n            ragsupreqmod = ragsupreq - ragshortprevious\n        else\n            ragsupreqmod = ragsupreq\n        end if\n    end if\n    \n  end function modifiedagsupplyreq\n"
    },
    {
        "instruction": [
            "Write a Fortran function called \"basename\" that takes in a string and an optional separator character and returns the base name of the file or directory path. The function has 2 input parameters: a string named \"sfullname\" with a maximum length of 256 characters and an optional character named \"cseparator\". The function returns a string named \"sbasename\" with a maximum length of 256 characters. To use the function, provide the full path or name of the file/directory as the input and optionally specify a separator character to locate the base name. If the separator character is not specified, the function will assume the last occurrence of any character in the string as the separator.",
            "Create a Fortran function named \"basename\" that takes in a string named \"sfullname\" and an optional character named \"cseparator\". This function is used to extract the last part of a file path or a file name from a given full name. The function returns a string named \"sbasename\" which contains the extracted file name or the last part of the file path. The input argument \"sfullname\" is of type character with a maximum length of 256 characters, while the optional input argument \"cseparator\" is of type character. The output argument \"sbasename\" is also of type character with a maximum length of 256 characters.",
            "Write a Fortran function code named \"basename\" that takes in a full file name and an optional separator character. The function is designed to extract the base name of the file (i.e., the file name without the path). The input parameter \"sfullname\" is a character string of length 256 that represents the full file name, and the optional input parameter \"cseparator\" is a single character that represents the separator between the path and the file name. The output parameter \"sbasename\" is a character string of length 256 that holds the extracted base name.\n\nTo extract the base name, the function uses the \"index\" intrinsic function to locate the last occurrence of the separator character in the full file name. If the separator is not found, the full file name is assigned to \"sbasename\". Otherwise, the base name is assigned as a substring of the full file name starting from the character immediately after the last occurrence of the separator.\n\nEnsure that the function is defined with the \"function\" keyword, and specify the number and types of the input and output parameters accordingly."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=256) :: sfullname, sbasename\n  character :: cseparator\n  \n  !case1\n  sfullname = \"/home/user/filename.txt\"\n  cseparator = \"/\"\n  sbasename = basename(sfullname, cseparator)\n  print *, sbasename\n\n  !case2\n  sfullname = \"C:\\Program Files\\Application\\myfile.dat\"\n  cseparator = \"\\\"\n  sbasename = basename(sfullname, cseparator)\n  print *, sbasename\n\n  !case3\n  sfullname = \"file.txt\"\n  cseparator = \"/\"\n  sbasename = basename(sfullname, cseparator)\n  print *, sbasename\n\n  !case4\n  sfullname = \"/var/log/system.log\"\n  cseparator = \".\"\n  sbasename = basename(sfullname, cseparator)\n  print *, sbasename\n\n  !case5\n  sfullname = \"C:\\User\\Desktop\\document.docx\"\n  cseparator = \"\\\\\"\n  sbasename = basename(sfullname, cseparator)\n  print *, sbasename\n\nend program main",
            "result": [
                "filename.txt",
                "myfile.dat",
                "file.txt",
                "log",
                "document.docx"
            ]
        },
        "code": "    function basename(sfullname, cseparator) result(sbasename)\n    \n        ! routine arguments\n        character(len=256), intent(in)  :: sfullname\n        character, intent(in), optional :: cseparator\n        character(len=256)              :: sbasename\n        \n        ! local variables\n        integer :: ipos\n        \n        ! locate the last occurrence of path separator character\n        ipos = index(sfullname, cseparator, back=.true.)\n        if(ipos <= 0) then\n            sbasename = sfullname\n        else\n            sbasename = sfullname(ipos+1:)\n        end if\n        \n    end function basename\n"
    },
    {
        "instruction": [
            "Write a Fortran function named f to compute the value of a mathematical function. The function takes two input arguments, both of which are of type real. The function calculates the value of -y - 3 * exp(-x) * sin(3*x) and assigns it to the output argument f, which is also of type real.",
            "Create a Fortran function named f that calculates a mathematical expression. The function takes two input arguments of type real, x and y. The output is a real value, f. The function calculates the value of f using the formula: f = -y - 3 * exp(-x) * sin(3 * x).",
            "Create a Fortran function named f that calculates the value of a mathematical function. The function takes two input parameters, x and y, both of which are of type real. The function returns a single output parameter, f, also of type real. The function computes the value of -y - 3 * exp(-x) * sin(3 * x) and assigns it to the output parameter f."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real :: x, y, result\n\n  ! case 1\n  x = 0.5\n  y = 1.0\n  result = f(x, y)\n  print *, result\n\n  ! case 2\n  x = -1.0\n  y = 2.0\n  result = f(x, y)\n  print *, result\n\n  ! case 3\n  x = 2.0\n  y = -3.0\n  result = f(x, y)\n  print *, result\n\n  ! case 4\n  x = 1.0\n  y = 0.0\n  result = f(x, y)\n  print *, result\n\n  ! case 5\n  x = -2.5\n  y = -1.5\n  result = f(x, y)\n  print *, result\n\nend program main",
            "result": [
                "-2.81503391",
                "-0.849188209",
                "3.11344433",
                "-0.155745462",
                "35.7815361"
            ]
        },
        "code": "function f(x, y)\n  implicit none\n  real::x, y, f\n  f=-y-3*exp(-x)*sin(3*x)\nend function f\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named fibr that calculates the Fibonacci number for a given input integer. The function takes a single input argument of type integer, named \"n\". The function returns an output integer, named \"fib\", which represents the Fibonacci number corresponding to the input value of \"n\". The function uses recursion to compute the Fibonacci number, following the rule that the Fibonacci number for n is equal to the sum of the Fibonacci numbers for n-1 and n-2.",
            "Create a Fortran function named fibr that calculates the Fibonacci number recursively. The function takes an integer input argument 'n' and returns an integer output argument 'fib'. \n\nTo use the function, provide an integer value for 'n'. The function will then compute the Fibonacci number corresponding to that value and assign it to 'fib'. \n\nNote that the Fibonacci sequence starts with 0 and 1, where each subsequent number is the sum of the two preceding numbers.",
            "You need to create a Fortran function called fibr that calculates the Fibonacci number for a given input integer value. The function takes one input parameter of type integer. The output of the function is an integer value representing the Fibonacci number. \n\nIn the function, the input integer is checked using a select case statement. If the input is less than or equal to 0, the function returns 0. If the input is equal to 1, the function returns 1. For any other value, the function recursively calls itself with the previous two Fibonacci numbers and adds them together to calculate the current Fibonacci number. \n\nPlease implement the fibr function in Fortran and provide the necessary input and output types in the function definition."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n\n  \n  !case1\n  n = 0\n  print *, fibr(n)\n  \n  !case2\n  n = 1\n  print *, fibr(n)\n  \n  !case3\n  n = 5\n  print *, fibr(n)\n  \n  !case4\n  n = 10\n  print *, fibr(n)\n  \n  !case5\n  n = 15\n  print *, fibr(n)\nend program main",
            "result": [
                "0",
                "1",
                "5",
                "55",
                "610"
            ]
        },
        "code": "    recursive function fibr(n) result(fib)\n        integer, intent(in) :: n\n        integer             :: fib\n\n        select case (n)\n            case (:0);      fib = 0\n            case (1);       fib = 1\n            case default;   fib = fibr(n-1) + fibr(n-2)\n        end select\n    end function fibr\n"
    },
    {
        "instruction": [
            "Write a Fortran function code named \"reverse\" that takes a string as input and returns the reversed version of the input string. The input parameter is of type \"character\" and has the intent \"in\". The output parameter is also of type \"character\" and has the result name \"res\". The function uses recursion to reverse the string.",
            "Provide a Fortran function code named \"reverse\" that takes a string as input and returns the reversed version of the input string as output. The input parameter is a character string, and the output parameter is also a character string. The function uses recursion to reverse the string.",
            "Give me a Fortran function code named reverse to reverse a given string. The function takes one input argument of type character, which is the string to be reversed. The output of the function is also a character, representing the reversed string."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=100) :: string\n  \n  !case1\n  string = 'hello'\n  print *, reverse(string)\n  \n  !case2\n  string = 'racecar'\n  print *, reverse(string)\n  \n  !case3\n  string = '1234567890'\n  print *, reverse(string)\n  \n  !case4\n  string = 'fortran'\n  print *, reverse(string)\n  \n  !case5\n  string = 'abcdefghijklmnopqrstuvwxyz'\n  print *, reverse(string)\n  \nend program main",
            "result": [
                "olleh",
                "racecar",
                "0987654321",
                "nartrof",
                "zyxwvutsrqponmlkjihgfedcba"
            ]
        },
        "code": "  recursive function reverse (string) result (res)\n\n    implicit none\n    character (*), intent (in) :: string\n    character (len (string)) :: res\n\n    if (len (string) == 0) then\n      res = ''\n    else\n      res = string (len (string) :) // reverse (string (: len (string) - 1))\n    end if\n\n  end function reverse\n"
    },
    {
        "instruction": [
            "Give me a Fortran function named biggamma that calculates the value of the reciprocal of tau plus the sum of a series of numbers. The function takes a single input argument of type real*8 named tau. The function returns a value of type real*8. \n\nTo compute the value, the function initializes the variable biggamma to 0.0d0 and sets the variable order to 20. It then enters a loop that iterates from order to 1, decrementing by 1 each time. Inside the loop, the variable biggamma is updated using a recursive formula. Finally, the function computes the reciprocal of tau plus biggamma and assigns it to the variable biggamma. \n\nThe function returns the final value of biggamma as the result.",
            "Create a Fortran function named biggamma that computes the reciprocal of the sum of a series of terms. The function takes one input parameter of type real*8 (double precision) named tau. The function returns a value of type real*8 (double precision) named biggamma. \n\nAt the beginning of the function, declare the input parameter tau as intent(in) to indicate that it is an input-only parameter. \n\nInside the function, declare two local variables: order of type integer to store the number of terms in the series, and i of type integer for loop indexing. \n\nSet the value of order to 20. \n\nInitialize the value of biggamma to 0.0. \n\nNext, use a do loop to iterate from order down to 1 in steps of -1. Inside the loop, update the value of biggamma using the formula i / (1.0 + i / (tau + biggamma)). \n\nAfter the loop, update the value of biggamma again using the formula 1.0 / (tau + biggamma). \n\nFinally, return the value of biggamma as the result of the function.",
            "Provide a Fortran function named biggamma that calculates the value of the gamma function for a given parameter tau. The function takes a single input argument of type real*8 (double precision) named tau. The function returns a single output value of type real*8 (double precision) named biggamma. \n\nTo calculate the gamma function, the function iteratively approximates it using a loop. The loop starts with an initial value of biggamma set to 0.0d0 (double precision 0). The loop runs for a total of 20 iterations, decrementing the loop index i from order (20) to 1. \n\nWithin each iteration, the value of biggamma is updated using a recursive formula. The formula involves dividing i by the sum of 1.0d0 and the ratio of i to the sum of tau and the previous value of biggamma. \n\nAfter the loop completes, the final value of biggamma is divided by the sum of tau and biggamma, and this result is assigned to the variable biggamma. Finally, the function returns the value of biggamma.\n\nPlease note that the function assumes double precision calculations and uses the real*8 data type for the input and output parameters."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real*8 :: tau\n  \n  !case1\n  tau = 1.0d0\n  print *, biggamma(tau)\n  \n  !case2\n  tau = 2.5d0\n  print *, biggamma(tau)\n  \n  !case3\n  tau = 0.5d0\n  print *, biggamma(tau)\n  \n  !case4\n  tau = 10.0d0\n  print *, biggamma(tau)\n  \n  !case5\n  tau = -1.0d0\n  print *, biggamma(tau)\nend program main",
            "result": [
                "0.59634755803620043",
                "0.30352583650406140",
                "0.92293763571383647",
                "9.1563333939788077E-002",
                "8.7812196733559021E-003"
            ]
        },
        "code": "function biggamma(tau)\n    implicit none\n    real*8, intent(in) :: tau\n    real*8 :: biggamma\n\n    integer :: order, i\n\n    order = 20\n    biggamma = 0.0d0\n\n    do i=order, 1, -1\n        biggamma = i / (1.0d0 + i / (tau + biggamma))\n    end do \n\n    biggamma = 1.0d0 / (tau + biggamma)\nend function biggamma\n"
    },
    {
        "instruction": [
            "Write a Fortran function named \"gfc\" that takes an integer input argument \"n\" and returns a real*8 array named \"g\" as the output. The function calculates different values based on the value of \"n\". If \"n\" is equal to 1, the function sets the values of \"g\" to (1.1330d0, -0.4059d0, 0.07014d0). If \"n\" is equal to 2, the function sets the values of \"g\" to (1.0785d0, -0.2319d0, 0.02947d0). For any other value of \"n\", the function calculates the elements of \"g\" based on a set of mathematical expressions involving \"n\". The function does not return any value explicitly, but the updated \"g\" array is accessible after the function call.",
            "Provide a Fortran function code named \"gfc\" that calculates the values of an array \"g\" based on the input parameter \"n\". The function takes an integer input parameter \"n\". The output is an array \"g\" of type real*8 with dimension 3. If \"n\" is equal to 1, the values of \"g\" are set to 1.1330, -0.4059, and 0.07014. If \"n\" is equal to 2, the values of \"g\" are set to 1.0785, -0.2319, and 0.02947. For any other value of \"n\", the values of \"g\" are calculated based on the given formulas. The function does not return any value explicitly.",
            "Give me a Fortran function named gfc that takes an integer input argument 'n' and returns a real array 'g' of size 3. The function computes the values of 'g' based on the value of 'n' using conditional statements. If 'n' is equal to 1, 'g' is assigned specific values. If 'n' is equal to 2, 'g' is assigned different specific values. For any other value of 'n', 'g' is computed based on a mathematical formula using 'n'. The function does not have any explicit output, but the computed values of 'g' are returned automatically."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n\n  real(8), dimension(3) :: g\n  \n  !case1\n  n = 1\n  g = gfc(n)\n  print *, g(1), g(2), g(3)\n  \n  !case2\n  n = 2\n  g = gfc(n)\n  print *, g(1), g(2), g(3)\n  \n  !case3\n  n = 3\n  g = gfc(n)\n  print *, g(1), g(2), g(3)\n  \n  !case4\n  n = 5\n  g = gfc(n)\n  print *, g(1), g(2), g(3)\n  \n  !case5\n  n = 10\n  g = gfc(n)\n  print *, g(1), g(2), g(3)\n  \nend program main",
            "result": [
                "1.1330000000000000      -0.40589999999999998        7.0139999999999994E-002",
                "1.0785000000000000      -0.23190000000000000        2.9470000000000000E-002",
                "1.0567000000000000      -0.16682592592592593        1.7596296296296294E-002",
                "1.0348759999999999      -0.10748720000000000        8.4519999999999977E-003",
                "1.0154840000000001       -5.7751900000000002E-002   2.8529999999999992E-003"
            ]
        },
        "code": "      function gfc(n) result(g)\n\n      integer, intent(in) :: n\n\n      real*8, dimension(3) :: g\n\n      if (n .eq. 1) then\n\n         g = (/1.1330d0, -0.4059d0, 0.07014d0/)\n\n      elseif (n .eq. 2) then\n\n         g = (/1.0785d0, -0.2319d0, 0.02947d0/)\n\n      else\n\n         g(1) = 0.9935d0 + 0.2328d0 / n - 0.1296d0 / n / n\n\n         g(2) = (-0.6282d0 + 0.5598d0 / n - 0.5299d0 / n / n) / n\n\n         g(3) = (0.3887d0 - 1.181d0 / n + 1.470d0 / n / n) / n / n\n\n      endif\n\n      return\n\n      end function gfc\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named pbc_d_max_origin to calculate the maximum distance between atoms in a periodic boundary condition system. The function takes three input parameters: natoms (an integer), coo (a 3xnatoms double precision array), and avec (a 3x3 double precision array). The function returns a single output parameter, d_max (a double precision).",
            "Write a Fortran function named pbc_d_max_origin that calculates the maximum distance from the origin for a given set of Cartesian coordinates and lattice vectors. \n\nThe function takes three input parameters: \n1. an integer parameter named natoms that represents the number of atoms,\n2. a 2D array named coo of size (3, natoms) containing the Cartesian coordinates of the atoms,\n3. a 2D array named avec of size (3,3) representing the lattice vectors.\n\nThe function returns a double precision parameter named d_max, representing the maximum distance from the origin.\n\nInside the function, a loop iterates over the atoms and converts the Cartesian coordinates to Cartesian coordinates relative to the lattice vectors. The maximum distance from the origin is calculated by taking the dot product of the converted coordinates with themselves and finding the maximum value. Finally, the square root of the maximum value is assigned to d_max.\n\nEnsure that the function declaration includes the \"implicit none\" statement to enforce explicit variable declarations.\n",
            "Create a Fortran function named pbc_d_max_origin that calculates the maximum distance from the origin in a periodic box. The function takes three input parameters: an integer \"natoms\" representing the number of atoms, a double precision 2D array \"coo\" representing the coordinates of the atoms, and a double precision 2D array \"avec\" representing the lattice vectors of the periodic box. The function returns a single double precision value \"d_max\" representing the maximum distance."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: natoms\n  double precision, allocatable :: coo(:,:), avec(:,:)\n  \n  !case1\n  natoms = 3\n  allocate(coo(3,natoms))\n  allocate(avec(3,3))\n  coo = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0], shape(coo))\n  avec = reshape([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0], shape(avec))\n  print *, pbc_d_max_origin(natoms, coo, avec)\n  deallocate(coo)\n  deallocate(avec)\n\n  !case2\n  natoms = 4\n  allocate(coo(3,natoms))\n  allocate(avec(3,3))\n  coo = reshape([-1.0, 0.0, 2.0, 0.0, 1.0, -2.0, 3.0, -4.0, 5.0, 6.0, -7.0, 8.0], shape(coo))\n  avec = reshape([2.0, 0.0, 0.0, 0.0, 3.0, 0.0, 0.0, 0.0, 4.0], shape(avec))\n  print *, pbc_d_max_origin(natoms, coo, avec)\n  deallocate(coo)\n  deallocate(avec)\n\n  !case3\n  natoms = 5\n  allocate(coo(3,natoms))\n  allocate(avec(3,3))\n  coo = reshape([0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0], shape(coo))\n  avec = reshape([1.0, 0.0, 0.0, 0.0, 2.0, 0.0, 0.0, 0.0, 3.0], shape(avec))\n  print *, pbc_d_max_origin(natoms, coo, avec)\n  deallocate(coo)\n  deallocate(avec)\n\n  !case4\n  natoms = 2\n  allocate(coo(3,natoms))\n  allocate(avec(3,3))\n  coo = reshape([0.0, 0.0, 0.0, 1.0, 1.0, 1.0], shape(coo))\n  avec = reshape([2.0, 0.0, 0.0, 0.0, 3.0, 0.0, 0.0, 0.0, 4.0], shape(avec))\n  print *, pbc_d_max_origin(natoms, coo, avec)\n  deallocate(coo)\n  deallocate(avec)\n\n  !case5\n  natoms = 3\n  allocate(coo(3,natoms))\n  allocate(avec(3,3))\n  coo = reshape([5.0, 5.0, 5.0, 10.0, 10.0, 10.0, 15.0, 15.0, 15.0], shape(coo))\n  avec = reshape([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0], shape(avec))\n  print *, pbc_d_max_origin(natoms, coo, avec)\n  deallocate(coo)\n  deallocate(avec)\nend program main",
            "result": [
                "13.928388277184119",
                "40.112342240263160",
                "14.966629547095765",
                "5.3851648071345037",
                "25.980762113533160"
            ]
        },
        "code": "  function pbc_d_max_origin(natoms, coo, avec) result(d_max)\n\n    implicit none\n\n    integer,                                intent(in) :: natoms\n    double precision, dimension(3, natoms), intent(in) :: coo\n    double precision, dimension(3,3),       intent(in) :: avec\n    double precision                                   :: d_max\n    \n    integer                        :: iat\n    double precision, dimension(3) :: cart\n\n    d_max = 0.0d0\n    do iat = 1, natoms\n       cart(1:3) = coo(1,iat)*avec(1:3,1) &\n                 + coo(2,iat)*avec(1:3,2) &\n                 + coo(3,iat)*avec(1:3,3)\n       d_max = max(d_max, sum(cart*cart))\n    end do\n    d_max = sqrt(d_max)\n\n  end function pbc_d_max_origin\n"
    },
    {
        "instruction": [
            "Provide a Fortran function named pbc_number_of_tvecs to calculate the number of lattice vectors within a specified distance from the origin. The function takes three input parameters: r_cut (radial cut-off), d_max (maximum distance from the origin), and avec (a 3x3 matrix representing lattice vectors). The function returns the number of lattice vectors (ntvecs) that satisfy the condition. The input parameters are of type double precision and the output parameter is of type integer.",
            "Write a Fortran function named pbc_number_of_tvecs that calculates the number of lattice vectors within a specified distance from the origin, taking into account periodic boundary conditions. The function takes three input parameters: r_cut (a double precision number representing the radial cut-off distance), d_max (a double precision number representing the maximum distance of a point/atom from the origin), and avec (a 3x3 double precision array representing the lattice vectors). The function returns an integer value representing the number of lattice vectors satisfying the condition.",
            "Provide a Fortran function named pbc_number_of_tvecs that calculates the number of lattice vectors within a certain radial cutoff distance. The function takes three input parameters: r_cut (a double precision value representing the radial cutoff), d_max (a double precision value representing the maximum distance of a point/atom from the origin), and avec (a 3x3 double precision array representing the lattice vectors). The function returns an integer value representing the number of lattice vectors within the cutoff distance."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  double precision :: r_cut, d_max\n  double precision, dimension(3,3) :: avec\n  integer :: ntvecs\n  \n  !case1\n  r_cut = 5.0\n  d_max = 2.0\n  avec = reshape([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0], [3, 3])\n  ntvecs = pbc_number_of_tvecs(r_cut, d_max, avec)\n  print *, ntvecs\n\n  !case2\n  r_cut = 10.0\n  d_max = 3.0\n  avec = reshape([1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 0.0, 1.0], [3, 3])\n  ntvecs = pbc_number_of_tvecs(r_cut, d_max, avec)\n  print *, ntvecs\n\n  !case3\n  r_cut = 8.0\n  d_max = 4.0\n  avec = reshape([2.0, 0.0, 0.0, 0.0, 2.0, 0.0, 0.0, 0.0, 2.0], [3, 3])\n  ntvecs = pbc_number_of_tvecs(r_cut, d_max, avec)\n  print *, ntvecs\n\n  !case4\n  r_cut = 6.0\n  d_max = 5.0\n  avec = reshape([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0], [3, 3])\n  ntvecs = pbc_number_of_tvecs(r_cut, d_max, avec)\n  print *, ntvecs\n\n  !case5\n  r_cut = 12.0\n  d_max = 2.0\n  avec = reshape([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0], [3, 3])\n  ntvecs = pbc_number_of_tvecs(r_cut, d_max, avec)\n  print *, ntvecs\n\nend program main",
            "result": [
                "1535",
                "4432",
                "1054",
                "8538",
                "8538"
            ]
        },
        "code": "  function pbc_number_of_tvecs(r_cut, d_max, avec) result(ntvecs)\n\n    implicit none\n\n    !------------------------------------------------------------------!\n    ! r_cut    : radial cut-off                                        !\n    ! d_max    : max. distance of a point/atom from the origin         !\n    ! avec(i,j): i-th component of the j-th lattice vector             !\n    !------------------------------------------------------------------!\n\n    double precision,                 intent(in) :: r_cut\n    double precision,                 intent(in) :: d_max\n    double precision, dimension(3,3), intent(in) :: avec\n    integer                                      :: ntvecs\n\n    integer                        :: ia, ib, ic\n    logical                        :: lasta, lastb, lastc\n    double precision, dimension(3) :: cart\n    double precision               :: r2, rcut2\n\n    rcut2 = r_cut + 2.0d0*d_max\n    rcut2 = rcut2*rcut2\n\n    ntvecs = 0\n    \n    ic = 0\n    c_do : do\n       lastc = .false.\n       ib = 0\n       b_do : do\n          lastb = .false.\n          ia = 0\n          a_do : do\n             lasta = .false.\n             if ((ic==0) .and. (ib==0) .and. (ia==0)) then\n                ia = ia + 1\n                cycle a_do\n             end if\n             \n             ! (+ia, +ib, +ic)\n             cart(1:3) = dble(ia)*avec(1:3,1) &\n                       + dble(ib)*avec(1:3,2) &\n                       + dble(ic)*avec(1:3,3) \n             r2 = sum(cart*cart)\n             if (r2 <= rcut2) then\n                lasta = .true.\n                ntvecs = ntvecs + 1\n             end if\n\n             if ((ia /= 0) .and. (ib /= 0)) then\n\n                ! (+ia, -ib, +ic)\n                cart(1:3) = dble(ia)*avec(1:3,1) &\n                          + dble(-ib)*avec(1:3,2) &\n                          + dble(ic)*avec(1:3,3) \n                r2 = sum(cart*cart)\n                if (r2 <= rcut2) then\n                   lasta = .true.\n                   ntvecs = ntvecs + 1\n                end if\n\n                if (ic /= 0) then\n\n                   ! (-ia, +ib, +ic)\n                   cart(1:3) = dble(-ia)*avec(1:3,1) &\n                             + dble(ib)*avec(1:3,2) &\n                             + dble(ic)*avec(1:3,3) \n                   r2 = sum(cart*cart)\n                   if (r2 <= rcut2) then\n                      lasta = .true.\n                      ntvecs = ntvecs + 1\n                   end if\n                   \n                   ! (-ia, -ib, +ic)\n                   cart(1:3) = dble(-ia)*avec(1:3,1) &\n                             + dble(-ib)*avec(1:3,2) &\n                             + dble(ic)*avec(1:3,3) \n                   r2 = sum(cart*cart)\n                   if (r2 <= rcut2) then\n                      lasta = .true.\n                      ntvecs = ntvecs + 1\n                   end if\n\n                end if ! c /= 0\n\n             else if ((ia /= 0) .and. (ic /= 0)) then\n\n                   ! (-ia, +ib, +ic)\n                   cart(1:3) = dble(-ia)*avec(1:3,1) &\n                             + dble(ib)*avec(1:3,2) &\n                             + dble(ic)*avec(1:3,3) \n                   r2 = sum(cart*cart)\n                   if (r2 <= rcut2) then\n                      lasta = .true.\n                      ntvecs = ntvecs + 1\n                   end if\n                   \n             else if ((ib /= 0) .and. (ic /= 0)) then\n\n                ! (+ia, -ib, +ic)\n                cart(1:3) = dble(ia)*avec(1:3,1) &\n                          + dble(-ib)*avec(1:3,2) &\n                          + dble(ic)*avec(1:3,3) \n                r2 = sum(cart*cart)\n                if (r2 <= rcut2) then\n                   lasta = .true.\n                   ntvecs = ntvecs + 1\n                end if\n\n             end if\n\n             if (.not. lasta) exit a_do\n             lastb = .true.\n             ia = ia + 1\n          end do a_do\n          if (.not. lastb) exit b_do\n          lastc = .true.\n          ib = ib + 1\n       end do b_do\n       if (.not. lastc) exit c_do\n       ic = ic + 1\n    end do c_do\n  \n  end function pbc_number_of_tvecs\n"
    },
    {
        "instruction": [
            "Please write a Fortran function named \"eta\" that computes the value of the variable \"eta\" based on the given formula. The function takes five input arguments: x (real), eta0 (real), etainf (real), tau (real), and r (real). The function returns one output argument, eta (real).",
            "Give me a Fortran function code named eta to compute the value of a function using the given formula. The function takes 5 input arguments of type real, which are eta0, etainf, tau, r, and x. The function also has one output argument of type real, which is eta. The function calculates the value of eta using the given formula and returns it.",
            "Create a Fortran function named \"eta\" that calculates the value of eta based on the given parameters. The function takes five input arguments, all of type real(8): x, eta0, etainf, tau, and r. It returns an output argument, also of type real(8), which represents the calculated eta value. The function uses the formula eta = eta0 - (eta0 - etainf) * (1.0e0 - exp(-((x/tau)**r)))."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real(8) :: eta0, etainf, tau, r, x\n  \n  !case1\n  eta0 = 10.0\n  etainf = 1.0\n  tau = 5.0\n  r = 2.0\n  x = 2.0\n  print *, eta(x, eta0, etainf, tau, r)\n\n  !case2\n  eta0 = 5.0\n  etainf = 2.0\n  tau = 3.0\n  r = 1.0\n  x = 1.5\n  print *, eta(x, eta0, etainf, tau, r)\n\n  !case3\n  eta0 = 100.0\n  etainf = 50.0\n  tau = 10.0\n  r = 3.0\n  x = 5.0\n  print *, eta(x, eta0, etainf, tau, r)\n\n  !case4\n  eta0 = 1.0\n  etainf = 0.0\n  tau = 1.0\n  r = 1.0\n  x = 0.5\n  print *, eta(x, eta0, etainf, tau, r)\n\n  !case5\n  eta0 = 2.0\n  etainf = 0.0\n  tau = 3.0\n  r = 2.0\n  x = 1.0\n  print *, eta(x, eta0, etainf, tau, r)\n\nend program main",
            "result": [
                "8.6692941006959021",
                "3.8195919791379005",
                "94.124845129229769",
                "0.60653065971263342",
                "1.7896786336287396"
            ]
        },
        "code": "function eta(x,eta0,etainf,tau,r)\n    implicit none\n    real(8):: eta,eta0,etainf,tau,r,x\n\n    eta = eta0-(eta0-etainf)*(1.0e0-exp(-((x/tau)**r)))\n\nend function eta\n"
    },
    {
        "instruction": [
            "Provide a Fortran function named \"distance\" that calculates the distance between a given number \"i\" and the nearest perfect square number. \n\nThe function takes one input argument, \"i\", of type real, which represents the number to calculate the distance from. The output of the function is an integer, \"j\", which represents the calculated distance.\n\nTo calculate the distance, the function performs the following steps:\n1. Computes the square root of \"i\" and rounds it up to the nearest integer.\n2. Divides the rounded square root by 2 and takes the floor of the result to obtain \"num\".\n3. Calculates the offset by subtracting the square of (2 * num - 1) from \"i\" and taking the modulus by 2 * num.\n4. Calculates the final distance, \"j\", by adding \"num\" to the absolute difference between the offset and \"num\".\n\nThe \"distance\" function in Fortran provides a convenient way to calculate the distance between a given number and the nearest perfect square number.",
            "Write a Fortran function code called \"distance\" that calculates the distance of a given number from the center of a spiral pattern. The function takes one input argument of type real and returns one output argument of type integer. \n\nTo calculate the distance, the function first determines the number of spirals based on the square root of the input number. It then calculates the offset by taking the difference between the input number and the square of twice the number of spirals minus one, and computes the modulus of this offset with twice the number of spirals. \n\nThe function finally computes the distance by adding the number of spirals to the absolute difference between the offset and the number of spirals.",
            "Provide a Fortran function code named distance to calculate the distance of a given input number to the central point in a spiral pattern. The function takes in one input argument of type real and returns one output argument of type integer. The input argument is passed by value using the intent(in) keyword.\n\nTo compute the distance, the function performs the following steps:\n1. Calculates the number of spirals (num) based on the square root of the input number.\n2. Computes the offset by taking the input number minus the square of (2 * num - 1).\n3. The offset is then modulo divided by (2 * num).\n4. The final distance (j) is obtained by adding num and the absolute difference between the offset and num.\n\nWrite the Fortran instructions for the distance function, specifying the number and type of input and output parameters."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real :: i\n  integer :: j\n  \n  !case1\n  i = 10.0\n  j = distance(i)\n  print *, j\n  \n  !case2\n  i = 25.0\n  j = distance(i)\n  print *, j\n  \n  !case3\n  i = 50.0\n  j = distance(i)\n  print *, j\n  \n  !case4\n  i = 100.0\n  j = distance(i)\n  print *, j\n  \n  !case5\n  i = 150.0\n  j = distance(i)\n  print *, j\n\nend program main",
            "result": [
                "3",
                "4",
                "7",
                "9",
                "7"
            ]
        },
        "code": "function distance(i) result(j)\n    real, intent(in) :: i ! input\n    integer :: j ! output\n\n    integer :: num\n    integer :: offset\n\n    num = floor(real(ceiling(sqrt(i))) / 2)\n    offset = mod(int(i - ((2 * num - 1) ** 2)), 2 * num)\n\n    j = num + abs(offset - num)\n end function distance\n"
    },
    {
        "instruction": [
            "Provide a Fortran function code named get_random_double_precision_with_range to generate a random double precision number within a given range. The function takes two input arguments of type double precision, representing the start and end values of the range. It returns a random double precision number within this range as the output.",
            "Give me a Fortran function code named get_random_double_precision_with_range that generates a random double precision number within a specified range. The function takes two input arguments of type double precision called start and end_, representing the range. The function returns a single output argument of type double precision called random_double, which holds the generated random number.",
            "Write a Fortran function code named get_random_double_precision_with_range that generates a random double precision number within a specified range. The function takes two input arguments of type double precision, representing the start and end of the range. It returns a single output argument of type double precision, which is the randomly generated number within the specified range."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  double precision :: start, end_, random_double\n  \n  !case1\n  start = 0.0\n  end_ = 1.0\n  random_double = get_random_double_precision_with_range(start, end_)\n  print *, random_double\n\n  !case2\n  start = -10.0\n  end_ = 10.0\n  random_double = get_random_double_precision_with_range(start, end_)\n  print *, random_double\n\n  !case3\n  start = -100.0\n  end_ = 100.0\n  random_double = get_random_double_precision_with_range(start, end_)\n  print *, random_double\n\n  !case4\n  start = 1.5\n  end_ = 2.5\n  random_double = get_random_double_precision_with_range(start, end_)\n  print *, random_double\n\n  !case5\n  start = -1000.0\n  end_ = 1000.0\n  random_double = get_random_double_precision_with_range(start, end_)\n  print *, random_double\n\nend program main",
            "result": [
                "0.99755959009261719",
                "1.3364941522254661",
                "93.183075099224993",
                "2.2479276854714323",
                "-265.21820525048861"
            ]
        },
        "code": "    function get_random_double_precision_with_range(start, end_) result(random_double)\n        double precision, intent(in) :: start\n        double precision, intent(in) :: end_\n        double precision :: random_double\n\n        call random_number(random_double)\n        random_double = start + (end_ - start) * random_double\n    end function\n"
    },
    {
        "instruction": [
            "Create a Fortran function named get_random_integer_with_range that generates a random integer within a specified range. The function takes two input arguments of type integer, start and end_, which represent the lower and upper bounds of the range. The function returns a single output argument, random_integer, of type integer.",
            "Write a Fortran function named get_random_integer_with_range that generates a random integer within a specified range. The function takes two input arguments, start (integer) and end_ (integer), which define the range of possible values. The output is a single integer, random_integer.",
            "Write a Fortran function named get_random_integer_with_range that generates a random integer within a specified range. The function takes two input parameters, both of type integer, which represent the start and end of the range. The function returns a single output parameter, an integer, which represents the randomly generated integer."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: start, end_, random_integer\n  \n  ! Case 1\n  start = 1\n  end_ = 10\n  random_integer = get_random_integer_with_range(start, end_)\n  print *, random_integer\n  \n  ! Case 2\n  start = -5\n  end_ = 5\n  random_integer = get_random_integer_with_range(start, end_)\n  print *, random_integer\n  \n  ! Case 3\n  start = 100\n  end_ = 1000\n  random_integer = get_random_integer_with_range(start, end_)\n  print *, random_integer\n  \n  ! Case 4\n  start = -100\n  end_ = -10\n  random_integer = get_random_integer_with_range(start, end_)\n  print *, random_integer\n  \n  ! Case 5\n  start = 0\n  end_ = 1\n  random_integer = get_random_integer_with_range(start, end_)\n  print *, random_integer\n  \nend program main",
            "result": [
                "10",
                "1",
                "970",
                "-32",
                "0"
            ]
        },
        "code": "    function get_random_integer_with_range(start, end_) result(random_integer)\n        integer, intent(in) :: start\n        integer, intent(in) :: end_\n        integer :: random_integer\n\n        double precision :: random_real\n\n        call random_number(random_real)\n        random_integer = start + floor((end_ + 1 - start) * random_real)\n    end function\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named count_non_empty to count the number of non-empty elements in a two-dimensional integer array. The function takes one input argument, an integer array called counts, with an unspecified size. The function returns one output argument, an integer called nr_non_empty, which represents the number of non-empty elements in the array.",
            "Create a Fortran function named count_non_empty that counts the number of non-empty elements in a two-dimensional integer array. The function takes one input argument, counts, which is a two-dimensional integer array passed by reference. The function returns one output argument, nr_non_empty, which is an integer representing the number of non-empty elements in the array.",
            "Provide a Fortran function named count_non_empty that calculates the number of non-empty elements in a two-dimensional integer array. The function takes one input argument, \"counts\", which is a two-dimensional integer array. The function returns one output argument, \"nr_non_empty\", which is an integer."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: m, n\n  integer, allocatable :: counts(:,:)\n  \n  !case1\n  m = 3\n  n = 4\n  allocate(counts(m,n))\n  counts = reshape([1, 0, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0], [m, n])\n  print *, count_non_empty(counts)\n  deallocate(counts)\n\n  !case2\n  m = 2\n  n = 3\n  allocate(counts(m,n))\n  counts = reshape([0, 0, 0, 0, 0, 0], [m, n])\n  print *, count_non_empty(counts)\n  deallocate(counts)\n\n  !case3\n  m = 2\n  n = 2\n  allocate(counts(m,n))\n  counts = reshape([1, 2, 3, 4], [m, n])\n  print *, count_non_empty(counts)\n  deallocate(counts)\n\n  !case4\n  m = 4\n  n = 5\n  allocate(counts(m,n))\n  counts = reshape([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [m, n])\n  print *, count_non_empty(counts)\n  deallocate(counts)\n\n  !case5\n  m = 3\n  n = 3\n  allocate(counts(m,n))\n  counts = reshape([1, 1, 1, 1, 1, 1, 1, 1, 1], [m, n])\n  print *, count_non_empty(counts)\n  deallocate(counts)\nend program main",
            "result": [
                "6",
                "0",
                "4",
                "0",
                "9"
            ]
        },
        "code": "    function count_non_empty(counts) result(nr_non_empty)\n        implicit none\n        integer, dimension(:, :), intent(in) :: counts\n        integer :: nr_non_empty\n\n        nr_non_empty = size(counts) - count(counts == 0)\n    end function count_non_empty\n"
    },
    {
        "instruction": [
            "Create a Fortran function named \"pi\" that calculates an approximation of the value of pi using a Monte Carlo method. The function takes an integer input parameter \"n\" and returns a real output parameter \"pi\". The function uses an array \"x\" of size 2 by \"n\" to generate random numbers between 0 and 1. The function then counts the number of randomly generated points that fall within a unit circle centered at the origin. The value of pi is approximated by multiplying the count by 4 and dividing it by \"n\".",
            "Provide a Fortran function named pi that calculates the value of pi using a Monte Carlo method. The function takes an integer input parameter, n, which represents the number of random points to be generated. The function returns a real(8) output value, pi, which represents the estimated value of pi.",
            "Write a Fortran function named \"pi\" that calculates the value of pi using a Monte Carlo method. The function takes a single integer input parameter \"n\" and returns a single real output parameter \"pi\". \n\nIn the function, generate a 2D array of random numbers between 0 and 1 using the \"random_number\" subroutine. Then, compute the distance from the origin for each point in the array using the \"hypot\" function. Count the number of points that fall within a unit circle centered at the origin. Multiply this count by 4 and divide it by \"n\" to approximate the value of pi. Return the calculated value of pi as the output of the function."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: n\n  \n  !case1\n  n = 1000\n  print *, pi(n)\n  \n  !case2\n  n = 10000\n  print *, pi(n)\n\n  !case3\n  n = 100000\n  print *, pi(n)\n  \n  !case4\n  n = 1000000\n  print *, pi(n)\n  \n  !case5\n  n = 10000000\n  print *, pi(n)\n  \nend program main",
            "result": [
                "3.1040000000000001",
                "3.1196000000000002",
                "3.1392000000000002",
                "3.1429800000000001",
                "3.1420032000000000"
            ]
        },
        "code": "        function  pi(n)\n        integer :: n\n        real(8) :: x(2,n),pi\n        call random_number(x)\n        pi = 4.d0 * dble( count( hypot(x(1,:),x(2,:)) <= 1.d0 ) ) / n\n        end function\n"
    },
    {
        "instruction": [
            "Give me a Fortran function code named string_their that takes an integer value as input and returns a string. If the input value is not equal to 1, the function returns \"their\". If the input value is equal to 1, the function returns \"its\". The number of input arguments is 1 and the data type is [integer]. The number of output arguments is 1 and the data type is [character].",
            "Provide a Fortran function code named string_their to determine the appropriate pronoun to use based on the input value. The function takes an integer value as input and returns a character string indicating whether the value is singular or plural. The number of input arguments is 1 and the type is integer. The number of output arguments is 1 and the type is character with a length of 5.",
            "Provide a Fortran function code called string_their that takes an integer value as input and returns a string. The function determines whether the input value is equal to 1 or not. If the value is not equal to 1, the function returns the string \"their\". Otherwise, it returns the string \"its\". The function has one input parameter of type integer and one output parameter of type character."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: val\n  \n  !case1\n  val = 1\n  print *, string_their(val)\n\n  !case2\n  val = -5\n  print *, string_their(val)\n\n  !case3\n  val = 0\n  print *, string_their(val)\n\n  !case4\n  val = 100\n  print *, string_their(val)\n\n  !case5\n  val = 2\n  print *, string_their(val)\nend program main",
            "result": [
                "its",
                "their",
                "their",
                "their",
                "their"
            ]
        },
        "code": "     function string_their( val )\n\n!   given an integer val, returns \"their\" if v /= 1, otherwise returns \"its\"\n\n     character ( len = 5 ) :: string_their\n\n!--------------------------------\n!   d u m m y   a r g u m e n t\n!--------------------------------\n\n     integer, intent( in ) :: val\n\n     if ( val /= 1 ) then\n       string_their = \"their\"\n     else\n       string_their = \"its  \"\n     end if\n\n     return\n\n\n      end function string_their\n"
    },
    {
        "instruction": [
            "Write a Fortran function named mod2pi that takes a single input argument of type real and returns a value of type real. This function is used to compute the modulus of an angle in the range [-\u03c0, \u03c0] radians. The function takes into account the tolerance level specified by the parameter theta_tol. The number of input arguments is 1 and the data type is real. The number of output arguments is 1 and the data type is real.",
            "Create a Fortran function called mod2pi that calculates the modulo 2*pi of a given angle in radians. The function takes a single input argument of type real, representing the angle theta. The output of the function is also of type real and represents the resulting angle modulo 2*pi. The function uses the acos function to calculate the value of pi and checks if the input theta lies within the range -pi to pi. If theta is within this range, it is returned as is. Otherwise, the function iteratively adjusts theta by subtracting or adding 2*pi until it lies within the desired range. Once theta satisfies the condition, it is returned as the result.",
            "Write a Fortran function named mod2pi that calculates the modulo 2*pi of a given angle. The input parameter is a real number named theta. The output is also a real number named mod2pi. Additionally, the function uses a constant named theta_tol which is set to 1.e-6. The function checks if theta is within the range of -pi to pi and returns theta if it is. If theta is slightly outside this range, it is rounded to the nearest boundary value (-pi or pi). If theta is significantly outside the range, the function repeatedly subtracts or adds 2*pi until theta falls within the range. Finally, the function assigns the resulting value to mod2pi."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real :: theta\n  \n  !case1\n  theta = 0.0\n  print *, mod2pi(theta)\n  \n  !case2\n  theta = 3.14\n  print *, mod2pi(theta)\n  \n  !case3\n  theta = -3.14\n  print *, mod2pi(theta)\n  \n  !case4\n  theta = 6.28\n  print *, mod2pi(theta)\n  \n  !case5\n  theta = -6.28\n  print *, mod2pi(theta)\n  \nend program main\n    ",
            "result": [
                "0.00000000",
                "3.14000010",
                "-3.14000010",
                "-3.18527222E-03",
                "3.18527222E-03"
            ]
        },
        "code": "   function mod2pi(theta)\n\n      real, intent(in) :: theta\n      real :: pi, th, mod2pi\n      real, parameter :: theta_tol = 1.e-6\n      logical :: out\n\n      pi = 2.*acos(0.)\n\n      if (theta <= pi .and. theta >= -pi) then\n         mod2pi = theta\n         return\n      end if\n\n      if (theta - theta_tol <= pi .and. theta >= -pi) then\n         mod2pi = pi\n         return\n      end if\n\n      if (theta <= pi .and. theta + theta_tol >= -pi) then\n         mod2pi = -pi\n         return\n      end if\n\n      th = theta\n      out = .true.\n      do while (out)\n         if (th > pi) th = th - 2.*pi\n         if (th < -pi) th = th + 2.*pi\n         if (th <= pi .and. th >= -pi) out = .false.\n      end do\n      mod2pi = th\n\n   end function mod2pi\n"
    },
    {
        "instruction": [
            "Provide a Fortran function named \"convert\" that takes an integer input argument and returns a character string. The function checks if the input number is divisible by 3, 5, or 7, and appends the corresponding strings \"pling\", \"plang\", or \"plong\" to the result string, respectively. If the input number is not divisible by any of these numbers, the function converts the integer to a string and returns it. The function has 1 input parameter of type integer and 1 output parameter of type character.",
            "Give me a Fortran function code named convert to convert an integer to a string representation. The number of input arguments is 1 and the data type is [integer]. The number of output arguments is 1 and the data type is [character(20)].",
            "Create a Fortran function named \"convert\" to convert an integer into a corresponding string based on specific rules. The function takes one input argument of type integer and returns a string. The input argument represents the integer to be converted. The function checks if the input integer is divisible by 3, 5, or 7 and appends the corresponding string \"pling\", \"plang\", or \"plong\" respectively. If the input integer is not divisible by any of these numbers, the function converts the integer to a string."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: i\n  \n  !case1\n  i = 15\n  print *, convert(i)\n  \n  !case2\n  i = 21\n  print *, convert(i)\n  \n  !case3\n  i = 35\n  print *, convert(i)\n  \n  !case4\n  i = 45\n  print *, convert(i)\n  \n  !case5\n  i = 58\n  print *, convert(i)\n  \nend program main",
            "result": [
                "plingplang",
                "plingplong",
                "plangplong",
                "plingplang",
                "58"
            ]
        },
        "code": "  function convert(i)\n    implicit none\n    integer :: i\n    character(20) :: convert\n\n    convert = ''\n\n    if ( mod(i,3) .eq. 0 ) then\n      convert = 'pling'\n    end if\n    if ( mod(i,5) .eq. 0 ) then\n      convert = trim(convert)//'plang'\n    end if\n    if ( mod(i,7) .eq. 0 ) then\n      convert = trim(convert)//'plong'\n    end if\n\n    if (convert .eq. '') then\n      write( convert, '(i20)' ) i\n      convert = trim(adjustl(convert))\n    end if\n\n  end function convert\n"
    },
    {
        "instruction": [
            "Create a Fortran function named \"wrap\" that wraps an input integer value within a specified range. The function takes two input arguments: an integer \"x\" and an integer \"l\". It returns an integer value, denoted as \"wrap\". \n\nTo wrap the input value \"x\" within the range of 0 to \"l-1\", the function performs the following steps: \n1. If \"x\" is greater than or equal to \"l\", subtract \"l\" from \"x\" and assign the result to \"wrap\".\n2. If \"x\" is less than 0, add \"l\" to \"x\" and assign the result to \"wrap\".\n3. If neither of the above conditions is true, assign the value of \"x\" to \"wrap\".\n\nImplement this function, considering the input arguments' data types as integers.",
            "Write a Fortran function named \"wrap\" that takes two integer arguments, \"x\" and \"l\". The function calculates the wrapped value of \"x\" within the range of 0 to \"l\". The number of input arguments is 2 and the test_data type is [integer,integer]. The number of output arguments is 1 and the test_data type is [integer].",
            "Create a Fortran function called \"wrap\" which takes two input parameters, an integer \"x\" and an integer \"l\". The function returns an integer. \n\nThe purpose of this function is to wrap the value of \"x\" within the range from 0 to \"l-1\". If \"x\" is greater than or equal to \"l\", the function subtracts \"l\" from \"x\". If \"x\" is less than 0, the function adds \"l\" to \"x\". Otherwise, if \"x\" is within the range, it remains unchanged.\n\nSo, the function \"wrap\" helps in wrapping an integer value within a given range."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: x, l, result\n  \n  !case1\n  x = 5\n  l = 10\n  result = wrap(x, l)\n  print *, result\n  \n  !case2\n  x = 15\n  l = 8\n  result = wrap(x, l)\n  print *, result\n  \n  !case3\n  x = -3\n  l = 7\n  result = wrap(x, l)\n  print *, result\n  \n  !case4\n  x = 0\n  l = 5\n  result = wrap(x, l)\n  print *, result\n  \n  !case5\n  x = 100\n  l = 100\n  result = wrap(x, l)\n  print *, result\nend program main",
            "result": [
                "5",
                "7",
                "4",
                "0",
                "0"
            ]
        },
        "code": "pure function wrap(x, l)\ninteger, intent(in) :: x,l\ninteger :: wrap\n\nif (x >= l) then\n    wrap = x - l\nelse if (x < 0) then\n    wrap = x + l\nelse\n    wrap = x\nendif\nend function\n"
    },
    {
        "instruction": [
            "Write a Fortran function called finite_diff that calculates the finite difference between two given values. The function takes in 5 input parameters: y, yp, ym, dx, maskp, and maskm, all of type real(kind=8) and integer. It returns a single output parameter, finite_diff, of type real(kind=8). The function checks the values of maskp and maskm and computes the finite difference accordingly. If both maskp and maskm are 1, the function computes the difference between yp and ym divided by twice dx. If maskm is 0 and maskp is 1, the function computes the difference between yp and y divided by dx. If maskm is 1 and maskp is 0, the function computes the difference between y and ym divided by dx. If both maskp and maskm are not 1, the function returns 0.",
            "Write a Fortran function named finite_diff that calculates the finite difference based on the given input parameters. The function takes in five input arguments: y, yp, ym, dx (all of type real(kind=8)), and maskp, maskm (both of type integer). The function returns a single output value of type real(kind=8).\n\nTo use the function, provide the values for y, yp, ym, dx, maskp, and maskm as input arguments. The function will evaluate different cases based on the values of maskp and maskm. If both are equal to 1, the function calculates the central difference using (yp-ym)/(2*dx). If maskm is 0 and maskp is 1, the function calculates the forward difference using (yp-y)/dx. If maskm is 1 and maskp is 0, the function calculates the backward difference using (y-ym)/dx. If both maskp and maskm are either 0 or not equal to 1, the function returns 0.\n\nTo obtain the finite difference result, assign the output of the function to a variable of type real(kind=8).",
            "Give me a Fortran function code named finite_diff to compute the finite difference approximation. The function takes in 5 input parameters, all of which are of type real(kind=8). The parameters are y, yp, ym, dx, maskp, and maskm. The function returns a single output parameter of type real(kind=8) named finite_diff. \n\nThe function calculates the finite difference approximation based on the values of y, yp, ym, dx, maskp, and maskm. If both maskm and maskp are equal to 1, the finite difference is computed as (yp-ym)/(2*dx). If maskm is equal to 0 and maskp is equal to 1, the finite difference is computed as (yp-y)/dx. If maskm is equal to 1 and maskp is equal to 0, the finite difference is computed as (y-ym)/dx. If both maskm and maskp are equal to 0, the finite difference is set to 0."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  real(kind=8) :: y, yp, ym, dx\n  integer :: maskp, maskm\n  \n  !case1\n  y = 1.0\n  yp = 2.0\n  ym = 0.0\n  dx = 0.1\n  maskp = 1\n  maskm = 1\n  print *, finite_diff(y, yp, ym, dx, maskp, maskm)\n\n  !case2\n  y = -1.0\n  yp = 0.0\n  ym = -2.0\n  dx = 0.05\n  maskp = 0\n  maskm = 1\n  print *, finite_diff(y, yp, ym, dx, maskp, maskm)\n\n  !case3\n  y = 0.0\n  yp = 0.0\n  ym = -3.0\n  dx = 0.2\n  maskp = 1\n  maskm = 0\n  print *, finite_diff(y, yp, ym, dx, maskp, maskm)\n\n  !case4\n  y = 5.0\n  yp = 5.0\n  ym = 5.0\n  dx = 1.0\n  maskp = 0\n  maskm = 0\n  print *, finite_diff(y, yp, ym, dx, maskp, maskm)\n\n  !case5\n  y = 3.0\n  yp = 4.0\n  ym = 2.0\n  dx = 0.5\n  maskp = 1\n  maskm = 1\n  print *, finite_diff(y, yp, ym, dx, maskp, maskm)\n\nend program main",
            "result": [
                "9.9999998509883898",
                "19.999999701976780",
                "0.0000000000000000",
                "0.0000000000000000",
                "2.0000000000000000"
            ]
        },
        "code": "pure function finite_diff(y,yp,ym,dx,maskp,maskm)\nreal(kind=8), intent(in) :: y,yp,ym,dx\ninteger, intent(in) :: maskp,maskm\nreal(kind=8) :: finite_diff\n\nif (maskm == 1 .and. maskp == 1) then\n    finite_diff = (yp-ym)/(2.*dx)\nelse if (maskm == 0 .and. maskp == 1) then\n    finite_diff = (yp-y)/dx\nelse if (maskm == 1 .and. maskp == 0) then\n    finite_diff = (y-ym)/dx\nelse\n    finite_diff = 0.\nend if\nend function\n"
    },
    {
        "instruction": [
            "Write a Fortran function named \"tolower\" that converts all uppercase letters in a given string to lowercase. The function takes one input argument of type \"character(len=*)\" which represents the input string. The function returns a string of the same length as the input string, with all uppercase letters converted to lowercase. The name of the function is \"tolower\".",
            "Give me a Fortran function code named tolower to convert a given string to lowercase. The function takes a single input argument of type character and returns a modified string of the same length.",
            "Provide a Fortran function code named tolower that converts a given string to lowercase. The function takes one input parameter of type character and returns a string of the same length. \n\nTo use the function, provide the string you want to convert as the input argument to the tolower function. The function will iterate over each character in the string and check if it is an uppercase letter. If it is, the corresponding lowercase letter will be substituted. The resulting lowercase string will then be returned as the output.\n\nPlease note that the function is case-sensitive, so any non-alphabet characters or already lowercase letters will remain unchanged."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  character(len=50) :: string\n  \n  !case1\n  string = 'Hello World'\n  print *, tolower(string)\n\n  !case2\n  string = 'FORTRAN'\n  print *, tolower(string)\n\n  !case3\n  string = 'Testing 123'\n  print *, tolower(string)\n\n  !case4\n  string = 'UPPER CASE'\n  print *, tolower(string)\n\n  !case5\n  string = 'mIxEd CaSe'\n  print *, tolower(string)\n  \nend program main",
            "result": [
                "Hello World",
                "FORTRAN",
                "Testing 123",
                "UPPER CASE",
                "mIxEd CaSe"
            ]
        },
        "code": "function tolower( string )\n    character(len=*), intent(in) :: string\n    character(len=len(string))   :: tolower\n\n    character(len=26), parameter :: upper = 'abcdefghijklmnopqrstuvwxyz'\n    character(len=26), parameter :: lower = 'abcdefghijklmnopqrstuvwxyz'\n\n    integer                    :: i\n    integer                    :: k\n    integer                    :: length\n\n    length  = len(string)\n    tolower = string\n    do i = 1,length\n        k = index( upper, string(i:i) )\n        if ( k > 0 ) then\n           tolower(i:i) = lower(k:k)\n        endif\n    enddo\nend function tolower\n"
    },
    {
        "instruction": [
            "Create a Fortran function named \"number_of_occupied_adjacent_sets\" to count the number of occupied adjacent sets in a 2D integer array. The function takes three parameters: two integers \"i\" and \"j\" representing the index to check, and a 2D integer array \"iarray\" containing the data. The function returns an integer \"n_occupied\" representing the count of occupied adjacent sets.",
            "Give me a Fortran function code named number_of_occupied_adjacent_sets to count the number of occupied adjacent sets in a 2D array. The function takes three input parameters: i (integer), j (integer), and iarray (integer 2D array). The function returns a single output parameter: n_occupied (integer).",
            "Provide a Fortran function named number_of_occupied_adjacent_sets that calculates the number of occupied adjacent sets for a given index in a 2D integer array. The function takes three input parameters: two integers i and j to indicate the index to check, and a 2D integer array iarray. The function returns a single integer, n_occupied, which represents the number of occupied adjacent sets."
        ],
        "test_case": {
            "unit_test": "program main\n  use test_function\n  implicit none\n  integer :: i, j\n  integer, allocatable :: iarray(:,:)\n  \n  !case1\n  i = 2\n  j = 2\n  allocate(iarray(3,3))\n  iarray = reshape([0, 1, 0, 1, 1, 1, 0, 1, 0], [3,3])\n  print *, number_of_occupied_adjacent_sets(i, j, iarray)\n  deallocate(iarray)\n\n  !case2\n  i = 1\n  j = 1\n  allocate(iarray(3,3))\n  iarray = reshape([1, 1, 1, 1, 1, 1, 1, 1, 1], [3,3])\n  print *, number_of_occupied_adjacent_sets(i, j, iarray)\n  deallocate(iarray)\n\n  !case3\n  i = 3\n  j = 3\n  allocate(iarray(3,3))\n  iarray = reshape([1, 1, 1, 1, 0, 1, 1, 1, 1], [3,3])\n  print *, number_of_occupied_adjacent_sets(i, j, iarray)\n  deallocate(iarray)\n\n  !case4\n  i = 2\n  j = 2\n  allocate(iarray(4,4))\n  iarray = reshape([0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0], [4,4])\n  print *, number_of_occupied_adjacent_sets(i, j, iarray)\n  deallocate(iarray)\n\n  !case5\n  i = 4\n  j = 4\n  allocate(iarray(4,4))\n  iarray = reshape([1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1], [4,4])\n  print *, number_of_occupied_adjacent_sets(i, j, iarray)\n  deallocate(iarray)\nend program main",
            "result": [
                "4",
                "3",
                "2",
                "4",
                "2"
            ]
        },
        "code": "    function number_of_occupied_adjacent_sets(i, j, iarray) result(n_occupied)\n    !! for part 1\n    implicit none\n    integer,intent(in) :: i, j !! index to check\n    integer,dimension(:,:),intent(in) :: iarray\n    integer :: n_occupied, ii, jj\n\n    integer :: n, m\n\n    n = size(iarray,1)\n    m = size(iarray,2)\n\n    n_occupied = 0\n\n    ! ###\n    ! #x#\n    ! ###\n\n    do ii = i-1, i+1\n        do jj = j-1, j+1\n            if (ii==i .and. jj==j) cycle\n            if (ii>0 .and. ii<=n .and. jj>0 .and. jj<=m) then\n                if (iarray(ii,jj)==1) n_occupied = n_occupied + 1\n            end if\n        end do\n    end do\n\n    end function number_of_occupied_adjacent_sets\n"
    }
]