{"data": {"instruction": ["Give me a Fortran function code named near that calculates the nearest distance between two points on a periodic domain. The function takes two input parameters of type real*8: dx (the difference between the two points) and domain (the size of the periodic domain). It returns a single output parameter of type real*8, which represents the corrected distance between the points.", "Write a Fortran function named \"near\" that calculates the nearest distance between two points, taking into account the possibility of wrap-around when evaluating distances. The function takes two input arguments: \"dx\" of type real*8 and \"domain\" of type real*8. It returns one output argument: \"near\" of type real*8. The function's purpose is to correct for wrap-around by subtracting or adding the \"domain\" value to the \"dx\" value based on certain conditions.", "Provide a Fortran function named \"near\" that calculates the proximity of a given distance \"dx\" to a specified domain size \"domain\". The function takes two input parameters of type real*8, \"dx\" and \"domain\". The function returns a value of type real*8. To correct for wrap-around when evaluating distances between points, the function computes the half of the domain size and assigns it to the variable \"hdom\". Then, the function assigns the value of \"dx\" to the variable \"near\". If \"dx\" is greater than or equal to half of the domain size, the function subtracts the domain size from \"near\". If \"dx\" is less than or equal to negative half of the domain size, the function adds the domain size to \"near\"."], "test_case": {"unit_test": "program main\n  use test_function\n  implicit none\n  real*8 :: dx, domain, result\n  \n  ! Test Case 1\n  dx = 2.0\n  domain = 10.0\n  result = near(dx, domain)\n  print *, result\n  \n  ! Test Case 2\n  dx = -7.5\n  domain = 20.0\n  result = near(dx, domain)\n  print *, result\n  \n  ! Test Case 3\n  dx = 12.5\n  domain = 25.0\n  result = near(dx, domain)\n  print *, result\n  \n  ! Test Case 4\n  dx = -1.0\n  domain = 5.0\n  result = near(dx, domain)\n  print *, result\n  \n  ! Test Case 5\n  dx = 0.0\n  domain = 100.0\n  result = near(dx, domain)\n  print *, result\n  \nend program main", "result": ["2.0000000000000000", "-7.5000000000000000", "-12.500000000000000", "-1.0000000000000000", "0.0000000000000000"]}, "code": "  function near(dx,domain)\n\n    ! to correct for wrap-around when evaulating distances\n    ! between points\n\n    implicit none\n    real*8, intent(in) :: dx, domain\n    ! real*8, intent(out) :: near\n    real*8 :: near\n    real*8 :: hdom\n\n    hdom = 0.5*domain\n    near = dx\n    if (dx .ge. hdom) near = near - domain\n    if (dx .le. -hdom) near = near + domain\n\n  end function near\n"}, "gpt4_result": "```json\n{\n  \"result\": true,\n  \"instruction\": \"Provide a Fortran function named \\\"near\\\" that calculates the proximity of a given distance \\\"dx\\\" to a specified domain size \\\"domain\\\". The function takes two input parameters of type real*8, \\\"dx\\\" and \\\"domain\\\". The function returns a value of type real*8. To correct for wrap-around when evaluating distances between points, the function computes the half of the domain size and assigns it to the variable \\\"hdom\\\". Then, the function assigns the value of \\\"dx\\\" to the variable \\\"near\\\". If \\\"dx\\\" is greater than or equal to half of the domain size, the function subtracts the domain size from \\\"near\\\". If \\\"dx\\\" is less than or equal to negative half of the domain size, the function adds the domain size to \\\"near\\\".\",\n  \"code\": \"  function near(dx,domain)\\n\\n    ! to correct for wrap-around when evaulating distances\\n    ! between points\\n\\n    implicit none\\n    real*8, intent(in) :: dx, domain\\n    ! real*8, intent(out) :: near\\n    real*8 :: near\\n    real*8 :: hdom\\n\\n    hdom = 0.5*domain\\n    near = dx\\n    if (dx .ge. hdom) near = near - domain\\n    if (dx .le. -hdom) near = near + domain\\n\\n  end function near\\n\",\n  \"reason\": \"The provided code and instruction pair meets all the specified rules. The code has both input parameters (dx and domain) and an output parameter (near), fulfilling rule 1. The code performs a logical function that corrects for wrap-around in a periodic domain, which is not a simple variable assignment, thus satisfying rule 2. The instruction accurately describes the logical function of the code, meeting rule 3. Finally, both the code and the instruction are specific to the Fortran domain, complying with rule 4.\"\n}\n```"}
{"data": {"instruction": ["Provide a Fortran function named get_default_ii that returns an integer value. The function takes two input arguments: one optional integer argument named 'i' and one mandatory integer argument named 'default'. The function checks if the optional argument 'i' is present. If 'i' is present, the function returns its value. Otherwise, it returns the value of the mandatory argument 'default'.", "Create a Fortran function named get_default_ii that takes two input arguments. The first argument, i, is an optional integer, and the second argument, default, is a required integer. The function returns an integer. \n\nThe function checks if the optional argument, i, is present. If it is present, the function assigns the value of i to the result, ret. If i is not present, the function assigns the value of default to ret.", "Create a Fortran function called get_default_ii that returns an integer value. The function takes two input parameters, i (optional integer) and default (integer). If the optional parameter i is present, the function assigns its value to the return variable ret. Otherwise, the function assigns the value of default to ret."], "test_case": {"unit_test": "program main\n  use test_function\n  implicit none\n  integer :: i, default\n  \n  !case1\n  i = 5\n  default = 10\n  print *, get_default_ii(i, default)\n  \n  !case2\n  i = 3\n  default = 7\n  print *, get_default_ii(i, default)\n  \n  !case3\n  i = 0\n  default = 100\n  print *, get_default_ii(i, default)\n  \n  !case4\n  i = -10\n  default = -5\n  print *, get_default_ii(i, default)\n  \n  !case5\n  default = 0\n  print *, get_default_ii(default=default)\nend program main", "result": ["5", "3", "0", "-10", "0"]}, "code": "    elemental function get_default_ii(i, default) result(ret)\n        integer, intent(in), optional :: i\n        integer, intent(in) :: default\n        integer :: ret\n\n        if (present(i)) then\n            ret = i\n        else\n            ret = default\n        end if\n    end function\n"}, "gpt4_result": "```json\n{\n  \"result\": true,\n  \"instruction\": \"Provide a Fortran function named get_default_ii that returns an integer value. The function takes two input arguments: one optional integer argument named 'i' and one mandatory integer argument named 'default'. The function checks if the optional argument 'i' is present. If 'i' is present, the function returns its value. Otherwise, it returns the value of the mandatory argument 'default'.\",\n  \"code\": \"    elemental function get_default_ii(i, default) result(ret)\\n        integer, intent(in), optional :: i\\n        integer, intent(in) :: default\\n        integer :: ret\\n\\n        if (present(i)) then\\n            ret = i\\n        else\\n            ret = default\\n        end if\\n    end function\\n\",\n  \"reason\": \"The provided code and instruction pair meets all the specified rules. The code has both input parameters ('i' and 'default') and an output parameter ('ret'), fulfilling rule 1. The code performs a logical check to see if the optional parameter 'i' is present, which is not a simple variable assignment, thus satisfying rule 2. The instruction accurately describes the logical function of the code, which is to return the value of 'i' if present or 'default' otherwise, meeting rule 3. Finally, both the code and the instruction are specific to the Fortran domain, complying with rule 4.\"\n}\n```"}
