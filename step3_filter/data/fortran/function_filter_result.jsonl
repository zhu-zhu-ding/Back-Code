{"data": {"instruction": ["Give me a Fortran function code named near that calculates the nearest distance between two points on a periodic domain. The function takes two input parameters of type real*8: dx (the difference between the two points) and domain (the size of the periodic domain). It returns a single output parameter of type real*8, which represents the corrected distance between the points.", "Write a Fortran function named \"near\" that calculates the nearest distance between two points, taking into account the possibility of wrap-around when evaluating distances. The function takes two input arguments: \"dx\" of type real*8 and \"domain\" of type real*8. It returns one output argument: \"near\" of type real*8. The function's purpose is to correct for wrap-around by subtracting or adding the \"domain\" value to the \"dx\" value based on certain conditions.", "Provide a Fortran function named \"near\" that calculates the proximity of a given distance \"dx\" to a specified domain size \"domain\". The function takes two input parameters of type real*8, \"dx\" and \"domain\". The function returns a value of type real*8. To correct for wrap-around when evaluating distances between points, the function computes the half of the domain size and assigns it to the variable \"hdom\". Then, the function assigns the value of \"dx\" to the variable \"near\". If \"dx\" is greater than or equal to half of the domain size, the function subtracts the domain size from \"near\". If \"dx\" is less than or equal to negative half of the domain size, the function adds the domain size to \"near\"."], "test_case": {"unit_test": "program main\n  use test_function\n  implicit none\n  real*8 :: dx, domain, result\n  \n  ! Test Case 1\n  dx = 2.0\n  domain = 10.0\n  result = near(dx, domain)\n  print *, result\n  \n  ! Test Case 2\n  dx = -7.5\n  domain = 20.0\n  result = near(dx, domain)\n  print *, result\n  \n  ! Test Case 3\n  dx = 12.5\n  domain = 25.0\n  result = near(dx, domain)\n  print *, result\n  \n  ! Test Case 4\n  dx = -1.0\n  domain = 5.0\n  result = near(dx, domain)\n  print *, result\n  \n  ! Test Case 5\n  dx = 0.0\n  domain = 100.0\n  result = near(dx, domain)\n  print *, result\n  \nend program main", "result": ["2.0000000000000000", "-7.5000000000000000", "-12.500000000000000", "-1.0000000000000000", "0.0000000000000000"]}, "code": "  function near(dx,domain)\n\n    ! to correct for wrap-around when evaulating distances\n    ! between points\n\n    implicit none\n    real*8, intent(in) :: dx, domain\n    ! real*8, intent(out) :: near\n    real*8 :: near\n    real*8 :: hdom\n\n    hdom = 0.5*domain\n    near = dx\n    if (dx .ge. hdom) near = near - domain\n    if (dx .le. -hdom) near = near + domain\n\n  end function near\n"}, "gpt4_result": "```json\n{\n  \"result\": true,\n  \"instruction\": \"Provide a Fortran function named \\\"near\\\" that calculates the proximity of a given distance \\\"dx\\\" to a specified domain size \\\"domain\\\". The function takes two input parameters of type real*8, \\\"dx\\\" and \\\"domain\\\". The function returns a value of type real*8. To correct for wrap-around when evaluating distances between points, the function computes the half of the domain size and assigns it to the variable \\\"hdom\\\". Then, the function assigns the value of \\\"dx\\\" to the variable \\\"near\\\". If \\\"dx\\\" is greater than or equal to half of the domain size, the function subtracts the domain size from \\\"near\\\". If \\\"dx\\\" is less than or equal to negative half of the domain size, the function adds the domain size to \\\"near\\\".\",\n  \"code\": \"  function near(dx,domain)\\n\\n    ! to correct for wrap-around when evaulating distances\\n    ! between points\\n\\n    implicit none\\n    real*8, intent(in) :: dx, domain\\n    ! real*8, intent(out) :: near\\n    real*8 :: near\\n    real*8 :: hdom\\n\\n    hdom = 0.5*domain\\n    near = dx\\n    if (dx .ge. hdom) near = near - domain\\n    if (dx .le. -hdom) near = near + domain\\n\\n  end function near\\n\",\n  \"reason\": \"The provided code and instruction pair meets all the specified rules. The code has both input parameters (dx and domain) and an output parameter (near), fulfilling rule 1. The code performs a logical function that corrects for wrap-around in a periodic domain, which is not a simple variable assignment, thus satisfying rule 2. The instruction accurately describes the logical function of the code, meeting rule 3. Finally, both the code and the instruction are specific to the Fortran domain, complying with rule 4.\"\n}\n```"}
