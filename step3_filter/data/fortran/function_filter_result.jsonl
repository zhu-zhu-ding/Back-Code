{"data": {"instruction": ["Give me a Fortran function code named near that calculates the nearest distance between two points on a periodic domain. The function takes two input parameters of type real*8: dx (the difference between the two points) and domain (the size of the periodic domain). It returns a single output parameter of type real*8, which represents the corrected distance between the points.", "Write a Fortran function named \"near\" that calculates the nearest distance between two points, taking into account the possibility of wrap-around when evaluating distances. The function takes two input arguments: \"dx\" of type real*8 and \"domain\" of type real*8. It returns one output argument: \"near\" of type real*8. The function's purpose is to correct for wrap-around by subtracting or adding the \"domain\" value to the \"dx\" value based on certain conditions.", "Provide a Fortran function named \"near\" that calculates the proximity of a given distance \"dx\" to a specified domain size \"domain\". The function takes two input parameters of type real*8, \"dx\" and \"domain\". The function returns a value of type real*8. To correct for wrap-around when evaluating distances between points, the function computes the half of the domain size and assigns it to the variable \"hdom\". Then, the function assigns the value of \"dx\" to the variable \"near\". If \"dx\" is greater than or equal to half of the domain size, the function subtracts the domain size from \"near\". If \"dx\" is less than or equal to negative half of the domain size, the function adds the domain size to \"near\"."], "test_case": {"unit_test": "program main\n  use test_function\n  implicit none\n  real*8 :: dx, domain, result\n  \n  ! Test Case 1\n  dx = 2.0\n  domain = 10.0\n  result = near(dx, domain)\n  print *, result\n  \n  ! Test Case 2\n  dx = -7.5\n  domain = 20.0\n  result = near(dx, domain)\n  print *, result\n  \n  ! Test Case 3\n  dx = 12.5\n  domain = 25.0\n  result = near(dx, domain)\n  print *, result\n  \n  ! Test Case 4\n  dx = -1.0\n  domain = 5.0\n  result = near(dx, domain)\n  print *, result\n  \n  ! Test Case 5\n  dx = 0.0\n  domain = 100.0\n  result = near(dx, domain)\n  print *, result\n  \nend program main", "result": ["2.0000000000000000", "-7.5000000000000000", "-12.500000000000000", "-1.0000000000000000", "0.0000000000000000"]}, "code": "  function near(dx,domain)\n\n    ! to correct for wrap-around when evaulating distances\n    ! between points\n\n    implicit none\n    real*8, intent(in) :: dx, domain\n    ! real*8, intent(out) :: near\n    real*8 :: near\n    real*8 :: hdom\n\n    hdom = 0.5*domain\n    near = dx\n    if (dx .ge. hdom) near = near - domain\n    if (dx .le. -hdom) near = near + domain\n\n  end function near\n"}, "gpt4_result": {"result": true, "instruction": "Provide a Fortran function named \"near\" that calculates the proximity of a given distance \"dx\" to a specified domain size \"domain\". The function takes two input parameters of type real*8, \"dx\" and \"domain\". The function returns a value of type real*8. To correct for wrap-around when evaluating distances between points, the function computes the half of the domain size and assigns it to the variable \"hdom\". Then, the function assigns the value of \"dx\" to the variable \"near\". If \"dx\" is greater than or equal to half of the domain size, the function subtracts the domain size from \"near\". If \"dx\" is less than or equal to negative half of the domain size, the function adds the domain size to \"near\".", "code": "  function near(dx,domain)\n\n    ! to correct for wrap-around when evaulating distances\n    ! between points\n\n    implicit none\n    real*8, intent(in) :: dx, domain\n    ! real*8, intent(out) :: near\n    real*8 :: near\n    real*8 :: hdom\n\n    hdom = 0.5*domain\n    near = dx\n    if (dx .ge. hdom) near = near - domain\n    if (dx .le. -hdom) near = near + domain\n\n  end function near\n", "reason": "The given Fortran function code named 'near' and the instruction both meet all the requirements. The code has both input parameters (dx, domain) and output parameter (near). The code is not a simple variable assignment, it has a logical function which is to calculate the nearest distance between two points on a periodic domain. The instruction completely describes the logical function of the code. Both the code and instructions have Fortran domain characteristics."}}
{"data": {"instruction": ["Provide a Fortran function named get_default_ii that returns an integer value. The function takes two input arguments: one optional integer argument named 'i' and one mandatory integer argument named 'default'. The function checks if the optional argument 'i' is present. If 'i' is present, the function returns its value. Otherwise, it returns the value of the mandatory argument 'default'.", "Create a Fortran function named get_default_ii that takes two input arguments. The first argument, i, is an optional integer, and the second argument, default, is a required integer. The function returns an integer. \n\nThe function checks if the optional argument, i, is present. If it is present, the function assigns the value of i to the result, ret. If i is not present, the function assigns the value of default to ret.", "Create a Fortran function called get_default_ii that returns an integer value. The function takes two input parameters, i (optional integer) and default (integer). If the optional parameter i is present, the function assigns its value to the return variable ret. Otherwise, the function assigns the value of default to ret."], "test_case": {"unit_test": "program main\n  use test_function\n  implicit none\n  integer :: i, default\n  \n  !case1\n  i = 5\n  default = 10\n  print *, get_default_ii(i, default)\n  \n  !case2\n  i = 3\n  default = 7\n  print *, get_default_ii(i, default)\n  \n  !case3\n  i = 0\n  default = 100\n  print *, get_default_ii(i, default)\n  \n  !case4\n  i = -10\n  default = -5\n  print *, get_default_ii(i, default)\n  \n  !case5\n  default = 0\n  print *, get_default_ii(default=default)\nend program main", "result": ["5", "3", "0", "-10", "0"]}, "code": "    elemental function get_default_ii(i, default) result(ret)\n        integer, intent(in), optional :: i\n        integer, intent(in) :: default\n        integer :: ret\n\n        if (present(i)) then\n            ret = i\n        else\n            ret = default\n        end if\n    end function\n"}, "gpt4_result": {"result": true, "instruction": "Create a Fortran function named get_default_ii that takes two input arguments. The first argument, i, is an optional integer, and the second argument, default, is a required integer. The function returns an integer. \n\nThe function checks if the optional argument, i, is present. If it is present, the function assigns the value of i to the result, ret. If i is not present, the function assigns the value of default to ret.", "code": "elemental function get_default_ii(i, default) result(ret)\n    integer, intent(in), optional :: i\n    integer, intent(in) :: default\n    integer :: ret\n\n    if (present(i)) then\n        ret = i\n    else\n        ret = default\n    end if\nend function\n", "reason": "The code has both input parameters (i and default) and output parameters (ret). The code has a logical function which checks if the optional argument i is present and assigns its value to ret if it is, otherwise assigns the value of default to ret. The instruction completely describes this logical function. Both the code and instructions have Fortran domain characteristics."}}
{"data": {"instruction": ["Give me a Fortran function code named get_default_dd that returns a double precision value. The function takes two input arguments: a double precision value (optional) and a default double precision value. The function checks if the first argument is present. If it is, the function returns the value of the first argument. If the first argument is not present, the function returns the value of the second argument.", "Create a Fortran elemental function called get_default_dd that accepts two double precision input arguments, d and default. The function returns a double precision value, ret. The purpose of this function is to return the value of d if it is present, otherwise return the value of default.", "Provide a Fortran function code named get_default_dd that returns a default value if a double precision input argument is not provided. The function takes two input arguments, where the first argument is optional and of type double precision, and the second argument is of type double precision. The function returns a double precision value as the result. If the first input argument is present, the function returns its value; otherwise, it returns the default value specified by the second input argument."], "test_case": {"unit_test": "program main\n  use test_function\n  implicit none\n  double precision :: d, default\n  \n  !case1\n  d = 2.5\n  default = 1.0\n  print *, get_default_dd(d, default)\n  \n  !case2\n  d = -3.25\n  default = 0.0\n  print *, get_default_dd(d, default)\n  \n  !case3\n  d = 0.0\n  default = 10.0\n  print *, get_default_dd(d, default)\n  \n  !case4\n  d = 1.23456789\n  default = 1.23456789\n  print *, get_default_dd(d, default)\n  \n  !case5\n  d = 10000000000.0\n  default = -10000000000.0\n  print *, get_default_dd(d, default)\n  \nend program main", "result": ["2.5000000000000000", "-3.2500000000000000", "0.0000000000000000", "1.2345678806304932", "10000000000.000000"]}, "code": "    elemental function get_default_dd(d, default) result(ret)\n        double precision, intent(in), optional :: d\n        double precision, intent(in) :: default\n\n        double precision :: ret\n\n        if (present(d)) then\n            ret = d\n        else\n            ret = default\n        end if\n    end function\n"}, "gpt4_result": {"result": true, "instruction": "Give me a Fortran function code named get_default_dd that returns a double precision value. The function takes two input arguments: a double precision value (optional) and a default double precision value. The function checks if the first argument is present. If it is, the function returns the value of the first argument. If the first argument is not present, the function returns the value of the second argument.", "code": "elemental function get_default_dd(d, default) result(ret)\n        double precision, intent(in), optional :: d\n        double precision, intent(in) :: default\n\n        double precision :: ret\n\n        if (present(d)) then\n            ret = d\n        else\n            ret = default\n        end if\n    end function\n", "reason": "The provided Fortran function code and instruction meet all the requirements. The code has both input parameters (d and default) and output parameter (ret). The code has a logical function which checks if the first argument is present and returns the appropriate value. The instruction completely describes this logical function. Both the code and instructions have Fortran domain characteristics."}}
